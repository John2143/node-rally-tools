#!/usr/bin/env node
/* Generated by rollup. Written by John Schmidt */
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var rp = _interopDefault(require('request-promise'));
var chalk$1 = _interopDefault(require('chalk'));
var fs = _interopDefault(require('fs'));
var path = require('path');
var argparse = _interopDefault(require('minimist'));
var inquirer = _interopDefault(require('inquirer'));

global.chalk = chalk$1;
global.log = text => console.log(text);
global.write = text => process.stdout.write(text);
global.errorLog = text => log(chalk$1.red(text));

class lib{
    static async makeAPIRequest({env, path: path$$1, path_full, payload, body, json = true, method = "GET", qs, headers = {}, fullResponse = false}){
        //Keys are defined in enviornment variables
        let rally_api_key = process.env[`rally_api_key_${env}`];
        let rally_api = process.env[`rally_api_url_${env}`];

        if(!rally_api && !path_full) return errorLog(`Unsupported env ${env}`);

        path$$1 = path_full || rally_api + path$$1;
        body = body || payload && JSON.stringify(payload);

        if(global.logAPI){
            log(chalk$1`${method} @ ${path$$1}`);
            if(qs){
                log(qs);
            }
        }
        if(payload){
            headers["Content-Type"] = "application/vnd.api+json";
        }

        let requestOptions = {
            method, body, qs, uri: path$$1,
            auth: {bearer: rally_api_key},
            headers: {
                Accept: "application/vnd.api+json",
                ...headers,
            },
            simple: false, resolveWithFullResponse: true,
        };
        let response = await rp(requestOptions);

        if(!fullResponse && ![200, 201, 204].includes(response.statusCode)){
            throw new APIError(response, requestOptions);
        }
        if(fullResponse){
            return response;
        }else if(json){
            return JSON.parse(response.body);
        }else{
            return response.body;
        }
    }
    //Index a json endpoint that returns a {links} field.
    static async indexPath(env, path$$1){
        let all = [];

        let json = await this.makeAPIRequest({env, path: path$$1});

        let [numPages, pageSize] = this.numPages(json.links.last);
        //log(`num pages: ${numPages} * ${pageSize}`);

        all = [...json.data];
        while(json.links.next){
            json = await this.makeAPIRequest({env, path_full: json.links.next});
            all = [...all, ...json.data];
        }

        return all;
    }

    //Returns number of pages and pagination size
    static numPages(str){
        return /page=(\d+)p(\d+)/.exec(str).slice(1);
    }

    //Index a json endpoint that returns a {links} field.
    //
    //This function is faster than indexPath because it can guess the pages it
    //needs to retreive so that it can request all assets at once.
    //
    //This function assumes that the content from the inital request is the
    //first page, so starting on another page may cause issues. Consider
    //indexPath for that.
    static async indexPathFast(env, path$$1){
        let all = [];

        let json = await this.makeAPIRequest({env, path: path$$1});
        let baselink = json.links.first;
        const linkToPage = page => baselink.replace("page=1p", `page=${page}p`);

        let [numPages, pageSize] = this.numPages(json.links.last);
        //log(`num pages: ${numPages} * ${pageSize}`);

        //Construct an array of all the requests that are done simultanously.
        //Assume that the content from the inital request is the first page.
        let promises = [Promise.resolve(json),];
        for(let i = 2; i <= numPages; i++){
            let req = this.makeAPIRequest({env, path_full: linkToPage(i)});
            promises.push(req);
        }

        for(let promise of promises){
            all = [...all, ...(await promise).data];
        }

        return all;
    }
}
class AbortError extends Error{
    constructor(message){
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.name = "AbortError";
    }
}

class APIError extends Error{
    constructor(response, opts){
        super(chalk$1`
{reset Request returned} {yellow ${response.statusCode}}
{green ${JSON.stringify(opts)}}
{reset ${response.body}}
        `);
        Error.captureStackTrace(this, this.constructor);
        this.name = "ApiError";
    }
}

let envs = {};
class Preset{
    constructor({path: path$$1, remote, data}){
        this.remote = remote;
        if(!this.remote){
            this.path = path$$1;
            try{
                this.code = this.getLocalCode();
            }catch(e){
                log(chalk`{red Node Error} e.message`);
                throw new AbortError("Could not load code of local file");
            }
            this.name = this.parseFilenameForName() || this.parseCodeForName();
        }else{
            this.name = data.attributes.name;
            this.id = data.id;
            this.rawData = data;
        }
    }
    chalkPrint(){
        let id = String(this.remote && this.remote + "-" + this.id || "Local").padStart(8);
        return chalk`{green ${id}}: {blue ${this.name}}`;
    }
    parseFilenameForName(){
        if(this.path.endsWith(".jinja") || this.path.endsWith(".json")){
            return path.basename(this.path)
                .replace("_", " ")
                .replace("-", " ");
        }
    }
    parseCodeForName(){
        const name_regex = /name:\s([\w\d. \/]+)[\r\s\n]*?/;
        const match = name_regex.exec(this.code);
        if(match) return match[1];
    }
    findStringsInCode(strings){
        if(!this.code) return [];

        return strings.filter(str => {
            let regex = new Regexp(str);
            return !!this.code.match(regex);
        });
    }
    getPath(){
        return `${process.env.rally_repo_path}/silo-presets/${this.name}.${this.ext}`;
    }
    getMetadataPath(){
        return `${process.env.rally_repo_path}/silo-metadata/${this.name}.json`;
    }
    codeBinary(){
        if(this.code.startsWith("=BASE64=")){
            return bota(this.code.substring(8));
        }else{
            return this.code;
        }
    }
    async uploadPresetData(env, id){
        let res = await lib.makeAPIRequest({
            env, path: `/presets/${id}/providerData`,
            body: this.code, method: "PUT", fullResponse: true
        });
        write(chalk`response {yellow ${res.statusCode}}`);
    }
    async uploadCodeToEnv(env, createFunction){
        write(chalk`Uploading {green ${this.name}} to {green ${env}}: `);

        //First query the api to see if this already exists.
        let res = await lib.makeAPIRequest({
            env, path: `/presets`,
            qs: {filter: `name=${this.name}`},
        });
        let remote = res.data[0];

        if(remote){
            //If it exists we can replace it
            write("replace, ");
            await this.uploadPresetData(env, remote.id);
        }else{
            //If it needs to be created then we need to ask the user for metadata
            write("create, ");
            let metadata = await createFunction(this);
            write("Posting to create preset... ");
            let res = await lib.makeAPIRequest({
                env, path: `/presets`, method: "POST",
                payload: {data: metadata},
            });
            let id = res.data.id;
            write(chalk`Created id {green ${id}}... Uploading Code... `);
            await this.uploadPresetData(env, id);
        }
        log();
    }

    constructMetadata(providerID){
        return {
            attributes: {
                name: this.name,
                //providerSettings: {
                //},
            },
            relationships: {
                providerType: {
                    data: {
                        id: providerID,
                        type: "providerTypes",
                    },
                }
            },
            type: "presets"
        };
    }

    getMetadata(){}
    getLocalCode(){
        return fs.readFileSync(this.path, "utf-8");
    }

    static envs(env){
        return envs[env] = envs[env] || Preset.cache_envs(env);
    }
    static cache_env(env){

    }
}

class Rule{
    constructor(data, remote){
        this.rawData = data;
        this.remote = remote;
    }
    chalkPrint(){
        let D = this.rawData;
        let id = String(this.remote + "-" + D.id).padStart(8);
        return chalk`{green ${id}}: {blue ${D.attributes.name}}`;
    }
}

const rallyFunctions = {
    async bestPagintation(){
        global.silentAPI = true;
        for(let i = 10; i <= 30; i+=5){
            console.time("test with " + i);
            let dl = await lib.indexPathFast("DEV", `/workflowRules?page=1p${i}`);
            console.timeEnd("test with " + i);
        }
    },
    async uploadPresets(env, presets, createFunc = ()=>false){
        for(let preset of presets){
            await preset.uploadCodeToEnv(env, createFunc);
        }
    },
    async getProviders(env){
        let providers = await lib.indexPath(env, "/providerTypes?page=1p50");
        providers = providers.sort((a, b) => {
            return a.attributes.category.localeCompare(b.attributes.category) ||
                   a.attributes.name    .localeCompare(b.attributes.name);
        });
        return providers;
    },
    async getEditorConfig(env, provider){
        let config = await lib.makeAPIRequest({env, path_full: provider.links.editorConfig});
        let helpText = config.helpText;
        config.helpText = () => helpText;
        return config
    },
    async getRules(env){
        let rules = await lib.indexPathFast(env, "/workflowRules?page=1p20");
        return rules;
    },
    async getPresets(env){
        let rules = await lib.indexPathFast(env, "/presets?page=1p20");
        return rules;
    },
};

require("source-map-support").install();

let argv = argparse(process.argv.slice(2), {
    string: ["file", "env"],
    alias: {
        f: "file", e: "env",
    }
});

function prettyPrintProvider(pro){
    let id = String(pro.id).padStart(4);
    return chalk`{green ${id}}: {blue ${pro.attributes.category}} - {green ${pro.attributes.name}}`;
}

let cli = {
    async help(){
        log(this);
    },
    async ["print-args"](args){
        log(args);
    },
    async preset(args){
        let env = args.env;
        let arg = argv._[1];
        if(arg === "upload"){
            let files = args.file;
            if(!files){
                throw new AbortError("No files provided to upload (use --file argument)");
            }
            if(typeof files === "string") files = [files];
            log(chalk`Uploading {green ${files.length}} preset(s) to {green ${env}}.`);

            let presets = files.map(path$$1 => new Preset({path: path$$1, remote: false}));
            await rallyFunctions.uploadPresets(args.env, presets, async preset => {
                log("asking... ");
                let provider = await this["select-provider"](args);
                return preset.constructMetadata(provider.id);
            });
        }else if(arg === "list"){
            log("Loading...");
            let presets = await rallyFunctions.getPresets(env);
            log(chalk`{yellow ${presets.length}} presets on {green ${env}}.`);
            for(let data of presets) log(new Preset({data, remote: env}).chalkPrint());
        }else{
            log("Unknown Action " + arg);
        }
        //log(presets);
    },
    async rule(args){
        let env = args.env;
        let arg = argv._[1];

        if(arg === "list"){
            log("Loading...");
            let rules = await rallyFunctions.getRules(env);
            log(chalk`{yellow ${rules.length}} rules on {green ${env}}.`);
            for(let data of rules) log(new Rule(data, env).chalkPrint());
        }else{
            log("Unknown Action " + arg);
        }
    },
    async providers(args){
        let env = args.env;
        let ident = argv._[1];

        let providers = await rallyFunctions.getProviders(env);

        if(ident){
            let pro = providers.find(x => x.id == ident || x.attributes.name.includes(ident));
            if(!pro){
                log(chalk`Couldn't find provider by {green ${ident}}`);
            }else{
                log(prettyPrintProvider(pro));
                log(await rallyFunctions.getEditorConfig(env, pro));
            }
        }else{
            for(let pro of providers) log(prettyPrintProvider(pro));
        }
    },
    async ["select-provider"](args){
        let env = args.env;

        let providers = await rallyFunctions.getProviders(env);
        let defaultProvider =  providers.find(x => x.attributes.name === "SdviEvaluate");
        if(args.defaultSelect){
            return defaultProvider;
        }else{
            let q = await inquirer.prompt([{
                type: "list",
                name: "provider",
                default: defaultProvider,
                choices: providers.map(x => ({
                    name: prettyPrintProvider(x),
                    value: x,
                })),
            },]);
            return q.provider;
        }
    },
};

async function $main(){
    let func = argv._[0];
    if(cli[func]){
        try{
            let ret = await cli[func](argv);
            if(ret){
                write(chalk.white("CLI returned: "));
                log(ret);
            }
        }catch(e){
            if(e instanceof AbortError){
                log(chalk`{red CLI Aborted}: ${e.message}`);
            }else{
                throw e;
            }
        }
    }else{
        log(`Unknown command '${func}'. Try 'help'`);
    }
}

async function main(...args){
    try{
        await $main(...args);
    }catch(e){
        errorLog(e.stack);
    }
}

main();
//# sourceMappingURL=bundle.js.map

#!/usr/bin/env node
/* Generated by rollup. Written by John Schmidt */
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var rp = _interopDefault(require('request-promise'));
var chalk = _interopDefault(require('chalk'));
var fs = _interopDefault(require('fs'));
var path = require('path');

var minimist = function (args, opts) {
    if (!opts) opts = {};
    
    var flags = { bools : {}, strings : {}, unknownFn: null };

    if (typeof opts['unknown'] === 'function') {
        flags.unknownFn = opts['unknown'];
    }

    if (typeof opts['boolean'] === 'boolean' && opts['boolean']) {
      flags.allBools = true;
    } else {
      [].concat(opts['boolean']).filter(Boolean).forEach(function (key) {
          flags.bools[key] = true;
      });
    }
    
    var aliases = {};
    Object.keys(opts.alias || {}).forEach(function (key) {
        aliases[key] = [].concat(opts.alias[key]);
        aliases[key].forEach(function (x) {
            aliases[x] = [key].concat(aliases[key].filter(function (y) {
                return x !== y;
            }));
        });
    });

    [].concat(opts.string).filter(Boolean).forEach(function (key) {
        flags.strings[key] = true;
        if (aliases[key]) {
            flags.strings[aliases[key]] = true;
        }
     });

    var defaults = opts['default'] || {};
    
    var argv = { _ : [] };
    Object.keys(flags.bools).forEach(function (key) {
        setArg(key, defaults[key] === undefined ? false : defaults[key]);
    });
    
    var notFlags = [];

    if (args.indexOf('--') !== -1) {
        notFlags = args.slice(args.indexOf('--')+1);
        args = args.slice(0, args.indexOf('--'));
    }

    function argDefined(key, arg) {
        return (flags.allBools && /^--[^=]+$/.test(arg)) ||
            flags.strings[key] || flags.bools[key] || aliases[key];
    }

    function setArg (key, val, arg) {
        if (arg && flags.unknownFn && !argDefined(key, arg)) {
            if (flags.unknownFn(arg) === false) return;
        }

        var value = !flags.strings[key] && isNumber(val)
            ? Number(val) : val
        ;
        setKey(argv, key.split('.'), value);
        
        (aliases[key] || []).forEach(function (x) {
            setKey(argv, x.split('.'), value);
        });
    }

    function setKey (obj, keys, value) {
        var o = obj;
        keys.slice(0,-1).forEach(function (key) {
            if (o[key] === undefined) o[key] = {};
            o = o[key];
        });

        var key = keys[keys.length - 1];
        if (o[key] === undefined || flags.bools[key] || typeof o[key] === 'boolean') {
            o[key] = value;
        }
        else if (Array.isArray(o[key])) {
            o[key].push(value);
        }
        else {
            o[key] = [ o[key], value ];
        }
    }
    
    function aliasIsBoolean(key) {
      return aliases[key].some(function (x) {
          return flags.bools[x];
      });
    }

    for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        
        if (/^--.+=/.test(arg)) {
            // Using [\s\S] instead of . because js doesn't support the
            // 'dotall' regex modifier. See:
            // http://stackoverflow.com/a/1068308/13216
            var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
            var key = m[1];
            var value = m[2];
            if (flags.bools[key]) {
                value = value !== 'false';
            }
            setArg(key, value, arg);
        }
        else if (/^--no-.+/.test(arg)) {
            var key = arg.match(/^--no-(.+)/)[1];
            setArg(key, false, arg);
        }
        else if (/^--.+/.test(arg)) {
            var key = arg.match(/^--(.+)/)[1];
            var next = args[i + 1];
            if (next !== undefined && !/^-/.test(next)
            && !flags.bools[key]
            && !flags.allBools
            && (aliases[key] ? !aliasIsBoolean(key) : true)) {
                setArg(key, next, arg);
                i++;
            }
            else if (/^(true|false)$/.test(next)) {
                setArg(key, next === 'true', arg);
                i++;
            }
            else {
                setArg(key, flags.strings[key] ? '' : true, arg);
            }
        }
        else if (/^-[^-]+/.test(arg)) {
            var letters = arg.slice(1,-1).split('');
            
            var broken = false;
            for (var j = 0; j < letters.length; j++) {
                var next = arg.slice(j+2);
                
                if (next === '-') {
                    setArg(letters[j], next, arg);
                    continue;
                }
                
                if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {
                    setArg(letters[j], next.split('=')[1], arg);
                    broken = true;
                    break;
                }
                
                if (/[A-Za-z]/.test(letters[j])
                && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
                    setArg(letters[j], next, arg);
                    broken = true;
                    break;
                }
                
                if (letters[j+1] && letters[j+1].match(/\W/)) {
                    setArg(letters[j], arg.slice(j+2), arg);
                    broken = true;
                    break;
                }
                else {
                    setArg(letters[j], flags.strings[letters[j]] ? '' : true, arg);
                }
            }
            
            var key = arg.slice(-1)[0];
            if (!broken && key !== '-') {
                if (args[i+1] && !/^(-|--)[^-]/.test(args[i+1])
                && !flags.bools[key]
                && (aliases[key] ? !aliasIsBoolean(key) : true)) {
                    setArg(key, args[i+1], arg);
                    i++;
                }
                else if (args[i+1] && /true|false/.test(args[i+1])) {
                    setArg(key, args[i+1] === 'true', arg);
                    i++;
                }
                else {
                    setArg(key, flags.strings[key] ? '' : true, arg);
                }
            }
        }
        else {
            if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
                argv._.push(
                    flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)
                );
            }
            if (opts.stopEarly) {
                argv._.push.apply(argv._, args.slice(i + 1));
                break;
            }
        }
    }
    
    Object.keys(defaults).forEach(function (key) {
        if (!hasKey(argv, key.split('.'))) {
            setKey(argv, key.split('.'), defaults[key]);
            
            (aliases[key] || []).forEach(function (x) {
                setKey(argv, x.split('.'), defaults[key]);
            });
        }
    });
    
    if (opts['--']) {
        argv['--'] = new Array();
        notFlags.forEach(function(key) {
            argv['--'].push(key);
        });
    }
    else {
        notFlags.forEach(function(key) {
            argv._.push(key);
        });
    }

    return argv;
};

function hasKey (obj, keys) {
    var o = obj;
    keys.slice(0,-1).forEach(function (key) {
        o = (o[key] || {});
    });

    var key = keys[keys.length - 1];
    return key in o;
}

function isNumber (x) {
    if (typeof x === 'number') return true;
    if (/^0x[0-9a-f]+$/i.test(x)) return true;
    return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
}

global.log = console.log;
global.errorLog = text => log(chalk.red(text));

class lib{
    static async makeAPIRequest({env, path: path$$1, path_full, payload, body, json = true, method = "GET", qs, headers = {}, fullResponse = false}){
        //Keys are defined in enviornment variables
        let rally_api_key = process.env[`rally_api_key_${env}`];
        let rally_api = process.env[`rally_api_url_${env}`];

        if(!rally_api && !path_full) return errorLog(`Unsupported env ${env}`);

        path$$1 = path_full || rally_api + path$$1;
        body = body || payload && JSON.stringify(payload);

        if(!global.silentAPI){
            log(chalk`${method} @ ${path$$1}`);
            if(qs){
                log(qs);
            }
        }

        let response = await rp({
            method, body, qs, uri: path$$1,
            auth: {bearer: rally_api_key},
            headers: {
                Accept: "application/vnd.api+json",
                ...headers,
            },
            simple: false, resolveWithFullResponse: true,
        });

        if(![200, 201, 204].includes(response.statusCode)){
            errorLog(response);
            throw new Error("Api result error");
        }
        if(json){
            return JSON.parse(response.body);
        }else if(fullResponse){
            return response;
        }else{
            return response.body;
        }
    }
    //Index a json endpoint that returns a {links} field.
    static async indexPath(env, path$$1){
        let all = [];

        let json = await this.makeAPIRequest({env, path: path$$1});

        let [numPages, pageSize] = this.numPages(json.links.last);
        log(`num pages: ${numPages} * ${pageSize}`);

        all = [...json.data];
        while(json.links.next){
            json = await this.makeAPIRequest({env, path_full: json.links.next});
            all = [...all, ...json.data];
        }

        return all;
    }

    //Returns number of pages and pagination size
    static numPages(str){
        return /page=(\d+)p(\d+)/.exec(str).slice(1);
    }

    //Index a json endpoint that returns a {links} field.
    //
    //This function is faster than indexPath because it can guess the pages it
    //needs to retreive so that it can request all assets at once.
    //
    //This function assumes that the content from the inital request is the
    //first page, so starting on another page may cause issues. Consider
    //indexPath for that.
    static async indexPathFast(env, path$$1){
        let all = [];

        let json = await this.makeAPIRequest({env, path: path$$1});
        let baselink = json.links.first;
        const linkToPage = page => baselink.replace("page=1p", `page=${page}p`);

        let [numPages, pageSize] = this.numPages(json.links.last);
        log(`num pages: ${numPages} * ${pageSize}`);

        //Construct an array of all the requests that are done simultanously.
        //Assume that the content from the inital request is the first page.
        let promises = [Promise.resolve(json),];
        for(let i = 2; i <= numPages; i++){
            let req = this.makeAPIRequest({env, path_full: linkToPage(i)});
            promises.push(req);
        }

        for(let promise of promises){
            all = [...all, ...(await promise).data];
        }

        return all;
    }
}
class AbortError extends Error{
    constructor(message){
        super(message);
        Error.captureStackTrace(this, this.constructor);
    }
}

let envs = {};
class Preset{
    constructor({path: path$$1, remote}){
        this.remote = remote;
        if(!this.remote){
            this.path = path$$1;
            try{
                this.code = this.getLocalCode();
            }catch(e){
                log(chalk`{red Node Error} e.message`);
                throw new AbortError("Could not load code of local file");
            }
            this.name = this.parseFilenameForName() || this.parseCodeForName();
        }
    }
    toString(){
        return `<Preset ${this.name} on ${this.remote || "~local"}>`;
    }
    parseFilenameForName(){
        if(this.path.endsWith(".jinja") || this.path.endsWith(".json")){
            return path.basename(this.path)
                .replace("_", " ")
                .replace("-", " ");
        }
    }
    parseCodeForName(){
        const name_regex = /name:\s([\w\d. \/]+)[\r\s\n]*?/;
        const match = name_regex.exec(this.code);
        if(match) return match[1];
    }
    findStringsInCode(strings){
        if(!this.code) return [];

        return strings.filter(str => {
            let regex = new Regexp(str);
            return !!this.code.match(regex);
        });
    }
    getPath(){
        return `${process.env.rally_repo_path}/silo-presets/${this.name}.${this.ext}`;
    }
    getMetadataPath(){
        return `${process.env.rally_repo_path}/silo-metadata/${this.name}.json`;
    }
    codeBinary(){
        if(this.code.startsWith("=BASE64=")){
            return bota(this.code.substring(8));
        }else{
            return this.code;
        }
    }
    async postPresetData(env, id){
    }
    async uploadCodeToEnv(env){
        log(chalk`Uploading {green ${this.name}} to {green ${env}}`);
        let res = await lib.makeAPIRequest({
            env, path: `/presets`,
            qs: {filter: `name=${this.name}aaa`},
        });
        let remote = res.data[0];
        if(remote){
            res = await lib.makeAPIRequest({
                env, path: `/presets/${remote.id}/providerData`,
                body: this.code,
            });
            log(res);
        }else{
            log("Non existant");
            //create if python
        }
    }

    getMetadata(){}
    getLocalCode(){
        return fs.readFileSync(this.path, "utf-8");
    }

    static envs(env){
        return envs[env] = envs[env] || Preset.cache_envs(env);
    }
    static cache_env(env){

    }
}

const rallyFunctions = {
    async bestPagintation(){
        global.silentAPI = true;
        for(let i = 10; i <= 30; i+=5){
            console.time("test with " + i);
            let dl = await lib.indexPathFast("DEV", `/workflowRules?page=1p${i}`);
            console.timeEnd("test with " + i);
        }
    },
    async uploadPresets(env, presets){
        for(let preset of presets){
            await preset.uploadCodeToEnv(env);
        }
    },
    async getProviders(env){
        let index = lib.indexPath(env, "/providerTypes");
        log(index);
    },
};

let argv = minimist(process.argv.slice(2), {
    string: ["file", "env"],
    alias: {
        f: "file", e: "env",
    }
});

let cli = {
    async help(){
        log(this);
    },
    async ["print-args"](args){
        log(args);
    },
    async ["upload-preset"](args){
        let env = args.env;
        let files = args.file;
        if(typeof args.file === "string") files = [files];
        log(chalk`Uploading {green ${files.length}} preset(s) to {green ${env}}.`);

        let presets = files.map(path$$1 => new Preset({path: path$$1, remote: false}));
        await rallyFunctions.uploadPresets(args.env, presets);
        //log(presets);
    },
    async ["list-providers"](args){
        let env = args.env;
        rallyFunctions.getProviders(env);
    },
};

async function $main(){
    let func = argv._[0];
    if(cli[func]){
        try{
            await cli[func](argv);
        }catch(e){
            if(e instanceof AbortError){
                log(chalk`{red CLI Aborted}: ${e.message}`);
            }else{
                throw e;
            }
        }
    }else{
        log(`Unknown command '${func}'. Try 'help'`);
    }
}

async function main(...args){
    try{
        await $main(...args);
    }catch(e){
        errorLog(e.stack);
    }
}

main();

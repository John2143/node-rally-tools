#!/usr/bin/env node
/*----------------------------------------------
 * Generated by rollup. Written by John Schmidt.
 * Rally Tools CLI v1.10.1
 *--------------------------------------------*/
const importLazy = require("import-lazy")(require);

'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var argparse = _interopDefault(require('minimist'));
var chalk$1 = _interopDefault(require('chalk'));
var os = require('os');
var fs = require('fs');
var child_process = require('child_process');
var perf_hooks = require('perf_hooks');
var path = require('path');
var path__default = _interopDefault(path);

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

let configFile = os.homedir() + "/.rallyconfig";
let configObject;
function loadConfig(file) {
  if (file) configFile = file;
  configObject = {
    hasConfig: true
  };

  try {
    let json = fs.readFileSync(configFile);
    configObject = JSON.parse(json);
  } catch (e) {
    if (e.code == "ENOENT") {
      configObject.hasConfig = false; //ok, they should probably make a config
    } else {
      throw e;
    }
  }
}
function setConfig(obj) {
  configObject = obj;
}
loadConfig();

//these are the help entries for each command
let helpEntries = {};

let helpEntry = name => helpEntries[name] ? helpEntries[name] : helpEntries[name] = {
  name
}; //short description


function helpText(text) {
  return function (func, name) {
    helpEntry(name).text = text;
    return func;
  };
} //flag type argument like -f or --file

function arg(long, short, desc) {
  return function (func, name) {
    let args = helpEntry(name).args = helpEntry(name).args || [];
    args.unshift({
      long,
      short,
      desc
    });
    return func;
  };
} //normal argument

function param(param, desc) {
  return function (func, name) {
    let params = helpEntry(name).params = helpEntry(name).params || [];
    params.unshift({
      param,
      desc
    });
    return func;
  };
} //usage string

function usage(usage) {
  return function (func, name) {
    usage = usage.replace(/[\[<](\w+)[\]>]/g, chalk`[{blue $1}]`);
    helpEntry(name).usage = usage;
    return func;
  };
}
//function retuns obj.a.b.c

function deepAccess(obj, path$$1) {
  let o = obj;

  for (let key of path$$1) {
    if (!o) return [];
    o = o[key];
  }

  return o;
} //This takes a class as the first argument, then adds a getter/setter pair that
//corresponds to an object in this.data


function defineAssoc(classname, shortname, path$$1) {
  path$$1 = path$$1.split(".");
  let lastKey = path$$1.pop();
  Object.defineProperty(classname.prototype, shortname, {
    get() {
      return deepAccess(this, path$$1)[lastKey];
    },

    set(val) {
      deepAccess(this, path$$1)[lastKey] = val;
    }

  });
}

function spawn(options, ...args) {
  if (typeof options !== "object") {
    args.unshift(options);
    options = {};
  } //todo options


  return new Promise((resolve, reject) => {
    let start = perf_hooks.performance.now();
    let stdout = "";
    let stderr = "";
    let cp = child_process.spawn(...args);
    if (cp.stdout) cp.stdout.on("data", chunk => {
      stdout += chunk;
      write(chunk);
    });
    if (cp.stderr) cp.stderr.on("data", chunk => {
      stderr += chunk;
      write(chunk);
    });
    cp.on("error", reject);
    cp.on("close", code => {
      let end = perf_hooks.performance.now();
      let time = end - start;
      let timestr = time > 1000 ? (time / 100 | 0) / 10 + "s" : (time | 0) + "ms";
      resolve({
        stdout,
        stderr,
        exitCode: code,
        time,
        timestr
      });
    });
  });
}

const rp = importLazy("request-promise");
global.chalk = chalk$1;

global.log = text => console.log(text);

global.write = text => process.stdout.write(text);

global.errorLog = text => log(chalk$1.red(text));

class lib {
  //This function takes 2 required arguemnts:
  // env: the enviornment you wish to use
  // and either:
  //  'path', the short path to the resource. ex '/presets/'
  //  'path_full', the full path to the resource like 'https://discovery-dev.sdvi.com/presets'
  //
  // If the method is anything but GET, either payload or body should be set.
  // payload should be a javascript object to be turned into json as the request body
  // body should be a string that is passed as the body. for example: the python code of a preset.
  //
  // qs are the querystring parameters, in a key: value object.
  // {filter: "name=test name"} becomes something like 'filter=name=test+name'
  //
  // headers are the headers of the request. "Content-Type" is already set if
  //   payload is given as a parameter
  //
  // fullResponse should be true if you want to receive the request object,
  //  not just the returned data.
  static async makeAPIRequest({
    env,
    path: path$$1,
    path_full,
    payload,
    body,
    method = "GET",
    qs,
    headers = {},
    fullResponse = false,
    timeout = configObject.timeout || 20000
  }) {
    var _configObject$api;

    //Keys are defined in enviornment variables
    let config = configObject === null || configObject === void 0 ? void 0 : (_configObject$api = configObject.api) === null || _configObject$api === void 0 ? void 0 : _configObject$api[env];

    if (!config) {
      throw new UnconfiguredEnvError(env);
    }

    if (method !== "GET" && !configObject.dangerModify) {
      if (env === "UAT" && configObject.restrictUAT || env === "PROD") {
        throw new ProtectedEnvError(env);
      }
    }

    let rally_api_key = config.key;
    let rally_api = config.url;
    path$$1 = path_full || rally_api + path$$1;

    if (payload) {
      body = JSON.stringify(payload, null, 4);
    }

    if (configObject.vverbose) {
      log(chalk$1`${method} @ ${path$$1}`);

      if (qs) {
        log(qs);
      }
    }

    if (payload) {
      headers["Content-Type"] = "application/vnd.api+json";
    }

    let requestOptions = {
      method,
      body,
      qs,
      uri: path$$1,
      timeout,
      auth: {
        bearer: rally_api_key
      },
      headers: {
        //SDVI ignores this header sometimes.
        Accept: "application/vnd.api+json",
        ...headers
      },
      simple: false,
      resolveWithFullResponse: true
    };
    let response;

    try {
      response = await rp(requestOptions);
    } catch (e) {
      if ((e === null || e === void 0 ? void 0 : e.cause.code) === "ESOCKETTIMEDOUT") {
        throw new APIError(response || {}, requestOptions, body);
      } else {
        throw e;
      }
    } //Throw an error for any 5xx or 4xx


    if (!fullResponse && ![200, 201, 204].includes(response.statusCode)) {
      throw new APIError(response, requestOptions, body);
    }

    let contentType = response.headers["content-type"];
    let isJSONResponse = contentType === "application/vnd.api+json" || contentType === "application/json";

    if (fullResponse) {
      return response;
    } else if (isJSONResponse) {
      try {
        return JSON.parse(response.body);
      } catch (e) {
        log(response.body);
        throw new AbortError("Body is not valid json: ");
      }
    } else {
      return response.body;
    }
  } //Index a json endpoint that returns a {links} field.
  //This function returns the merged data objects as an array
  //
  //Additonal options (besides makeAPIRequest options):
  // - Observe: function to be called for each set of data from the api


  static async indexPath(env, path$$1) {
    let all = [];
    let opts = typeof env === "string" ? {
      env,
      path: path$$1
    } : env;
    let json = await this.makeAPIRequest(opts);
    let [numPages, pageSize] = this.numPages(json.links.last); //log(`num pages: ${numPages} * ${pageSize}`);

    all = [...json.data];

    while (json.links.next) {
      json = await this.makeAPIRequest({ ...opts,
        path_full: json.links.next
      });
      if (opts.observe) opts.observe(json.data);
      all = [...all, ...json.data];
    }

    return all;
  } //Returns number of pages and pagination size


  static numPages(str) {
    return /page=(\d+)p(\d+)/.exec(str).slice(1);
  }

  static arrayChunk(array, chunkSize) {
    let newArr = [];

    for (let i = 0; i < array.length; i += chunkSize) {
      newArr.push(array.slice(i, i + chunkSize));
    }

    return newArr;
  }

  static async doPromises(promises, result = [], cb) {
    for (let promise of promises) {
      let res = await promise;
      result.push(res);

      if (cb) {
        cb(res.data);
      }
    }

    return result;
  }

  static async drawProgress(i, max, size = 30) {
    let pct = Number(i) / Number(max); //clamp between 0 and 1

    pct = pct < 0 ? 0 : pct > 1 ? 1 : pct;
    let numFilled = Math.floor(pct * size);
    let numEmpty = size - numFilled;
    process.stderr.write(`\r${" ".repeat(size + 8)}\r[${"*".repeat(numFilled)}${" ".repeat(numEmpty)}] ${i} / ${max}`);
  } //TODO implelement
  //static async processPromises({
  //promiseGenerator, chunksize, startingPromises = [],
  //observe,
  //}){
  //let promises = startingPromises
  //for(let promise of promiseGenerator()){
  //}
  //}
  //Index a json endpoint that returns a {links} field.
  //
  //This function is faster than indexPath because it can guess the pages it
  //needs to retreive so that it can request all assets at once.
  //
  //This function assumes that the content from the inital request is the
  //first page, so starting on another page may cause issues. Consider
  //indexPath for that.
  //
  //Additional opts, besides default indexPath opts:
  // - chunksize[10]: How often to break apart concurrent requests


  static async indexPathFast(env, path$$1) {
    let opts = typeof env === "string" ? {
      env,
      path: path$$1
    } : env;
    let json = await this.makeAPIRequest(opts);
    let baselink = json.links.first;

    const linkToPage = page => baselink.replace("page=1p", `page=${page}p`);

    let [numPages, pageSize] = this.numPages(json.links.last); //log(`num pages: ${numPages} * ${pageSize}`);
    //Construct an array of all the requests that are done simultanously.
    //Assume that the content from the inital request is the first page.

    let allResults = [];
    let promises = [Promise.resolve(json)];
    opts.chunksize = opts.chunksize || 10;

    for (let i = 2; i <= (opts.limit ? opts.limit : numPages); i++) {
      this.drawProgress(i, opts.limit || numPages);

      if (promises.length === opts.chunksize) {
        await this.doPromises(promises, allResults, opts.observe);
        promises = [];
      }

      let req = this.makeAPIRequest({ ...opts,
        path_full: linkToPage(i)
      });
      promises.push(req);
    }

    await this.doPromises(promises, allResults, opts.observe);
    let all = [];

    for (let result of allResults) {
      for (let item of result.data) {
        all.push(item);
      }
    }

    return all;
  }

  static isLocalEnv(env) {
    return !env || env === "LOCAL" || env === "LOC";
  }

  static envName(env) {
    if (this.isLocalEnv(env)) return "LOCAL";
    return env;
  }

}
class AbortError extends Error {
  constructor(message) {
    super(message);
    Error.captureStackTrace(this, this.constructor);
    this.name = "AbortError";
  }

}
class APIError extends Error {
  constructor(response, opts, body) {
    super(chalk$1`
{reset Request returned} {yellow ${response === null || response === void 0 ? void 0 : response.statusCode}}{
{green ${JSON.stringify(opts, null, 4)}}
{green ${body}}
{reset ${response.body}}
===============================
{red ${response.body ? "Request timed out" : "Bad response from API"}}
===============================
        `);
    this.response = response;
    this.opts = opts;
    this.body = body;
    Error.captureStackTrace(this, this.constructor);
    this.name = "ApiError";
  }

}
class UnconfiguredEnvError extends AbortError {
  constructor(env) {
    super("Unconfigured enviornment: " + env);
    this.name = "Unconfigured Env Error";
  }

}
class ProtectedEnvError extends AbortError {
  constructor(env) {
    super("Protected enviornment: " + env);
    this.name = "Protected Env Error";
  }

}
class Collection {
  constructor(arr) {
    this.arr = arr;
  }

  [Symbol.iterator]() {
    return this.arr[Symbol.iterator]();
  }

  findById(id) {
    return this.arr.find(x => x.id == id);
  }

  findByName(name) {
    return this.arr.find(x => x.name == name);
  }

  findByNameContains(name) {
    return this.arr.find(x => x.name.includes(name));
  }

  log() {
    for (let d of this) {
      if (d) {
        log(d.chalkPrint(true));
      } else {
        log(chalk$1`{red (None)}`);
      }
    }
  }

  get length() {
    return this.arr.length;
  }

}
class RallyBase {
  static isLoaded(env) {
    if (!this.hasLoadedAll) return;
    return this.hasLoadedAll[env];
  }

  static async getById(env, id, qs) {
    if (this.isLoaded(env)) {
      return (await this.getAll(env)).findById(id);
    } else {
      let data = await lib.makeAPIRequest({
        env,
        path: `/${this.endpoint}/${id}`,
        qs
      });
      if (data.data) return new this({
        data: data.data,
        remote: env,
        included: data.included
      });
    }
  }

  static async getByName(env, name, qs) {
    if (this.isLoaded(env)) {
      return (await this.getAll(env)).findByName(name);
    } else {
      let data = await lib.makeAPIRequest({
        env,
        path: `/${this.endpoint}`,
        qs: { ...qs,
          filter: `name=${name}` + (qs ? qs.filter : "")
        }
      }); //TODO included might not wokr correctly here

      if (data.data[0]) return new this({
        data: data.data[0],
        remote: env,
        included: data.included
      });
    }
  }

  static async getAllPreCollect(d) {
    return d;
  }

  static async getAll(env) {
    this.hasLoadedAll = this.hasLoadedAll || {};
    if (this.isLoaded(env)) return this.hasLoadedAll[env];
    let datas = await lib.indexPathFast(env, `/${this.endpoint}?page=1p10`);
    datas = await this.getAllPreCollect(datas);
    let all = new Collection(datas.map(data => new this({
      data,
      remote: env
    })));
    this.hasLoadedAll[env] = all;
    return all;
  }

  static async removeCache(env) {
    this.hasLoadedAll = this.hasLoadedAll || {};

    if (this.isLoaded(env)) {
      this.hasLoadedAll[env] = undefined;
    }
  } //Specific turns name into id based on env
  //Generic turns ids into names


  async resolveApply(type, dataObj, direction) {
    let obj;

    if (direction == "generic") {
      obj = await type.getById(this.remote, dataObj.id);

      if (obj) {
        dataObj.name = obj.name;
      }
    } else if (direction == "specific") {
      obj = await type.getByName(this.remote, dataObj.name);

      if (obj) {
        dataObj.id = obj.id;
      }
    }

    return obj;
  } //Type is the baseclass you are looking for (should extend RallyBase)
  //name is the name of the field
  //isArray is true if it has multiple cardinailty, false if it is single
  //direction gets passed directly to resolveApply


  async resolveField(type, name, isArray = false, direction = "generic") {
    // ignore empty fields
    let field = this.relationships[name];
    if (!(field === null || field === void 0 ? void 0 : field.data)) return;

    if (isArray) {
      return await Promise.all(field.data.map(o => this.resolveApply(type, o, direction)));
    } else {
      return await this.resolveApply(type, field.data, direction);
    }
  }

  cleanup() {
    for (let [key, val] of Object.entries(this.relationships)) {
      //Remove ids from data
      if (val.data) {
        if (val.data.id) {
          delete val.data.id;
        } else if (val.data[0]) {
          for (let x of val.data) delete x.id;
        }
      }

      delete val.links;
    } // organization is unused (?)


    delete this.relationships.organization; // id is specific to envs

    delete this.data.id; // links too

    delete this.data.links;
  }

}

class Provider extends RallyBase {
  constructor({
    data,
    remote
  }) {
    super();
    this.data = data;
    this.meta = {};
    this.remote = remote;
  } //cached


  async getEditorConfig() {
    if (this.editorConfig) return this.editorConfig;
    this.editorConfig = await lib.makeAPIRequest({
      env: this.remote,
      path_full: this.data.links.editorConfig
    });
    this.editorConfig.fileExt = await this.getFileExtension();
    return this.editorConfig;
  }

  static async getAllPreCollect(providers) {
    return providers.sort((a, b) => {
      return a.attributes.category.localeCompare(b.attributes.category) || a.attributes.name.localeCompare(b.attributes.name);
    });
  }

  async getFileExtension() {
    let config = await this.getEditorConfig();
    let map = {
      python: "py",
      text: "txt",

      getmap(key) {
        if (this.name === "Aurora") return "zip";
        if (this[key]) return this[key];
        return key;
      }

    };
    return map.getmap(config.lang);
  }

  chalkPrint(pad = true) {
    let id = String(this.id);
    if (pad) id = id.padStart(4);
    return chalk`{green ${id}}: {blue ${this.category}} - {green ${this.name}}`;
  }

}

defineAssoc(Provider, "id", "data.id");
defineAssoc(Provider, "name", "data.attributes.name");
defineAssoc(Provider, "category", "data.attributes.category");
defineAssoc(Provider, "remote", "meta.remote");
defineAssoc(Provider, "editorConfig", "meta.editorConfig");
Provider.endpoint = "providerTypes";

class Asset extends RallyBase {
  constructor({
    data,
    remote,
    included
  }) {
    super();
    this.data = data;
    this.meta = {};
    this.remote = remote;

    if (included) {
      this.meta.metadata = this.normalizeMetadata(included);
    }
  }

  static normalizeMetadata(payload) {
    let newMetadata = {};

    for (let md of payload) {
      if (md.type !== "metadata") continue;
      newMetadata[md.attributes.usage] = md.attributes.metadata;
    }

    return newMetadata;
  }

  static lite(id, remote) {
    return new this({
      data: {
        id
      },
      remote
    });
  }

  chalkPrint(pad = false) {
    let id = String("A-" + (this.remote && this.remote + "-" + this.id || "LOCAL"));
    if (pad) id = id.padStart(7);
    return chalk`{green ${id}}: {blue ${this.data.attributes ? this.name : "(lite asset)"}}`;
  }

  static async createNew(name, env) {
    let req = await lib.makeAPIRequest({
      env,
      path: "/assets",
      method: "POST",
      payload: {
        data: {
          attributes: {
            name
          },
          type: "assets"
        }
      }
    });
    return new this({
      data: req.data,
      remote: env
    });
  }

  async delete() {
    let req = await lib.makeAPIRequest({
      env: this.remote,
      path: "/assets/" + this.id,
      method: "DELETE"
    });
  }

  async addFile(label, fileuris) {
    if (!Array.isArray(fileuris)) fileuris = [fileuris];
    let instances = {};

    for (let i = 0; i < fileuris.length; i++) {
      instances[String(i + 1)] = {
        uri: fileuris[i]
      };
    }

    let req = await lib.makeAPIRequest({
      env: this.remote,
      path: "/files",
      method: "POST",
      payload: {
        "data": {
          "attributes": {
            label,
            instances
          },
          "relationships": {
            "asset": {
              "data": {
                id: this.id,
                "type": "assets"
              }
            }
          },
          "type": "files"
        }
      }
    });
    return req;
  }

  async startWorkflow(jobName, initData) {
    let attributes;

    if (initData) {
      //Convert init data to string
      initData = typeof initData === "string" ? initData : JSON.stringify(initData);
      attributes = {
        initData
      };
    }

    let req = await lib.makeAPIRequest({
      env: this.remote,
      path: "/workflows",
      method: "POST",
      payload: {
        "data": {
          "type": "workflows",
          attributes,
          "relationships": {
            "movie": {
              "data": {
                id: this.id,
                "type": "movies"
              }
            },
            "rule": {
              "data": {
                "attributes": {
                  "name": jobName
                },
                "type": "rules"
              }
            }
          }
        }
      }
    });
    return req;
  }

  async startEvaluate(env, presetid) {
    // Fire and forget.
    let data = await lib.makeAPIRequest({
      env,
      path: "/jobs",
      method: "POST",
      payload: {
        data: {
          type: "jobs",
          relationships: {
            movie: {
              data: {
                id: this.id,
                type: "movies"
              }
            },
            preset: {
              data: {
                id: presetid,
                type: "presets"
              }
            }
          }
        }
      }
    });
    return data;
  }

}

defineAssoc(Asset, "id", "data.id");
defineAssoc(Asset, "name", "data.attributes.name");
defineAssoc(Asset, "remote", "meta.remote");
defineAssoc(Asset, "md", "meta.metadata");
Asset.endpoint = "movies";

let exists = {};

class Preset extends RallyBase {
  constructor({
    path: path$$1,
    remote,
    data
  } = {}) {
    // Get full path if possible
    if (path$$1) {
      path$$1 = path.resolve(path$$1);

      if (path.dirname(path$$1).includes("silo-metadata")) {
        throw new AbortError("Constructing preset from metadata file");
      }
    }

    super(); // Cache by path

    if (path$$1) {
      if (exists[path$$1]) return exists[path$$1];
      exists[path$$1] = this;
    }

    this.meta = {};
    this.remote = remote;

    if (lib.isLocalEnv(this.remote)) {
      if (path$$1) {
        this.path = path$$1;
        let pathspl = this.path.split(".");
        this.ext = pathspl[pathspl.length - 1];

        try {
          this.code = this.getLocalCode();
        } catch (e) {
          if (e.code === "ENOENT" && configObject.ignoreMissing) {
            this.missing = true;
            return undefined;
          } else {
            log(chalk`{red Node Error} ${e.message}`);
            throw new AbortError("Could not load code of local file");
          }
        }

        let name = this.parseFilenameForName() || this.parseCodeForName();

        try {
          this.data = this.getLocalMetadata();
          this.isGeneric = true;
          name = this.name;
        } catch (e) {
          log(chalk`{yellow Warning}: ${path$$1} does not have a readable metadata file! Looking for ${this.localmetadatapath}`);
          this.data = Preset.newShell();
          this.isGeneric = false;
        }

        this.name = name;
      } else {
        this.data = Preset.newShell();
      }
    } else {
      this.data = data; //this.name = data.attributes.name;
      //this.id = data.id;

      this.isGeneric = false;
    }
  } //Given a metadata file, get its actualy file


  static async fromMetadata(path$$1) {
    try {
      let data = JSON.parse(readFileSync(path$$1));
    } catch (e) {
      if (e.code === "ENOENT" && configObject.ignoreMissing) {
        return null;
      } else {
        throw e;
      }
    }

    let provider = await Provider.getByName("DEV", data.relationships.providerType.data.name);
    let ext = await provider.getFileExtension();
    let name = data.attributes.name;
    let realpath = Preset.getLocalPath(name, ext);
    return new Preset({
      path: realpath
    });
  }

  static newShell() {
    return {
      "attributes": {
        "providerSettings": {}
      },
      "relationships": {},
      "type": "presets"
    };
  }

  cleanup() {
    super.cleanup();
    delete this.attributes["createdAt"];
    delete this.attributes["updatedAt"];
  }

  async acclimatize(env) {
    if (!this.isGeneric) throw new AbortError("Cannot acclimatize non-generics or shells");
    let providers = await Provider.getAll(env);
    let ptype = this.relationships["providerType"];
    ptype = ptype.data;
    let provider = providers.findByName(ptype.name);
    ptype.id = provider.id;
  }

  get test() {
    if (!this.code) return;
    const regex = /[^-]autotest:\s?([\w\d_\-. \/]+)[\r\s\n]*?/gm;
    let match;
    let matches = [];

    while (match = regex.exec(this.code)) {
      matches.push(match[1]);
    }

    return matches;
  }

  async runTest(env) {
    let remote = await Preset.getByName(env, this.name);

    for (let test of this.test) {
      let asset;

      if (test.startsWith("id")) {
        let match = /id:\s*(\d+)/g.exec(test);

        if (!match) {
          log(chalk`{red Could not parse autotest} ${test}.`);
          throw new AbortError("Could not properly parse the preset header");
        }

        asset = await Asset.getById(env, match[1]);
      } else {
        asset = await Asset.getByName(env, test);
      }

      if (!asset) {
        log(chalk`{yellow No movie found}, skipping test.`);
        continue;
      }

      write(chalk`Starting job {green ${this.name}} on ${asset.chalkPrint(false)}... `);
      await asset.startEvaluate(env, remote.id);
    }
  }

  async resolve() {
    if (this.isGeneric) return;
    let proType = await this.resolveField(Provider, "providerType");
    this.ext = await proType.getFileExtension();
    this.isGeneric = true;
    return {
      proType
    };
  }

  async saveLocal() {
    await this.saveLocalMetadata();
    await this.saveLocalFile();
  }

  async saveLocalMetadata() {
    if (!this.isGeneric) {
      await this.resolve();
      this.cleanup();
    }

    fs.writeFileSync(this.localmetadatapath, JSON.stringify(this.data, null, 4));
  }

  async saveLocalFile() {
    fs.writeFileSync(this.localpath, this.code);
  }

  async uploadRemote(env) {
    await this.uploadCodeToEnv(env, true);
  }

  async save(env) {
    this.saved = true;

    if (!this.isGeneric) {
      await this.resolve();
    }

    this.cleanup();

    if (lib.isLocalEnv(env)) {
      log(chalk`Saving {green ${this.name}} to {blue ${lib.envName(env)}}.`);
      await this.saveLocal();
    } else {
      await this.uploadRemote(env);
    }
  }

  async downloadCode() {
    if (!this.remote || this.code) return this.code;
    return this.code = await lib.makeAPIRequest({
      env: this.remote,
      path_full: this.data.links.providerData,
      json: false
    });
  }

  get code() {
    if (this._code) return this._code;
  }

  set code(v) {
    this._code = v;
  }

  chalkPrint(pad = true) {
    let id = String("P-" + (this.remote && this.remote + "-" + this.id || "LOCAL"));
    if (pad) id = id.padStart(10);

    if (this.meta.proType) {
      return chalk`{green ${id}}: {red ${this.meta.proType.name}} {blue ${this.name}}`;
    } else {
      return chalk`{green ${id}}: {blue ${this.name}}`;
    }
  }

  parseFilenameForName() {
    if (this.path.endsWith(".jinja") || this.path.endsWith(".json")) {
      return path.basename(this.path).replace("_", " ").replace("-", " ").replace(".json", "").replace(".jinja", "");
    }
  }

  parseCodeForName() {
    const name_regex = /name\s?:\s([\w\d. \/]+)[\r\s\n]*?/;
    const match = name_regex.exec(this.code);
    if (match) return match[1];
  }

  findStringsInCode(strings) {
    if (!this.code) return [];
    return strings.filter(str => {
      let regex = new RegExp(str);
      return !!this.code.match(regex);
    });
  }

  static getLocalPath(name, ext) {
    return path__default.join(configObject.repodir, "silo-presets", name + "." + ext);
  }

  get localpath() {
    return Preset.getLocalPath(this.name, this.ext);
  }

  get path() {
    if (this._path) return this._path;
  }

  set path(val) {
    this._path = val;
  }

  get name() {
    return this._nameOuter;
  }

  set name(val) {
    this._nameInner = val;
    this._nameOuter = val;
  }

  set providerType(value) {
    this.relationships["providerType"] = {
      data: { ...value,
        type: "providerTypes"
      }
    };
  }

  get localmetadatapath() {
    let fname = this.name;

    if (!fname && this.path) {
      let bname = path.basename(this.path);
      fname = bname.substring(0, bname.length - (this.ext.length + 1));
    }

    return path__default.join(configObject.repodir, "silo-metadata", fname + ".json");
  }

  get immutable() {
    return this.name.includes("Constant");
  }

  async uploadPresetData(env, id) {
    let res = await lib.makeAPIRequest({
      env,
      path: `/presets/${id}/providerData`,
      body: this.code,
      method: "PUT",
      fullResponse: true,
      timeout: 5000
    });
    write(chalk`response {yellow ${res.statusCode}} `);
  }

  async grabMetadata(env) {
    let remote = await Preset.getByName(env, this.name);
    this.isGeneric = false;

    if (!remote) {
      throw new AbortError(`No file found on remote ${env} with name ${this.name}`);
    }

    this.data = remote.data;
    this.remote = env;
  }

  async uploadCodeToEnv(env, includeMetadata, shouldTest = true) {
    if (!this.name) {
      log(chalk`Failed uploading {red ${this.path}}. No name found.`);
      return;
    }

    write(chalk`Uploading preset {green ${this.name}} to {green ${env}}: `);

    if (this.immutable) {
      log(chalk`{magenta IMMUTABLE}. Nothing to do.`);
      return;
    } //First query the api to see if this already exists.


    let remote = await Preset.getByName(env, this.name);

    if (remote) {
      //If it exists we can replace it
      write("replace, ");

      if (includeMetadata) {
        await lib.makeAPIRequest({
          env,
          path: `/presets/${remote.id}`,
          method: "PATCH",
          payload: {
            data: {
              attributes: this.data.attributes,
              type: "presets"
            }
          }
        });
        write("metadata OK, ");
      }

      await this.uploadPresetData(env, remote.id);
    } else {
      write("create, ");
      let metadata = {
        data: this.data
      };

      if (!this.relationships["providerType"]) {
        throw new AbortError("Cannot acclimatize shelled presets. (try creating it on the env first)");
      }

      await this.acclimatize(env);
      write("Posting to create preset... ");
      let res = await lib.makeAPIRequest({
        env,
        path: `/presets`,
        method: "POST",
        payload: metadata,
        timeout: 5000
      });
      let id = res.data.id;
      write(chalk`Created id {green ${id}}... Uploading Code... `);
      await this.uploadPresetData(env, id);
    }

    write("Done. ");

    if (this.test && shouldTest) {
      this.runTest(env);
    } else {
      log("No test");
    }
  }

  getLocalMetadata() {
    return JSON.parse(readFileSync(this.localmetadatapath, "utf-8"));
  }

  getLocalCode() {
    return readFileSync(this.path, "utf-8");
  }

}

defineAssoc(Preset, "_nameInner", "data.attributes.providerSettings.PresetName");
defineAssoc(Preset, "_nameOuter", "data.attributes.name");
defineAssoc(Preset, "id", "data.id");
defineAssoc(Preset, "attributes", "data.attributes");
defineAssoc(Preset, "relationships", "data.relationships");
defineAssoc(Preset, "remote", "meta.remote");
defineAssoc(Preset, "_code", "meta.code");
defineAssoc(Preset, "_path", "meta.path");
defineAssoc(Preset, "isGeneric", "meta.isGeneric");
defineAssoc(Preset, "ext", "meta.ext");
Preset.endpoint = "presets";

class Notification extends RallyBase {
  constructor({
    data,
    remote
  }) {
    super();
    this.data = data;
    this.meta = {};
    this.remote = remote;
  }

  static async getAllPreCollect(notifications) {
    return notifications.sort((a, b) => {
      return a.attributes.type.localeCompare(b.attributes.type) || a.attributes.name.localeCompare(b.attributes.name);
    });
  }

  chalkPrint(pad = false) {
    let id = String("N-" + this.id);
    if (pad) id = id.padStart(4);
    return chalk`{green ${id}}: {blue ${this.type}} - {green ${this.name}}`;
  }

}

defineAssoc(Notification, "id", "data.id");
defineAssoc(Notification, "name", "data.attributes.name");
defineAssoc(Notification, "address", "data.attributes.address");
defineAssoc(Notification, "type", "data.attributes.type");
defineAssoc(Notification, "remote", "meta.remote");
Notification.endpoint = "notificationPresets";

class Rule extends RallyBase {
  constructor({
    path: path$$1,
    data,
    remote
  } = {}) {
    super();

    if (path$$1) {
      path$$1 = path.resolve(path$$1);

      try {
        let f = fs.readFileSync(path$$1, "utf-8");
        data = JSON.parse(fs.readFileSync(path$$1, "utf-8"));
      } catch (e) {
        if (e.code === "ENOENT") {
          if (configObject.ignoreMissing) {
            this.missing = true;
            return undefined;
          } else {
            throw new AbortError("Could not load code of local file");
          }
        } else {
          throw new AbortError(`Unreadable JSON in ${path$$1}. ${e}`);
        }
      }
    }

    if (!data) {
      data = Rule.newShell();
    }

    this.data = data;
    this.meta = {};
    this.remote = remote;
    this.isGeneric = !this.remote;
  }

  static newShell() {
    return {
      "attributes": {
        "description": "-",
        "priority": "PriorityNorm",
        "starred": false
      },
      "relationships": {},
      "type": "workflowRules"
    };
  }

  async acclimatize(env) {
    this.remote = env;
    let preset = await this.resolveField(Preset, "preset", false, "specific");
    let pNext = await this.resolveField(Rule, "passNext", false, "specific");
    let eNext = await this.resolveField(Rule, "errorNext", false, "specific");
    let proType = await this.resolveField(Provider, "providerType", false, "specific");
    let dynamicNexts = await this.resolveField(Rule, "dynamicNexts", true, "specific");
    let enterNotif = await this.resolveField(Notification, "enterNotifications", true, "specific");
    let errorNotif = await this.resolveField(Notification, "errorNotifications", true, "specific");
    let passNotif = await this.resolveField(Notification, "passNotifications", true, "specific");
  }

  async saveA(env) {
    if (lib.isLocalEnv(env)) return;
    return await this.createIfNotExist(env);
  }

  async saveB(env) {
    if (!this.isGeneric) {
      await this.resolve();
    }

    this.cleanup();

    if (lib.isLocalEnv(env)) {
      log("Writing to local path: ");
      log(this.localpath);
      fs.writeFileSync(this.localpath, JSON.stringify(this.data, null, 4));
    } else {
      await this.acclimatize(env);
      await this.uploadRemote(env);
    }
  }

  get immutable() {
    return false;
  }

  async createIfNotExist(env) {
    write(chalk`First pass rule {green ${this.name}} to {green ${env}}: `);

    if (this.immutable) {
      log(chalk`{magenta IMMUTABLE}. Nothing to do.`);
      return;
    } //First query the api to see if this already exists.


    let remote = await Rule.getByName(env, this.name);
    this.idMap = this.idMap || {};

    if (remote) {
      this.idMap[env] = remote.id;
      log(chalk`exists ${remote.chalkPrint(false)}`);
      return;
    } //If it exists we can replace it


    write("create, ");
    let res = await lib.makeAPIRequest({
      env,
      path: `/workflowRules`,
      method: "POST",
      payload: {
        data: {
          attributes: {
            name: this.name
          },
          type: "workflowRules"
        }
      }
    });
    this.idMap = this.idMap || {};
    this.idMap[env] = res.data.id;
    write("id ");
    log(this.idMap[env]);
  }

  async patchStrip() {
    delete this.data.attributes.createdAt;
    delete this.data.attributes.starred;
    delete this.data.attributes.updatedAt; // TEMP FIX FOR BUG IN SDVI

    if (this.relationships.passMetadata && this.relationships.passMetadata[0]) {
      log("HAS PASS");
      log(this.name);
      log("HAS PASS");
    }

    delete this.relationships.passMetadata;

    if (this.relationships.errorMetadata && this.relationships.errorMetadata[0]) {
      log("HAS PASS");
      log(this.name);
      log("HAS PASS");
    }

    delete this.relationships.errorMetadata; // This is commented out because it was fixed.
    //for(let key in this.relationships){
    //let relationship = this.relationships[key];
    //if(!relationship.data || relationship.data instanceof Array && !relationship.data[0]){
    //delete this.relationships[key];
    //}
    //}
  }

  async uploadRemote(env) {
    write(chalk`Uploading rule {green ${this.name}} to {green ${env}}: `);

    if (this.immutable) {
      log(chalk`{magenta IMMUTABLE}. Nothing to do.`);
      return;
    }

    if (this.idMap[env]) {
      this.remote = env;
      await this.patchStrip();
      this.data.id = this.idMap[env]; //If it exists we can replace it

      write("replace, ");
      let res = await lib.makeAPIRequest({
        env,
        path: `/workflowRules/${this.idMap[env]}`,
        method: "PATCH",
        payload: {
          data: this.data
        },
        fullResponse: true
      });
      log(chalk`response {yellow ${res.statusCode}}`);

      if (res.statusCode !== 200) {
        log(res.body);
        log(JSON.stringify(this.data, null, 4));
      }
    } else {
      throw Error("Bad idmap!");
    }
  }

  get localpath() {
    return path.join(configObject.repodir, "silo-rules", this.name + ".json");
  }

  async resolve() {
    let preset = await this.resolveField(Preset, "preset", false); //log(preset);

    let pNext = await this.resolveField(Rule, "passNext", false);
    let eNext = await this.resolveField(Rule, "errorNext", false);
    let proType = await this.resolveField(Provider, "providerType", false); //log("Dynamic nexts")

    let dynamicNexts = await this.resolveField(Rule, "dynamicNexts", true); //log(dynamicNexts);

    let enterNotif = await this.resolveField(Notification, "enterNotifications", true);
    let errorNotif = await this.resolveField(Notification, "errorNotifications", true);
    let passNotif = await this.resolveField(Notification, "passNotifications", true); //TODO Unsupported

    delete this.relationships["enterMetadata"];
    delete this.relationships["errorMetadata"];
    this.isGeneric = true;
    return {
      preset,
      proType,
      pNext,
      eNext,
      dynamicNexts,
      errorNotif,
      enterNotif,
      passNotif
    };
  }

  chalkPrint(pad = true) {
    let id = String("R-" + (this.remote && this.remote + "-" + this.id || "LOCAL"));
    if (pad) id = id.padStart(10);

    try {
      return chalk`{green ${id}}: {blue ${this.name}}`;
    } catch (e) {
      return this.data;
    }
  }

}

defineAssoc(Rule, "name", "data.attributes.name");
defineAssoc(Rule, "description", "data.attributes.description");
defineAssoc(Rule, "id", "data.id");
defineAssoc(Rule, "relationships", "data.relationships");
defineAssoc(Rule, "isGeneric", "meta.isGeneric");
defineAssoc(Rule, "remote", "meta.remote");
defineAssoc(Rule, "idMap", "meta.idMap");
Rule.endpoint = "workflowRules";

class SupplyChain {
  constructor(startingRule, stopRule) {
    if (startingRule) {
      this.startingRule = startingRule;
      this.stopRule = stopRule;
      this.remote = startingRule.remote;
    }
  }

  async calculate() {
    log("Getting rules... ");
    this.allRules = await Rule.getAll(this.remote);
    log(this.allRules.length);
    log("Getting presets... ");
    this.allPresets = await Preset.getAll(this.remote);
    log(this.allPresets.length);
    log("Getting providers... ");
    this.allProviders = await Provider.getAll(this.remote);
    log(this.allProviders.length);
    log("Getting notifications... ");
    this.allNotifications = await Notification.getAll(this.remote);
    log(this.allNotifications.length);
    log("Downloading code... ");
    let i = 0;

    for (let preset of this.allPresets) {
      write(`\r${" ".repeat(process.env.COLUMNS || 30)}\r${i++} / ${this.allPresets.arr.length} ${preset.name}`);
      await preset.downloadCode();
    }

    log("Done!"); //Now we have everything we need to find a whole supply chain

    write("Calculating Supply chain... ");
    log(this.startingRule.chalkPrint());
    let allRuleNames = this.allRules.arr.map(x => x.name).filter(x => x.length >= 4);
    let allPresetNames = this.allPresets.arr.map(x => x.name).filter(x => x.length >= 4);
    let allNotifNames = this.allNotifications.arr.map(x => x.name).filter(x => x.length >= 4);
    let requiredNotifications = new Set();
    let ruleQueue = [this.startingRule];
    let presetQueue = [];

    for (let currentRule of ruleQueue) {
      if (currentRule === this.stopRule) continue;
      let {
        eNext,
        pNext,
        preset,
        passNotif,
        errorNotif,
        enterNotif
      } = await currentRule.resolve();
      passNotif.forEach(n => requiredNotifications.add(n));
      enterNotif.forEach(n => requiredNotifications.add(n));
      errorNotif.forEach(n => requiredNotifications.add(n));
      if (eNext && !ruleQueue.includes(eNext)) ruleQueue.push(eNext);
      if (pNext && !ruleQueue.includes(eNext)) ruleQueue.push(pNext);
      let neededPresets = preset.findStringsInCode(allPresetNames);
      neededPresets = neededPresets.map(x => this.allPresets.findByName(x));
      let neededRules = preset.findStringsInCode(allRuleNames);
      neededRules = neededRules.map(x => this.allRules.findByName(x));
      preset.findStringsInCode(allNotifNames).map(str => this.allNotifications.findByName(str)).forEach(notif => requiredNotifications.add(notif));
      neededPresets.push(preset);

      for (let p of neededPresets) if (!presetQueue.includes(p)) presetQueue.push(p);

      for (let p of neededRules) if (!ruleQueue.includes(p)) ruleQueue.push(p);

      if (configObject.verbose) {
        write(currentRule.chalkPrint(false));
        log(":");
        write("  ");
        write(preset.chalkPrint(false));
        log(":");
        write("  Pass Next: ");
        if (pNext) write(pNext.chalkPrint(false));else write("None");
        log("");
        write("  Err  Next: ");
        if (eNext) write(eNext.chalkPrint(false));else write("None");
        log("");
        log("  Rules:");

        for (let p of neededRules) log("    " + p.chalkPrint(true));

        log("  Presets:");

        for (let p of neededPresets) log("    " + p.chalkPrint(true));

        log("\n");
      }
    }

    log("Done!");
    this.rules = new Collection(ruleQueue);
    this.presets = new Collection(presetQueue);
    requiredNotifications.delete(undefined);
    this.notifications = new Collection([...requiredNotifications]);
  }

  async log() {
    log("Required notifications: ");
    this.notifications.log();
    write("Required rules: ");
    log(this.rules.arr.length);
    this.rules.log();
    write("Required presets: ");
    log(this.presets.arr.length);
    this.presets.log();
  }

  async syncTo(env) {
    for (let preset of this.presets) {
      try {
        await preset.save(env);
      } catch (e) {
        log(e);
      }
    }

    if (this.rules.arr[0]) {
      log("Starting create phase for rules");

      for (let rule of this.rules) {
        try {
          await rule.saveA(env);
        } catch (e) {
          log(e);
        }
      }

      log("OK");
      log("Starting link phase for rules");
      Rule.removeCache(env);

      for (let rule of this.rules) {
        try {
          await rule.saveB(env);
        } catch (e) {
          log(e);
        }
      }
    }
  }

}

require("source-map-support").install();
const rallyFunctions = {
  async bestPagintation() {
    global.silentAPI = true;

    for (let i = 10; i <= 30; i += 5) {
      console.time("test with " + i);
      let dl = await lib.indexPathFast("DEV", `/workflowRules?page=1p${i}`);
      console.timeEnd("test with " + i);
    }
  },

  async uploadPresets(env, presets, createFunc = () => false) {
    for (let preset of presets) {
      await preset.uploadCodeToEnv(env, createFunc);
    }
  },

  //Dummy test access
  async testAccess(env) {
    if (lib.isLocalEnv(env)) {
      //TODO
      return true;
    }

    let result = await lib.makeAPIRequest({
      env,
      path: "/providers?page=1p1",
      fullResponse: true,
      timeout: 1000
    });
    return result.statusCode;
  }

};

var allIndexBundle = /*#__PURE__*/Object.freeze({
  rallyFunctions: rallyFunctions,
  SupplyChain: SupplyChain,
  Preset: Preset,
  Rule: Rule,
  Provider: Provider,
  Notification: Notification,
  Asset: Asset,
  get configFile () { return configFile; },
  loadConfig: loadConfig,
  setConfig: setConfig,
  get configObject () { return configObject; },
  lib: lib,
  AbortError: AbortError,
  APIError: APIError,
  UnconfiguredEnvError: UnconfiguredEnvError,
  ProtectedEnvError: ProtectedEnvError,
  Collection: Collection,
  RallyBase: RallyBase
});

var version = "1.10.2";

let testCases = [["one segment good", {
  "userMetaData": {
    "segments": {
      "segments": [{
        "endTime": "00:02:37:20",
        "startTime": "00:01:38:10",
        "woo": [{
          "inPoint": "00:01:39:00",
          "outPoint": "00:02:19:00"
        }]
      }]
    }
  }
}], ["out of order segment 1-2", {
  "userMetaData": {
    "segments": {
      "segments": [{
        "startTime": "00:59:40;00",
        "endTime": "00:59:59;24",
        "woo": []
      }, {
        "startTime": "01:35:00;00",
        "endTime": "01:40:37;20",
        "woo": []
      }, {
        "startTime": "01:00:00;00",
        "endTime": "01:30:37;20",
        "woo": []
      }, {
        "startTime": "01:50:00;00",
        "endTime": "01:59:00;00",
        "woo": []
      }]
    }
  }
}], ["bad 0 hour timecodes", {
  "userMetaData": {
    "segments": {
      "segments": [{
        "startTime": "00:01:00;00",
        "endTime": "00:02:37;20",
        "woo": []
      }, {
        "startTime": "00:03:00;00",
        "endTime": "00:04:37;20",
        "woo": []
      }, {
        "startTime": "00:05:00;00",
        "endTime": "00:06:00;00",
        "woo": []
      }]
    }
  }
}], ["bad ovelapping segments", {
  "userMetaData": {
    "segments": {
      "segments": [{
        "startTime": "00:59:40;00",
        "endTime": "00:59:59;24",
        "woo": []
      }, {
        "startTime": "01:00:00;00",
        "endTime": "01:30:37;20",
        "woo": []
      }, {
        "startTime": "01:20:00;00",
        "endTime": "01:40:37;20",
        "woo": []
      }, {
        "startTime": "01:50:00;00",
        "endTime": "01:59:00;00",
        "woo": []
      }]
    }
  }
}], ["good segments", {
  "userMetaData": {
    "segments": {
      "segments": [{
        "startTime": "00:59:40;00",
        "endTime": "00:59:59;24",
        "woo": []
      }, {
        "startTime": "01:00:00;00",
        "endTime": "01:30:37;20",
        "woo": []
      }, {
        "startTime": "01:35:00;00",
        "endTime": "01:40:37;20",
        "woo": []
      }, {
        "startTime": "01:50:00;00",
        "endTime": "01:59:00;00",
        "woo": []
      }]
    }
  }
}], ["good segments w/ good woos", {
  "userMetaData": {
    "segments": {
      "segments": [{
        "startTime": "00:59:40;00",
        "endTime": "00:59:59;24",
        "woo": []
      }, {
        "startTime": "01:00:00;00",
        "endTime": "01:30:37;20",
        "woo": [{
          "inPoint": "01:20:39;00",
          "outPoint": "01:21:49;00"
        }]
      }, {
        "startTime": "01:35:00;00",
        "endTime": "01:40:37;20",
        "woo": [{
          "inPoint": "01:36:39;00",
          "outPoint": "01:37:49;00"
        }]
      }, {
        "startTime": "01:50:00;00",
        "endTime": "01:59:00;00",
        "woo": []
      }]
    }
  }
}], ["good segments w/ good woos (multiple woos]", {
  "userMetaData": {
    "segments": {
      "segments": [{
        "startTime": "00:59:40;00",
        "endTime": "00:59:59;24",
        "woo": []
      }, {
        "startTime": "01:00:00;00",
        "endTime": "01:30:37;20",
        "woo": [{
          "inPoint": "01:20:39;00",
          "outPoint": "01:21:49;00"
        }, {
          "inPoint": "01:22:39;00",
          "outPoint": "01:23:49;00"
        }]
      }, {
        "startTime": "01:35:00;00",
        "endTime": "01:40:37;20",
        "woo": [{
          "inPoint": "01:36:39;00",
          "outPoint": "01:37:49;00"
        }, {
          "inPoint": "01:38:39;00",
          "outPoint": "01:40:37;20"
        }]
      }, {
        "startTime": "01:50:00;00",
        "endTime": "01:59:00;00",
        "woo": []
      }]
    }
  }
}], ["good segments w/ bad woos (fully outside segment]", {
  "userMetaData": {
    "segments": {
      "segments": [{
        "startTime": "00:59:40;00",
        "endTime": "00:59:59;24",
        "woo": []
      }, {
        "startTime": "01:00:00;00",
        "endTime": "01:30:37;20",
        "woo": [{
          "inPoint": "01:33:39;00",
          "outPoint": "01:35:49;00"
        }]
      }, {
        "startTime": "01:35:00;00",
        "endTime": "01:40:37;20",
        "woo": [{
          "inPoint": "01:36:39;00",
          "outPoint": "01:37:49;00"
        }, {
          "inPoint": "01:38:39;00",
          "outPoint": "01:40:37;20"
        }]
      }, {
        "startTime": "01:50:00;00",
        "endTime": "01:59:00;00",
        "woo": []
      }]
    }
  }
}], ["good segments w/ bad woos (go past segment out time]", {
  "userMetaData": {
    "segments": {
      "segments": [{
        "startTime": "00:59:40;00",
        "endTime": "00:59:59;24",
        "woo": []
      }, {
        "startTime": "01:00:00;00",
        "endTime": "01:30:37;20",
        "woo": [{
          "inPoint": "01:20:39;00",
          "outPoint": "01:31:49;00"
        }]
      }, {
        "startTime": "01:35:00;00",
        "endTime": "01:40:37;20",
        "woo": [{
          "inPoint": "01:36:39;00",
          "outPoint": "01:37:49;00"
        }, {
          "inPoint": "01:38:39;00",
          "outPoint": "01:40:37;20"
        }]
      }, {
        "startTime": "01:50:00;00",
        "endTime": "01:59:00;00",
        "woo": []
      }]
    }
  }
}]];

function recursivePatch(target, patch) {
  if (typeof patch !== "object" || Array.isArray(patch)) return patch;

  for (let [key, value] of Object.entries(patch)) {
    if (typeof value === "object") {
      target[key] = recursivePatch(target[key], value);
    } else {
      target[key] = value;
    }
  }

  return target;
}

async function testFunction(args) {
  function uuid(args) {
    const digits = 16;
    return String(Math.floor(Math.random() * Math.pow(10, digits))).padStart(digits, "0");
  }

  let json = JSON.parse(require("fs").readFileSync("recontribution_init.json"));

  for (let [name, patch] of testCases) {
    let base = JSON.parse(JSON.stringify(json));
    base["Metadata"] = recursivePatch(base["Metadata"], patch);
    let asset = await Asset.createNew("USKN_R_" + uuid(), "UAT");
    log(name);
    log(asset.data.links.self.replace("/api/v2/assets/", "/content/"));
    await asset.addFile("SdviMovieFileMaster", "s3://discovery.com.uat.onramp.archive.us-east-1/DKNOXR_Master2.mxf");
    await asset.startWorkflow("External Logging", {
      version: 1,
      message: `Test: ${name}`
    });
    await asset.startWorkflow("AS302 Test DKNOX Recontribution", base);
  }
}

var baseCode = {
  SdviContentMover: `{
    "tasks": [
        {
            "operation": "move",
            "source": {
                "labels": [ "MyLabel" ],
                "tags": [ "segmented" ]
                "storageSet": [ "*", "-OtherStorageBucket" ],

            },
            "destination": {
                "storage": "Archive",
                "newLabel": "myNewLabel",
                "overwrite": "always"
            }
        }
    ]
}`,
  SdviEvaluate: `'''
name: {name}
'''

# code here`
};

const inquirer = importLazy("inquirer");
const readdir = importLazy("recursive-readdir");
let hasAutoCompletePrompt = false;

function addAutoCompletePrompt() {
  if (hasAutoCompletePrompt) return;
  hasAutoCompletePrompt = true;
  inquirer.registerPrompt("autocomplete", require("inquirer-autocomplete-prompt"));
}

async function $api(propArray) {
  const defaults = {
    DEV: "https://discovery-dev.sdvi.com/api/v2",
    UAT: "https://discovery-uat.sdvi.com/api/v2",
    QA: "https://discovery-qa.sdvi.com/api/v2",
    PROD: "https://discovery.sdvi.com/api/v2"
  };
  let q;

  if (propArray && propArray[1]) {
    q = {
      envs: [propArray[1]]
    };
  } else {
    //Create a checkbox prompt to choose enviornments
    q = await inquirer.prompt([{
      type: "checkbox",
      name: "envs",
      message: `What enviornments would you like to configure?`,
      choices: Object.keys(defaults).map(name => ({
        name,
        checked: true
      }))
    }]);
  } //Each env should ask 2 for two things: The url and the key.


  let questions = q.envs.map(env => {
    let defaultKey = process.env[`rally_api_key_${env}`];

    if (configObject && configObject.api && configObject.api[env]) {
      defaultKey = configObject.api[env].key;
    }

    return [{
      type: "input",
      name: `api.${env}.url`,
      message: `What is the url endpoint for ${env}`,
      default: defaults[env]
    }, {
      type: "input",
      name: `api.${env}.key`,
      message: `What is your api key for ${env}`,
      default: defaultKey
    }];
  }); //flatten and ask

  questions = [].concat(...questions);
  q = await inquirer.prompt(questions);

  if (propArray) {
    q.api = { ...configObject.api,
      ...q.api
    };
  }

  return q;
}
async function $chalk(propArray) {
  return {
    chalk: await askQuestion("Would you like chalk enabled (Adds coloring)?")
  };
}
async function $restrictUAT(propArray) {
  return {
    restrictUAT: await askQuestion("Would you like to protect UAT?")
  };
}
async function $repodir(propArray) {
  return await inquirer.prompt([{
    type: "input",
    name: `repodir`,
    message: `Where is your rally repository?`,
    default: process.env["rally_repo_path"]
  }]);
}
async function $defaultEnv(propArray) {
  return await inquirer.prompt([{
    type: "input",
    name: `defaultEnv`,
    message: `Default enviornment?`,
    default: "DEV"
  }]);
} //Internal usage/testing

async function selectProvider(providers, autoDefault = false) {
  addAutoCompletePrompt();
  let defaultProvider = providers.findByName("SdviEvaluate");

  if (autoDefault) {
    return defaultProvider;
  } else {
    let choices = providers.arr.map(x => ({
      name: x.chalkPrint(true),
      value: x
    }));
    let q = await inquirer.prompt([{
      type: "autocomplete",
      name: "provider",
      default: defaultProvider,
      source: async (sofar, input) => {
        return choices.filter(x => input ? x.value.name.toLowerCase().includes(input.toLowerCase()) : true);
      }
    }]);
    return q.provider;
  }
}
async function selectLocal(path$$1, typeName, Class) {
  addAutoCompletePrompt();
  let basePath = path.join(configObject.repodir, path$$1);
  let f = await readdir(basePath);
  let objs = f.map(name => new Class({
    path: name
  }));
  let objsMap = objs.map(x => ({
    name: x.chalkPrint(true),
    value: x
  }));
  let none = {
    name: chalk`      {red None}: {red None}`,
    value: null
  };
  objsMap.unshift(none);
  let q = await inquirer.prompt([{
    type: "autocomplete",
    name: "obj",
    message: `What ${typeName} do you want?`,
    source: async (sofar, input) => {
      return objsMap.filter(x => input ? x.name.toLowerCase().includes(input.toLowerCase()) : true);
    }
  }]);
  return q.obj;
}
async function selectPreset(purpose = "preset") {
  return selectLocal("silo-presets", "preset", Preset);
}
async function selectRule(purpose = "rule") {
  return selectLocal("silo-rules", purpose, Rule);
}
async function askInput(name, question, def) {
  return (await inquirer.prompt([{
    type: "input",
    name: "ok",
    message: question,
    default: def
  }])).ok;
}
async function askQuestion(question) {
  return (await inquirer.prompt([{
    type: "confirm",
    name: "ok",
    message: question
  }])).ok;
}

var configHelpers = /*#__PURE__*/Object.freeze({
  $api: $api,
  $chalk: $chalk,
  $restrictUAT: $restrictUAT,
  $repodir: $repodir,
  $defaultEnv: $defaultEnv,
  selectProvider: selectProvider,
  selectLocal: selectLocal,
  selectPreset: selectPreset,
  selectRule: selectRule,
  askInput: askInput,
  askQuestion: askQuestion
});

var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _dec12, _dec13, _dec14, _dec15, _dec16, _dec17, _dec18, _dec19, _dec20, _dec21, _dec22, _dec23, _dec24, _dec25, _dec26, _dec27, _dec28, _dec29, _dec30, _dec31, _dec32, _dec33, _dec34, _dec35, _dec36, _dec37, _dec38, _dec39, _dec40, _obj;

require("source-map-support").install();
let argv = argparse(process.argv.slice(2), {
  string: ["file", "env"],
  //boolean: ["no-protect"],
  default: {
    protect: true
  },
  alias: {
    f: "file",
    e: "env"
  }
}); //help menu helper

function printHelp(help, short) {
  let helpText$$1 = chalk`
{white ${help.name}}: ${help.text}
    Usage: ${help.usage || "<unknown>"}
`; //Trim newlines

  helpText$$1 = helpText$$1.substring(1, helpText$$1.length - 1);

  if (!short) {
    for (let param$$1 of help.params || []) {
      helpText$$1 += chalk`\n    {blue ${param$$1.param}}: ${param$$1.desc}`;
    }

    for (let arg$$1 of help.args || []) {
      helpText$$1 += chalk`\n    {blue ${arg$$1.short}}, {blue ${arg$$1.long}}: ${arg$$1.desc}`;
    }
  }

  return helpText$$1;
}

async function getFilesFromArgs(args) {
  let lastArg = args._.shift();

  if (args.file) {
    let files = args.file;
    if (typeof files === "string") files = [files];
    return files;
  }

  if (lastArg == "-") {
    log("Reading from stdin");

    let getStdin = require("get-stdin");

    let stdin = await getStdin();
    let files = stdin.split("\n");
    if (files[files.length - 1] === "") files.pop();
    return files;
  } else {
    args._.push(lastArg);
  }
}

let presetsub = {
  async before(args) {
    this.env = args.env;
    if (!this.env) throw new AbortError("No env supplied");
    this.files = await getFilesFromArgs(args);
  },

  async $grab(args) {
    if (!this.files) {
      throw new AbortError("No files provided to grab (use --file argument)");
    }

    log(chalk`Grabbing {green ${this.files.length}} preset(s) metadata from {green ${this.env}}.`);
    let presets = this.files.map(path$$1 => new Preset({
      path: path$$1,
      remote: false
    }));

    for (let preset of presets) {
      //TODO small refactor
      await preset.grabMetadata(this.env);
      await preset.saveLocalMetadata();

      if (args.full) {
        let remo = await Preset.getByName(this.env, preset.name);
        await remo.resolve();
        await remo.downloadCode();
        await remo.saveLocalFile();
      }
    }
  },

  async $create(args) {
    let provider, name$$1, ext;

    if (args.provider) {
      provider = {
        name: args.provider
      };
      ext = args.ext;
    } else {
      provider = await selectProvider((await Provider.getAll(this.env)));
      ext = (await provider.getEditorConfig()).fileExt;
    }

    if (args.name) {
      name$$1 = args.name;
    } else {
      name$$1 = await askInput("Preset Name", "What is the preset name?");
    }

    let preset = new Preset();
    preset.providerType = {
      name: provider.name
    };
    preset.isGeneric = true;
    preset.name = name$$1;
    preset.ext = ext;

    if (baseCode[provider.name]) {
      preset._code = baseCode[provider.name].replace("{name}", name$$1);
    } else {
      preset._code = " ";
    }

    preset.saveLocalMetadata();
    preset.saveLocalFile();
  },

  async $list(args) {
    log("Loading...");
    let presets = await Preset.getAll(this.env);

    if (args.resolve) {
      Provider.getAll(this.env);

      for (let preset of presets) {
        let resolve = await preset.resolve(this.env);

        if (args.attach) {
          let {
            proType
          } = resolve;
          proType.editorConfig.helpText = "";
          preset.meta = { ...preset.meta,
            proType
          };
        }
      }
    }

    if (configObject.rawOutput) return presets;
    log(chalk`{yellow ${presets.length}} presets on {green ${this.env}}.`);
    presets.arr.sort((a, b) => {
      return Number(a.attributes.updatedAt) - Number(b.attributes.updatedAt);
    });

    for (let preset of presets) {
      log(preset.chalkPrint());
    }
  },

  async $upload(args) {
    if (!this.files) {
      throw new AbortError("No files provided to upload (use --file argument)");
    }

    log(chalk`Uploading {green ${this.files.length}} preset(s) to {green ${this.env}}.`);
    let presets = this.files.map(path$$1 => new Preset({
      path: path$$1,
      remote: false
    }));
    await rallyFunctions.uploadPresets(this.env, presets);
  },

  async $diff(args) {
    let file = this.files[0];

    if (!this.files) {
      throw new AbortError("No files provided to diff (use --file argument)");
    }

    let preset = new Preset({
      path: file,
      remote: false
    });

    if (!preset.name) {
      throw new AbortError(chalk`No preset header found. Cannot get name.`);
    }

    let preset2 = await Preset.getByName(this.env, preset.name);

    if (!preset2) {
      throw new AbortError(chalk`No preset found with name {red ${preset.name}} on {blue ${this.env}}`);
    }

    await preset2.downloadCode();

    let tempfile = require("tempy").file;

    let temp = tempfile({
      extension: preset.ext
    });
    fs.writeFileSync(temp, preset2.code);
    let ptr = `${file},${temp}`; //raw output returns "file1" "file2"

    if (configObject.rawOutput) return ptr; //standard diff

    argv.command = argv.command || "diff";
    await spawn(argv.command, [file, temp], {
      stdio: "inherit"
    });
  },

  async unknown(arg$$1, args) {
    log(chalk`Unknown action {red ${arg$$1}} try '{white rally help preset}'`);
  }

};
let rulesub = {
  async before(args) {
    this.env = args.env;
    if (!this.env) throw new AbortError("No env supplied");
  },

  async $list(args) {
    log("Loading...");
    let rules = await Rule.getAll(this.env);
    if (configObject.rawOutput) return rules;
    log(chalk`{yellow ${rules.length}} rules on {green ${this.env}}.`);
    rules.arr.sort((a, b) => {
      return Number(a.data.attributes.updatedAt) - Number(b.data.attributes.updatedAt);
    });

    for (let rule of rules) log(rule.chalkPrint());
  },

  async $create(args) {
    let preset = await selectPreset();
    let passNext = await selectRule("'On Exit OK'");
    let errorNext = await selectRule("'On Exit Error'");
    let name$$1 = await askInput("Rule Name", "What is the rule name?");
    let desc = await askInput("Description", "Enter a description.");
    let dynamicNexts = [];
    let next;

    while (next = await selectRule("dynamic next")) {
      let name$$1 = await askInput("Key", "Key name for dynamic next");
      dynamicNexts.push({
        meta: {
          transition: name$$1
        },
        type: "workflowRules",
        name: next.name
      });
    }

    let rule = new Rule();
    rule.name = name$$1;
    rule.description = desc;
    rule.relationships.preset = {
      data: {
        name: preset.name,
        type: "presets"
      }
    };
    if (errorNext) rule.relationships.errorNext = {
      data: {
        name: errorNext.name,
        type: "workflowRules"
      }
    };
    if (passNext) rule.relationships.passNext = {
      data: {
        name: passNext.name,
        type: "workflowRules"
      }
    };

    if (dynamicNexts[0]) {
      rule.relationships.dynamicNexts = {
        data: dynamicNexts
      };
    }

    rule.saveB();
  },

  async unknown(arg$$1, args) {
    log(chalk`Unknown action {red ${arg$$1}} try '{white rally help rule}'`);
  }

};
let jupytersub = {
  async before(args) {
    this.input = args._.shift() || "main.ipynb";
    this.output = args._.shift() || "main.py";
  },

  async $build(args) {
    let cmd = `jupyter nbconvert --to python ${this.input} --TagRemovePreprocessor.remove_cell_tags={\"remove_cell\"} --output ${this.output} --TemplateExporter.exclude_markdown=True --TemplateExporter.exclude_input_prompt=True --TemplateExporter.exclude_output_prompt=True`.split(" ");
    log(chalk`Compiling GCR file {green ${this.input}} into {green ${this.output}} using jupyter...`);

    try {
      let {
        timestr
      } = await spawn(cmd[0], cmd.slice(1));
      log(chalk`Complete in ~{green.bold ${timestr}}.`);
    } catch (e) {
      if (e.code !== "ENOENT") throw e;
      log(chalk`Cannot run the build command. Make sure that you have jupyter notebook installed.\n{green pip install jupyter}`);
      return;
    }
  }

};

async function categorizeString(str) {
  str = str.trim();
  let match;

  if (match = /^(\w)-(\w{1,10})-(\d{1,10}):/.exec(str)) {
    if (match[1] === "P") {
      return await Preset.getById(match[2], match[3]);
    } else if (match[1] === "R") {
      return await Rule.getById(match[2], match[3]);
    } else {
      return null;
    }
  } else if (match = /silo\-(\w+)\//.exec(str)) {
    try {
      switch (match[1]) {
        case "presets":
          return new Preset({
            path: str
          });

        case "rules":
          return new Rule({
            path: str
          });

        case "metadata":
          return await Preset.fromMetadata(str);
      }
    } catch (e) {
      log(e);
    }
  } else {
    return null;
  }
}

let supplysub = {
  async before(args) {
    this.env = args.env;
    if (!this.env) throw new AbortError("No env supplied");
    this.files = await getFilesFromArgs(args);
  },

  //Calculate a supply chain based on a starting rule at the top of the stack
  async $calc(args) {
    let name$$1 = args._.shift();

    let stopName = args._.shift();

    if (!name$$1) {
      throw new AbortError("No starting rule supplied");
    }

    let rules = await Rule.getAll(this.env);
    let start = rules.findByNameContains(name$$1);
    let stop;
    if (stopName) stop = rules.findByNameContains(stopName);

    if (!start) {
      throw new AbortError(chalk`No starting rule found by name {blue ${name$$1}}`);
    }

    log(chalk`Analzying supply chain: ${start.chalkPrint(false)} - ${stop ? stop.chalkPrint(false) : "(open)"}`);
    this.chain = new SupplyChain(start, stop);
    await this.chain.calculate();
    await this.postAction(args);
  },

  async postAction(args) {
    //Now that we ahve a supply chain object, do something with it
    if (args["to"]) {
      this.chain.log();

      if (this.chain.presets.arr[0]) {
        log("Loading code");
        await Promise.all(this.chain.presets.arr.map(obj => obj.downloadCode()));
        log("Done");
      }

      await this.chain.syncTo(args["to"]);
    } else if (args["diff"]) {
      //Very basic diff
      let env = args["diff"];
      await Promise.all(this.chain.presets.arr.map(obj => obj.downloadCode()));
      await Promise.all(this.chain.presets.arr.map(obj => obj.resolve()));
      let otherPresets = await Promise.all(this.chain.presets.arr.map(obj => Preset.getByName(env, obj.name)));
      otherPresets = new Collection(otherPresets.filter(x => x));
      await Promise.all(otherPresets.arr.map(obj => obj.downloadCode()));
      await Promise.all(otherPresets.arr.map(obj => obj.resolve()));

      const printPresets = (preset, otherPreset) => {
        log(preset.chalkPrint(true));

        if (otherPreset.name) {
          log(otherPreset.chalkPrint(true));
        } else {
          log(chalk`{red (None)}`);
        }
      };

      for (let preset of this.chain.presets) {
        let otherPreset = otherPresets.arr.find(x => x.name === preset.name) || {};

        if (preset.code === otherPreset.code) {
          if (!args["ignore-same"]) {
            printPresets(preset, otherPreset);
            log("Code Same");
          }
        } else {
          printPresets(preset, otherPreset);

          if (args["ignore-same"]) {
            log("-------");
          } else {
            log("Code Different");
          }
        }
      }
    } else {
      await this.chain.log();
    }
  },

  async $make(args) {
    let set = new Set();

    for (let file of this.files) {
      set.add((await categorizeString(file)));
    }

    let files = [...set];
    files = files.filter(f => f && !f.missing);
    this.chain = new SupplyChain();
    this.chain.rules = new Collection(files.filter(f => f instanceof Rule));
    this.chain.presets = new Collection(files.filter(f => f instanceof Preset));
    this.chain.notifications = new Collection([]);
    await this.postAction(args);
  },

  async unknown(arg$$1, args) {
    log(chalk`Unknown action {red ${arg$$1}} try '{white rally help supply}'`);
  }

};

function subCommand(object) {
  object = {
    before() {},

    after() {},

    unknown() {},

    ...object
  };
  return async function (args) {
    //Grab the next arg on the stack, find a function tied to it, and run
    let arg$$1 = args._.shift();

    let key = "$" + arg$$1;
    let ret;

    if (object[key]) {
      await object.before(args);
      ret = await object[key](args);
      await object.after(args);
    } else {
      if (arg$$1 === undefined) arg$$1 = "(None)";
      object.unknown(arg$$1, args);
    }

    return ret;
  };
}

let cli = (_dec = helpText(`Display the help menu`), _dec2 = usage(`rally help [subhelp]`), _dec3 = param("subhelp", "The name of the command to see help for"), _dec4 = helpText("Rally tools jupyter interface. Requires jupyter to be installed."), _dec5 = usage("rally jupyter build [in] [out]"), _dec6 = param("in/out", "input and output file for jupyter. By default main.ipyrb and main.py"), _dec7 = helpText(`Preset related actions`), _dec8 = usage(`rally preset [action] --env <enviornment> --file [file1] --file [file2] ...`), _dec9 = param("action", "The action to perform. Can be upload, diff, list"), _dec10 = arg("-e", "--env", "The enviornment you wish to perform the action on"), _dec11 = arg("-f", "--file", "A file to act on"), _dec12 = arg("~", "--command", "If the action is diff, this is the command to run instead of diff"), _dec13 = helpText(`Rule related actions`), _dec14 = usage(`rally rule [action] --env [enviornment]`), _dec15 = param("action", "The action to perform. Only list is supported right now"), _dec16 = arg("-e", "--env", "The enviornment you wish to perform the action on"), _dec17 = helpText(`supply chain related actions`), _dec18 = usage(`rally supply [action] [identifier] --env [enviornment]`), _dec19 = param("action", "The action to perform. Can be calc."), _dec20 = param("identifier", "If the action is calc, then this identifier should be the first rule in the chain."), _dec21 = arg("-e", "--env", "The enviornment you wish to perform the action on"), _dec22 = helpText(`List all available providers, or find one by name/id`), _dec23 = usage(`rally providers [identifier] --env [env] --raw`), _dec24 = param("identifier", "Either the name or id of the provider"), _dec25 = arg("-e", "--env", "The enviornment you wish to perform the action on"), _dec26 = arg("~", "--raw", "Raw output of command. If [identifier] is given, then print editorConfig too"), _dec27 = helpText(`Change config for rally tools`), _dec28 = usage("rally config [key] --set [value] --raw"), _dec29 = param("key", chalk`Key you want to edit. For example, {green chalk} or {green api.DEV}`), _dec30 = arg("~", "--set", "If this value is given, no interactive prompt will launch and the config option will change."), _dec31 = arg("~", "--raw", "Raw output of json config"), _dec32 = helpText(`create/modify asset`), _dec33 = usage("rally asset [action] [action...]"), _dec34 = param("action", chalk`Options are create, delete, launch, addfile. You can supply multiple actions to chain them`), _dec35 = arg(`-i`, `--id`, chalk`MOVIE_ID of asset to select`), _dec36 = arg(`-n`, `--name`, chalk`MOVIE_NAME of asset. with {white create}, '{white #}' will be replaced with a uuid. Default is '{white TEST_#}'`), _dec37 = arg(`-j`, `--job-name`, chalk`Job name to start (used with launch)`), _dec38 = arg(`~`, `--init-data`, chalk`Init data to use when launching job. can be string, or {white @path/to/file} for a file`), _dec39 = arg(`~`, `--file-label`, chalk`File label (used with addfile)`), _dec40 = arg(`~`, `--file-uri`, chalk`File s3 uri. Can use multiple uri's for the same label (used with addfile)`), (_obj = {
  async help(args) {
    let arg$$1 = args._.shift();

    if (arg$$1) {
      let help = helpEntries[arg$$1];

      if (!help) {
        log(chalk`No help found for '{red ${arg$$1}}'`);
      } else {
        log(printHelp(helpEntries[arg$$1]));
      }
    } else {
      for (let helpArg in helpEntries) {
        log(printHelp(helpEntries[helpArg], true));
      }
    }
  },

  async jupyter(args) {
    return subCommand(jupytersub)(args);
  },

  //@helpText(`Print input args, for debugging`)
  async printArgs(args) {
    log(args);
  },

  async preset(args) {
    return subCommand(presetsub)(args);
  },

  async rule(args) {
    return subCommand(rulesub)(args);
  },

  async supply(args) {
    return subCommand(supplysub)(args);
  },

  async providers(args) {
    let env = args.env;
    if (!env) return errorLog("No env supplied.");

    let ident = args._.shift();

    let providers = await Provider.getAll(env);

    if (ident) {
      let pro = providers.arr.find(x => x.id == ident || x.name.includes(ident));

      if (!pro) {
        log(chalk`Couldn't find provider by {green ${ident}}`);
      } else {
        log(pro.chalkPrint(false));
        let econfig = await pro.getEditorConfig();

        if (args.raw) {
          return pro;
        } else {
          if (econfig.helpText.length > 100) {
            econfig.helpText = "<too long to display>";
          }

          if (econfig.completions.length > 5) {
            econfig.completions = "<too long to display>";
          }

          log(econfig);
        }
      }
    } else {
      if (args.raw) return providers;

      for (let pro of providers) log(pro.chalkPrint());
    }
  },

  async config(args) {
    let prop = args._.shift();

    let propArray = prop && prop.split("."); //if(!await configHelpers.askQuestion(`Would you like to create a new config file in ${configFile}`)) return;

    let newConfigObject;

    if (!prop) {
      if (configObject.rawOutput) return configObject;
      log("Creating new config");
      newConfigObject = { ...configObject
      };

      for (let helperName in configHelpers) {
        if (helperName.startsWith("$")) {
          newConfigObject = { ...newConfigObject,
            ...(await configHelpers[helperName](false))
          };
        }
      }
    } else {
      log(chalk`Editing option {green ${prop}}`);

      if (args.set) {
        newConfigObject = { ...configObject,
          [prop]: args.set
        };
      } else {
        let ident = "$" + propArray[0];

        if (configHelpers[ident]) {
          newConfigObject = { ...configObject,
            ...(await configHelpers[ident](propArray))
          };
        } else {
          log(chalk`No helper for {red ${ident}}`);
          return;
        }
      }
    }

    newConfigObject.hasConfig = true; //Create readable json and make sure the user is ok with it

    let newConfig = JSON.stringify(newConfigObject, null, 4);
    log(newConfig); //-y or --set will make this not prompt

    if (!args.y && !args.set && !(await askQuestion("Write this config to disk?"))) return;
    fs.writeFileSync(configFile, newConfig, {
      mode: 0o600
    });
    log(chalk`Created file {green ${configFile}}.`);
  },

  async asset(args) {
    function uuid(args) {
      const digits = 16;
      return String(Math.floor(Math.random() * Math.pow(10, digits))).padStart(digits, "0");
    }

    let name$$1 = args.name || `TEST_#`;
    let env = args.env;
    let asset;

    let arg$$1 = args._.shift();

    if (!arg$$1) {
      throw new AbortError(chalk`Missing arguments: see {white 'rally help asset'}`);
    }

    if (arg$$1 == "create") {
      name$$1 = name$$1.replace("#", uuid());
      asset = await Asset.createNew(name$$1, env);
    } else {
      args._.unshift(arg$$1);

      if (args.id) {
        asset = Asset.lite(args.id, env);
      } else {
        asset = await Asset.getByName(env, args.name);
      }
    }

    if (!asset) {
      throw new AbortError("No asset found/created");
    }

    while (arg$$1 = args._.shift()) {
      if (arg$$1 === "launch") {
        let initData = args["init-data"];

        if (initData && initData.startsWith("@")) {
          log(chalk`Reading init data from {white ${initData.slice(1)}}`);
          initData = fs.readFileSync(initData.slice(1), "utf-8");
        }

        let jobName = args["job-name"];
        let p = await Rule.getByName(env, jobName);

        if (!p) {
          throw new AbortError(`Cannot launch job ${jobName}, does not exist (?)`);
        } else {
          log(chalk`Launching ${p.chalkPrint(false)} on ${asset.chalkPrint(false)}`);
        }

        asset.startWorkflow(jobName, initData);
      } else if (arg$$1 === "addfile") {
        await asset.addFile(args["file-label"], args["file-uri"]);
      } else if (arg$$1 === "delete") {
        await asset.delete();
      } else if (arg$$1 === "create") {
        throw new AbortError(`Cannot have more than 1 create/get per asset call`);
      } else if (arg$$1 === "show") {
        log(asset);
      }
    }
  },

  async checkSegments(args) {
    let asset = args._.shift();

    let res = await lib.makeAPIRequest({
      env: args.env,
      path: `/movies/${asset}/metadata/Metadata`
    });
    let segments = res.data.attributes.metadata.userMetaData.segments.segments;
    let r = segments.reduce((lastSegment, val, ind) => {
      let curSegment = val.startTime;

      if (curSegment < lastSegment) {
        log("bad segment " + (ind + 1));
      }

      return val.endTime;
    }, "00:00:00:00");
  },

  async replaceItem(args) {},

  async unitTest(args) {
    await testFunction(args);
  },

  async findLeslie(args) {
    let allLesieLike = [...(await this.listAssets(args, "HGTV")), ...(await this.listAssets(args, "GAC")), ...(await this.listAssets(args, "Great American Country")), ...(await this.listAssets(args, "COOK")), ...(await this.listAssets(args, "Cooking Channel")), ...(await this.listAssets(args, "TRAV")), ...(await this.listAssets(args, "Travel Channel")), ...(await this.listAssets(args, "DIY")), ...(await this.listAssets(args, "DIY Network")), ...(await this.listAssets(args, "FOOD")), ...(await this.listAssets(args, "Food Network"))];
    return allLesieLike;
  },

  async listAssets(args, tag) {
    let req = await lib.indexPathFast({
      env: args.env,
      path: "/assets",
      qs: {
        noRelationships: true,
        sort: "id"
      },
      chunksize: 30
    });

    for (let asset of req) {
      log(asset.id);
    }

    return req;
  },

  async listSegments(args) {
    let f = JSON.parse(fs.readFileSync(args.file, "utf-8"));

    for (let asset of f) {
      var _r$data$attributes$me, _r$data$attributes$me2;

      let r = await lib.makeAPIRequest({
        env: args.env,
        path: `/movies/${asset.id}/metadata/Metadata`
      });
      let segs = (_r$data$attributes$me = r.data.attributes.metadata.userMetaData) === null || _r$data$attributes$me === void 0 ? void 0 : (_r$data$attributes$me2 = _r$data$attributes$me.segments) === null || _r$data$attributes$me2 === void 0 ? void 0 : _r$data$attributes$me2.segments;

      if (segs && segs.length > 1) {
        log(asset.id);
        log(asset.name);
      }
    }
  },

  async test2(args) {
    let wfr = await lib.indexPath({
      env: args.env,
      path: "/workflowRuleMetadata"
    });
    log(wfr);

    for (let wfrm of wfr) {
      try {
        wfrm.id = undefined;
        wfrm.links = undefined;
        log(wfrm);
        let req = await lib.makeAPIRequest({
          env: "DEV",
          path: "/workflowRuleMetadata",
          method: "POST",
          payload: {
            data: wfrm
          }
        });
      } catch (e) {
        log("caught");
      } //break;

    }
  },

  async test3(args) {
    let wfr = await lib.indexPath({
      env: args.env,
      path: "/workflowRuleMetadata"
    });
    log(wfr);

    for (let wfrm of wfr) {
      try {
        wfrm.id = undefined;
        wfrm.links = undefined;
        log(wfrm);
        let req = await lib.makeAPIRequest({
          env: "DEV",
          path: "/workflowRuleMetadata",
          method: "POST",
          payload: {
            data: wfrm
          }
        });
      } catch (e) {
        log("caught");
      } //break;

    }
  },

  async ["@"](args) {
    args._.unshift("-");

    args._.unshift("make");

    return this.supply(args);
  },

  async test(args) {
    let asset = await Asset.getByName("UAT", args.name);
    log(asset);
  },

  //Used to test startup and teardown speed.
  noop() {
    return true;
  }

}, (_applyDecoratedDescriptor(_obj, "help", [_dec, _dec2, _dec3], Object.getOwnPropertyDescriptor(_obj, "help"), _obj), _applyDecoratedDescriptor(_obj, "jupyter", [_dec4, _dec5, _dec6], Object.getOwnPropertyDescriptor(_obj, "jupyter"), _obj), _applyDecoratedDescriptor(_obj, "preset", [_dec7, _dec8, _dec9, _dec10, _dec11, _dec12], Object.getOwnPropertyDescriptor(_obj, "preset"), _obj), _applyDecoratedDescriptor(_obj, "rule", [_dec13, _dec14, _dec15, _dec16], Object.getOwnPropertyDescriptor(_obj, "rule"), _obj), _applyDecoratedDescriptor(_obj, "supply", [_dec17, _dec18, _dec19, _dec20, _dec21], Object.getOwnPropertyDescriptor(_obj, "supply"), _obj), _applyDecoratedDescriptor(_obj, "providers", [_dec22, _dec23, _dec24, _dec25, _dec26], Object.getOwnPropertyDescriptor(_obj, "providers"), _obj), _applyDecoratedDescriptor(_obj, "config", [_dec27, _dec28, _dec29, _dec30, _dec31], Object.getOwnPropertyDescriptor(_obj, "config"), _obj), _applyDecoratedDescriptor(_obj, "asset", [_dec32, _dec33, _dec34, _dec35, _dec36, _dec37, _dec38, _dec39, _dec40], Object.getOwnPropertyDescriptor(_obj, "asset"), _obj)), _obj));

async function unknownCommand(cmd) {
  log(chalk`Unknown command {red ${cmd}}.`);
}

async function noCommand() {
  write(chalk`
Rally Tools {yellow v${version} (alpha)} CLI
by John Schmidt <John_Schmidt@discovery.com>
`); //Prompt users to setup one time config.

  if (!configObject.hasConfig) {
    write(chalk`
It looks like you haven't setup the config yet. Please run '{green rally config}'.
`);
    return;
  } //API Access tests


  for (let env of ["LOCAL", "DEV", "UAT", "QA", "PROD"]) {
    //Test access. Returns HTTP response code
    let resultStr;

    try {
      let result = await rallyFunctions.testAccess(env); //Create a colored display and response

      resultStr = chalk`{yellow ${result} <unknown>}`;
      if (result === 200) resultStr = chalk`{green 200 OK}`;else if (result === 401) resultStr = chalk`{red 401 No Access}`;else if (result >= 500) resultStr = chalk`{yellow ${result} API Down?}`;else if (result === true) resultStr = chalk`{green OK}`;else if (result === false) resultStr = chalk`{red BAD}`;
    } catch (e) {
      if (e instanceof UnconfiguredEnvError) {
        resultStr = chalk`{yellow Unconfigured}`;
      } else if (e instanceof APIError) {
        if (!e.response.body) {
          resultStr = chalk`{red Timeout (?)}`;
        }
      } else if (e.name == "RequestError") {
        resultStr = chalk`{red Low level error (check internet): ${e.error.errno}}`;
      } else {
        throw e;
      }
    }

    log(chalk`   ${env}: ${resultStr}`);
  }
}

async function $main() {
  //Supply --config to load a different config file
  if (argv.config) loadConfig(argv.config); // First we need to decide if the user wants color or not. If they do want
  // color, we need to make sure we use the right mode

  chalk.enabled = configObject.hasConfig ? configObject.chalk : true;

  if (chalk.level === 0 || !chalk.enabled) {
    let force = argv["force-color"];

    if (force) {
      chalk.enabled = true;

      if (force === true && chalk.level === 0) {
        chalk.level = 1;
      } else if (Number(force)) {
        chalk.level = Number(force);
      }
    }
  } //This flag being true allows you to modify UAT and PROD


  if (!argv["protect"]) {
    configObject.dangerModify = true;
  } //This enables raw output for some functions


  if (argv["raw"]) {
    configObject.rawOutput = true;

    global.log = () => {};

    global.errorLog = () => {};

    global.write = () => {};
  }

  if (argv["ignore-missing"]) {
    configObject.ignoreMissing = true;
  } //Default enviornment should normally be from config, but it can be
  //overridden by the -e/--env flag


  if (configObject.defaultEnv) {
    argv.env = argv.env || configObject.defaultEnv;
  } //Enable verbose logging in some places.


  if (argv["vverbose"]) {
    configObject.verbose = argv["vverbose"];
    configObject.vverbose = true;
  } else if (argv["verbose"]) {
    configObject.verbose = argv["verbose"];
  } //copy argument array to new object to allow modification


  argv._old = argv._.slice(); //Take first argument after `node bundle.js`
  //If there is no argument, display the default version info and API access.

  let func = argv._.shift();

  if (func) {
    if (!cli[func]) return await unknownCommand(func);

    try {
      //Call the cli function
      let ret = await cli[func](argv);

      if (ret) {
        write(chalk.white("CLI returned: "));
        if (ret instanceof Collection) ret = ret.arr; //Directly use console.log so that --raw works as intended.

        if (typeof ret === "object") {
          console.log(JSON.stringify(ret, null, 4));
        } else {
          console.log(ret);
        }
      }
    } catch (e) {
      if (e instanceof AbortError) {
        log(chalk`{red CLI Aborted}: ${e.message}`);
      } else {
        throw e;
      }
    }
  } else {
    await noCommand();
  }
}

async function main$1(...args) {
  //Catch all for errors to avoid ugly default node promise catcher
  try {
    await $main(...args);
  } catch (e) {
    errorLog(e.stack);
  }
} // If this is an imported module, then we should exec the cli interface.
// Oterwise just export everything.


if (require.main === module) {
  main$1();
} else {
  module.exports = allIndexBundle;
}
//# sourceMappingURL=bundle.js.map

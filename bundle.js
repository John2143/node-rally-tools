#!/usr/bin/env node
/*----------------------------------------------
 * Generated by rollup. Written by John Schmidt.
 * Rally Tools CLI v1.8.3
 *--------------------------------------------*/
const importLazy = require("import-lazy")(require);

'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var os = require('os');
var fs = require('fs');
var fs__default = _interopDefault(fs);
var child_process = require('child_process');
var perf_hooks = require('perf_hooks');
var chalk$1 = _interopDefault(require('chalk'));
var path = require('path');
var path__default = _interopDefault(path);
var argparse = _interopDefault(require('minimist'));

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

let configFile = os.homedir() + "/.rallyconfig";
let configObject;
function loadConfig(file) {
  if (file) configFile = file;
  configObject = {
    hasConfig: true
  };

  try {
    let json = fs.readFileSync(configFile);
    configObject = JSON.parse(json);
  } catch (e) {
    if (e.code == "ENOENT") {
      configObject.hasConfig = false; //ok, they should probably make a config
    } else {
      throw e;
    }
  }
}
function setConfig(obj) {
  configObject = obj;
}
loadConfig();

//these are the help entries for each command
let helpEntries = {};

let helpEntry = name => helpEntries[name] ? helpEntries[name] : helpEntries[name] = {
  name
}; //short description


function helpText(text) {
  return function (func, name) {
    helpEntry(name).text = text;
    return func;
  };
} //flag type argument like -f or --file

function arg(long, short, desc) {
  return function (func, name) {
    let args = helpEntry(name).args = helpEntry(name).args || [];
    args.unshift({
      long,
      short,
      desc
    });
    return func;
  };
} //normal argument

function param(param, desc) {
  return function (func, name) {
    let params = helpEntry(name).params = helpEntry(name).params || [];
    params.unshift({
      param,
      desc
    });
    return func;
  };
} //usage string

function usage(usage) {
  return function (func, name) {
    usage = usage.replace(/[\[<](\w+)[\]>]/g, chalk`[{blue $1}]`);
    helpEntry(name).usage = usage;
    return func;
  };
}
//function retuns obj.a.b.c

function deepAccess(obj, path$$1) {
  let o = obj;

  for (let key of path$$1) {
    if (!o) return [];
    o = o[key];
  }

  return o;
} //This takes a class as the first argument, then adds a getter/setter pair that
//corresponds to an object in this.data


function defineAssoc(classname, shortname, path$$1) {
  path$$1 = path$$1.split(".");
  let lastKey = path$$1.pop();
  Object.defineProperty(classname.prototype, shortname, {
    get() {
      return deepAccess(this, path$$1)[lastKey];
    },

    set(val) {
      deepAccess(this, path$$1)[lastKey] = val;
    }

  });
}

function spawn(options, ...args) {
  if (typeof options !== "object") {
    args.unshift(options);
    options = {};
  } //todo options


  return new Promise((resolve, reject) => {
    let start = perf_hooks.performance.now();
    let stdout = "";
    let stderr = "";
    let cp = child_process.spawn(...args);
    if (cp.stdout) cp.stdout.on("data", chunk => {
      stdout += chunk;
      write(chunk);
    });
    if (cp.stderr) cp.stderr.on("data", chunk => {
      stderr += chunk;
      write(chunk);
    });
    cp.on("error", reject);
    cp.on("close", code => {
      let end = perf_hooks.performance.now();
      let time = end - start;
      let timestr = time > 1000 ? (time / 100 | 0) / 10 + "s" : (time | 0) + "ms";
      resolve({
        stdout,
        stderr,
        exitCode: code,
        time,
        timestr
      });
    });
  });
}

const rp = importLazy("request-promise");
global.chalk = chalk$1;

global.log = text => console.log(text);

global.write = text => process.stdout.write(text);

global.errorLog = text => log(chalk$1.red(text));

class lib {
  //This function takes 2 required arguemnts:
  // env: the enviornment you wish to use
  // and either:
  //  'path', the short path to the resource. ex '/presets/'
  //  'path_full', the full path to the resource like 'https://discovery-dev.sdvi.com/presets'
  //
  // If the method is anything but GET, either payload or body should be set.
  // payload should be a javascript object to be turned into json as the request body
  // body should be a string that is passed as the body. for example: the python code of a preset.
  //
  // qs are the querystring parameters, in a key: value object.
  // {filter: "name=test name"} becomes something like 'filter=name=test+name'
  //
  // headers are the headers of the request. "Content-Type" is already set if
  //   payload is given as a parameter
  //
  // fullResponse should be true if you want to receive the request object,
  //  not just the returned data.
  static async makeAPIRequest({
    env,
    path: path$$1,
    path_full,
    payload,
    body,
    method = "GET",
    qs,
    headers = {},
    fullResponse = false,
    timeout = configObject.timeout || 0
  }) {
    var _configObject$api;

    //Keys are defined in enviornment variables
    let config = configObject === null || configObject === void 0 ? void 0 : (_configObject$api = configObject.api) === null || _configObject$api === void 0 ? void 0 : _configObject$api[env];

    if (!config) {
      throw new Error(env);
    }

    if (method !== "GET" && !configObject.dangerModify) {
      if (env === "UAT" && configObject.restrictUAT || env === "PROD") {
        throw new ProtectedEnvError(env);
      }
    }

    let rally_api_key = config.key;
    let rally_api = config.url;
    path$$1 = path_full || rally_api + path$$1;

    if (payload) {
      body = JSON.stringify(payload);
    }

    if (configObject.vverbose) {
      log(chalk$1`${method} @ ${path$$1}`);

      if (qs) {
        log(qs);
      }
    }

    if (payload) {
      headers["Content-Type"] = "application/vnd.api+json";
    }

    let requestOptions = {
      method,
      body,
      qs,
      uri: path$$1,
      timeout,
      auth: {
        bearer: rally_api_key
      },
      headers: {
        //SDVI ignores this header sometimes.
        Accept: "application/vnd.api+json",
        ...headers
      },
      simple: false,
      resolveWithFullResponse: true
    };
    let response;

    try {
      response = await rp(requestOptions);
    } catch (e) {
      if ((e === null || e === void 0 ? void 0 : e.cause.code) === "ESOCKETTIMEDOUT") {
        throw new APIError(response || {}, requestOptions, body);
      } else {
        throw e;
      }
    } //Throw an error for any 5xx or 4xx


    if (!fullResponse && ![200, 201, 204].includes(response.statusCode)) {
      throw new APIError(response, requestOptions, body);
    }

    let contentType = response.headers["content-type"];
    let isJSONResponse = contentType === "application/vnd.api+json" || contentType === "application/json";

    if (fullResponse) {
      return response;
    } else if (isJSONResponse) {
      try {
        return JSON.parse(response.body);
      } catch (e) {
        log(response.body);
        throw new AbortError("Body is not valid json: ");
      }
    } else {
      return response.body;
    }
  } //Index a json endpoint that returns a {links} field.
  //This function returns the merged data objects as an array
  //


  static async indexPath(env, path$$1) {
    let all = [];
    let opts = typeof env === "string" ? {
      env,
      path: path$$1
    } : env;
    let json = await this.makeAPIRequest(opts);
    let [numPages, pageSize] = this.numPages(json.links.last); //log(`num pages: ${numPages} * ${pageSize}`);

    all = [...json.data];

    while (json.links.next) {
      json = await this.makeAPIRequest({ ...opts,
        path_full: json.links.next
      });
      all = [...all, ...json.data];
    }

    return all;
  } //Returns number of pages and pagination size


  static numPages(str) {
    return /page=(\d+)p(\d+)/.exec(str).slice(1);
  }

  static arrayChunk(array, chunkSize) {
    let newArr = [];

    for (let i = 0; i < array.length; i += chunkSize) {
      newArr.push(array.slice(i, i + chunkSize));
    }

    return newArr;
  }

  static async doPromises(promises, result = []) {
    for (let promise of promises) {
      result.push((await promise));
    }

    return result;
  } //Index a json endpoint that returns a {links} field.
  //
  //This function is faster than indexPath because it can guess the pages it
  //needs to retreive so that it can request all assets at once.
  //
  //This function assumes that the content from the inital request is the
  //first page, so starting on another page may cause issues. Consider
  //indexPath for that.


  static async indexPathFast(env, path$$1) {
    let opts = typeof env === "string" ? {
      env,
      path: path$$1
    } : env;
    let json = await this.makeAPIRequest(opts);
    let baselink = json.links.first;

    const linkToPage = page => baselink.replace("page=1p", `page=${page}p`);

    let [numPages, pageSize] = this.numPages(json.links.last); //log(`num pages: ${numPages} * ${pageSize}`);
    //Construct an array of all the requests that are done simultanously.
    //Assume that the content from the inital request is the first page.

    let allResults = [];
    let promises = [Promise.resolve(json)];

    for (let i = 2; i <= (opts.limit ? opts.limit : numPages); i++) {
      if (promises.length === 5) {
        log("Chunk found");
        await this.doPromises(promises, allResults);
        promises = [];
      }

      let req = this.makeAPIRequest({ ...opts,
        path_full: linkToPage(i)
      });
      promises.push(req);
    }

    await this.doPromises(promises, allResults);
    let all = [];

    for (let result of allResults) {
      for (let item of result.data) {
        all.push(item);
      }
    }

    return all;
  }

  static isLocalEnv(env) {
    return !env || env === "LOCAL" || env === "LOC";
  }

  static envName(env) {
    if (this.isLocalEnv(env)) return "LOCAL";
    return env;
  }

  static async startJob(env, movie, preset) {
    var _movieObj$data, _movieObj$data$;

    let movieObj = await this.makeAPIRequest({
      env,
      path: "/movies",
      qs: {
        filter: `name=${movie}`
      }
    });
    let id = movieObj === null || movieObj === void 0 ? void 0 : (_movieObj$data = movieObj.data) === null || _movieObj$data === void 0 ? void 0 : (_movieObj$data$ = _movieObj$data[0]) === null || _movieObj$data$ === void 0 ? void 0 : _movieObj$data$.id;
    if (!id) return {}; // Fire and forget.

    let data = await this.makeAPIRequest({
      env,
      path: "/jobs",
      method: "POST",
      payload: {
        data: {
          type: "jobs",
          relationships: {
            movie: {
              data: {
                id: id,
                type: "movies"
              }
            },
            preset: {
              data: {
                id: preset,
                type: "presets"
              }
            }
          }
        }
      }
    });
    return {
      movieId: id,
      reqData: data
    };
  }

}
class AbortError extends Error {
  constructor(message) {
    super(message);
    Error.captureStackTrace(this, this.constructor);
    this.name = "AbortError";
  }

}
class APIError extends Error {
  constructor(response, opts, body) {
    super(chalk$1`
{reset Request returned} {yellow ${response === null || response === void 0 ? void 0 : response.statusCode}}{
{green ${JSON.stringify(opts, null, 4)}}
{green ${body}}
{reset ${response.body}}
===============================
{red ${response.body ? "Request timed out" : "Bad response from API"}}
===============================
        `);
    this.response = response;
    this.opts = opts;
    this.body = body;
    Error.captureStackTrace(this, this.constructor);
    this.name = "ApiError";
  }

}
class UnconfiguredEnvError extends AbortError {
  constructor(env) {
    super("Unconfigured enviornment: " + env);
    this.name = "Unconfigured Env Error";
  }

}
class ProtectedEnvError extends AbortError {
  constructor(env) {
    super("Protected enviornment: " + env);
    this.name = "Protected Env Error";
  }

}
class Collection {
  constructor(arr) {
    this.arr = arr;
  }

  [Symbol.iterator]() {
    return this.arr[Symbol.iterator]();
  }

  findById(id) {
    return this.arr.find(x => x.id == id);
  }

  findByName(name) {
    return this.arr.find(x => x.name == name);
  }

  findByNameContains(name) {
    return this.arr.find(x => x.name.includes(name));
  }

  log() {
    for (let d of this) {
      if (d) {
        log(d.chalkPrint(true));
      } else {
        log(chalk$1`{red (None)}`);
      }
    }
  }

  get length() {
    return this.arr.length;
  }

}
class RallyBase {
  static isLoaded(env) {
    if (!this.hasLoadedAll) return;
    return this.hasLoadedAll[env];
  }

  static async getById(env, id) {
    if (this.isLoaded(env)) {
      return (await this.constructor.getAll(env)).findById(id);
    } else {
      let data = await lib.makeAPIRequest({
        env,
        path: `/${this.endpoint}/${id}`
      });
      if (data.data) return new this({
        data: data.data,
        remote: env
      });
    }
  }

  static async getByName(env, name) {
    if (this.isLoaded(env)) {
      return (await this.getAll(env)).findByName(name);
    } else {
      let data = await lib.makeAPIRequest({
        env,
        path: `/${this.endpoint}`,
        qs: {
          filter: `name=${name}`
        }
      });
      if (data.data[0]) return new this({
        data: data.data[0],
        remote: env
      });
    }
  }

  static async getAllPreCollect(d) {
    return d;
  }

  static async getAll(env) {
    this.hasLoadedAll = this.hasLoadedAll || {};
    if (this.isLoaded(env)) return this.hasLoadedAll[env];
    let datas = await lib.indexPathFast(env, `/${this.endpoint}?page=1p10`);
    datas = await this.getAllPreCollect(datas);
    let all = new Collection(datas.map(data => new this({
      data,
      remote: env
    })));
    this.hasLoadedAll[env] = all;
    return all;
  }

  static async removeCache(env) {
    this.hasLoadedAll = this.hasLoadedAll || {};

    if (this.isLoaded(env)) {
      this.hasLoadedAll[env] = undefined;
    }
  } //Specific turns name into id based on env
  //Generic turns ids into names


  async resolveApply(type, dataObj, direction) {
    let obj;

    if (direction == "generic") {
      obj = await type.getById(this.remote, dataObj.id);

      if (obj) {
        dataObj.name = obj.name;
      }
    } else if (direction == "specific") {
      obj = await type.getByName(this.remote, dataObj.name);

      if (obj) {
        log("HAS NAME");
        dataObj.id = obj.id;
      }
    }

    return obj;
  } //Type is the baseclass you are looking for (should extend RallyBase)
  //name is the name of the field
  //isArray is true if it has multiple cardinailty, false if it is single
  //direction gets passed directly to resolveApply


  async resolveField(type, name, isArray = false, direction = "generic") {
    // ignore empty fields
    let field = this.relationships[name];
    if (!(field === null || field === void 0 ? void 0 : field.data)) return;

    if (isArray) {
      return await Promise.all(field.data.map(o => this.resolveApply(type, o, direction)));
    } else {
      return await this.resolveApply(type, field.data, direction);
    }
  }

  cleanup() {
    for (let [key, val] of Object.entries(this.relationships)) {
      //Remove ids from data
      if (val.data) {
        if (val.data.id) {
          delete val.data.id;
        } else if (val.data[0]) {
          for (let x of val.data) delete x.id;
        }
      }

      delete val.links;
    } // organization is unused (?)


    delete this.relationships.organization; // id is specific to envs

    delete this.data.id; // links too

    delete this.data.links;
  }

}

class Provider extends RallyBase {
  constructor({
    data,
    remote
  }) {
    super();
    this.data = data;
    this.meta = {};
    this.remote = remote;
  } //cached


  async getEditorConfig() {
    if (this.editorConfig) return this.editorConfig;
    this.editorConfig = await lib.makeAPIRequest({
      env: this.remote,
      path_full: this.data.links.editorConfig
    });
    this.editorConfig.fileExt = await this.getFileExtension();
    return this.editorConfig;
  }

  static async getAllPreCollect(providers) {
    return providers.sort((a, b) => {
      return a.attributes.category.localeCompare(b.attributes.category) || a.attributes.name.localeCompare(b.attributes.name);
    });
  }

  async getFileExtension() {
    let config = await this.getEditorConfig();
    let map = {
      python: "py",
      text: "txt",

      getmap(key) {
        if (this.name === "Aurora") return "zip";
        if (this[key]) return this[key];
        return key;
      }

    };
    return map.getmap(config.lang);
  }

  chalkPrint(pad = true) {
    let id = String(this.id);
    if (pad) id = id.padStart(4);
    return chalk`{green ${id}}: {blue ${this.category}} - {green ${this.name}}`;
  }

}

defineAssoc(Provider, "id", "data.id");
defineAssoc(Provider, "name", "data.attributes.name");
defineAssoc(Provider, "category", "data.attributes.category");
defineAssoc(Provider, "remote", "meta.remote");
defineAssoc(Provider, "editorConfig", "meta.editorConfig");
Provider.endpoint = "providerTypes";

let exists = {};

class Preset extends RallyBase {
  constructor({
    path: path$$1,
    remote,
    data
  } = {}) {
    // Get full path if possible
    if (path$$1) {
      path$$1 = path.resolve(path$$1);

      if (path.dirname(path$$1).includes("silo-metadata")) {
        throw new AbortError("Constructing preset from metadata file");
      }
    }

    super(); // Cache by path

    if (path$$1) {
      if (exists[path$$1]) return exists[path$$1];
      exists[path$$1] = this;
    }

    this.meta = {};
    this.remote = remote;

    if (lib.isLocalEnv(this.remote)) {
      if (path$$1) {
        this.path = path$$1;
        let pathspl = this.path.split(".");
        this.ext = pathspl[pathspl.length - 1];

        try {
          this.code = this.getLocalCode();
        } catch (e) {
          log(chalk`{red Node Error} ${e.message}`);
          throw new AbortError("Could not load code of local file");
        }

        let name = this.parseFilenameForName() || this.parseCodeForName();

        try {
          this.data = this.getLocalMetadata();
          this.isGeneric = true;
          name = this.name;
        } catch (e) {
          this.data = Preset.newShell();
          this.isGeneric = false;
        }

        this.name = name;
      } else {
        this.data = Preset.newShell();
      }
    } else {
      this.data = data; //this.name = data.attributes.name;
      //this.id = data.id;

      this.isGeneric = false;
    }
  } //Given a metadata file, get its actualy file


  static async fromMetadata(path$$1) {
    let data = JSON.parse(fs__default.readFileSync(path$$1));
    let provider = Provider.getByName(data.relationships.providerType.data.name);
    let ext = await provider.getFileExtension();
    let name = data.attributes.name;
    let realpath = Preset.getLocalPath(name, ext);
    return new Preset({
      path: realpath
    });
  }

  static newShell() {
    return {
      "attributes": {
        "providerSettings": {}
      },
      "relationships": {},
      "type": "presets"
    };
  }

  cleanup() {
    super.cleanup();
    delete this.attributes["createdAt"];
    delete this.attributes["updatedAt"];
  }

  async acclimatize(env) {
    if (!this.isGeneric) throw AbortError("Cannot acclimatize non-generics or shells");
    let providers = await Provider.getProviders(env);
    let ptype = this.relationships["providerType"];
    ptype = ptype.data;
    let provider = providers.findByName(ptype.name);
    ptype.id = provider.id;
  }

  get test() {
    if (!this.code) return;
    const regex = /autotest:\s?([\w\d_. \/]+)[\r\s\n]*?/gm;
    let match;
    let matches = [];

    while (match = regex.exec(this.code)) {
      matches.push(match[1]);
    }

    return matches;
  }

  async runTest(env) {
    let remote = await Preset.getByName(env, this.name);

    for (let test of this.test) {
      write(chalk`Starting job {green ${this.name}} on {green ${test}}... `);
      let {
        movieId
      } = await lib.startJob(env, test, remote.id);

      if (movieId) {
        write(chalk`movie {blue ${movieId}}. `);
        log(chalk`OK`);
      } else {
        log(chalk`{red No movie found}, Fail.`);
      }
    }
  }

  async resolve() {
    if (this.isGeneric) return;
    let providers = await Provider.getProviders(this.remote);
    let proType = this.resolveField(providers, "providerType");
    this.ext = await proType.getFileExtension();
    this.isGeneric = true;
    return {
      proType
    };
  }

  async saveLocal() {
    await this.saveLocalMetadata();
    await this.saveLocalFile();
  }

  async saveLocalMetadata() {
    if (!this.isGeneric) {
      await this.resolve();
      this.cleanup();
    }

    fs__default.writeFileSync(this.localmetadatapath, JSON.stringify(this.data, null, 4));
  }

  async saveLocalFile() {
    fs__default.writeFileSync(this.localpath, this.code);
  }

  async uploadRemote(env) {
    await this.uploadCodeToEnv(env, true);
  }

  async save(env) {
    this.saved = true;

    if (!this.isGeneric) {
      await this.resolve();
    } //log(chalk`Saving {green ${this.name}} to {blue ${lib.envName(env)}}.`)


    this.cleanup();

    if (lib.isLocalEnv(env)) {
      await this.saveLocal();
    } else {
      await this.uploadRemote(env);
    }
  }

  async downloadCode() {
    if (!this.remote || this.code) return this.code;
    return this.code = await lib.makeAPIRequest({
      env: this.remote,
      path_full: this.data.links.providerData,
      json: false
    });
  }

  get code() {
    if (this._code) return this._code;
  }

  set code(v) {
    this._code = v;
  }

  chalkPrint(pad = true) {
    let id = String("P-" + (this.remote && this.remote + "-" + this.id || "LOCAL"));
    if (pad) id = id.padStart(10);

    if (this.meta.proType) {
      return chalk`{green ${id}}: {red ${this.meta.proType.name}} {blue ${this.name}}`;
    } else {
      return chalk`{green ${id}}: {blue ${this.name}}`;
    }
  }

  parseFilenameForName() {
    if (this.path.endsWith(".jinja") || this.path.endsWith(".json")) {
      return path.basename(this.path).replace("_", " ").replace("-", " ").replace(".json", "").replace(".jinja", "");
    }
  }

  parseCodeForName() {
    const name_regex = /name\s?:\s([\w\d. \/]+)[\r\s\n]*?/;
    const match = name_regex.exec(this.code);
    if (match) return match[1];
  }

  findStringsInCode(strings) {
    if (!this.code) return [];
    return strings.filter(str => {
      let regex = new RegExp(str);
      return !!this.code.match(regex);
    });
  }

  static getLocalPath(name, ext) {
    return path__default.join(configObject.repodir, "silo-presets", name + "." + ext);
  }

  get localpath() {
    return Preset.getLocalPath(this.name, this.ext);
  }

  get path() {
    if (this._path) return this._path;
  }

  set path(val) {
    this._path = val;
  }

  get name() {
    return this._nameOuter;
  }

  set name(val) {
    this._nameInner = val;
    this._nameOuter = val;
  }

  set providerType(value) {
    this.relationships["providerType"] = {
      data: { ...value,
        type: "providerTypes"
      }
    };
  }

  get localmetadatapath() {
    let fname = this.name;

    if (!fname && this.path) {
      let bname = path.basename(this.path);
      fname = bname.substring(0, bname.length - (this.ext.length + 1));
    }

    return path__default.join(configObject.repodir, "silo-metadata", fname + ".json");
  }

  get immutable() {
    return this.name.includes("Constant");
  }

  async uploadPresetData(env, id) {
    let res = await lib.makeAPIRequest({
      env,
      path: `/presets/${id}/providerData`,
      body: this.code,
      method: "PUT",
      fullResponse: true,
      timeout: 5000
    });
    write(chalk`response {yellow ${res.statusCode}} `);
  }

  async grabMetadata(env) {
    let remote = await Preset.getByName(env, this.name);
    this.isGeneric = false;

    if (!remote) {
      throw new AbortError(`No file found on remote ${env} with name ${this.name}`);
    }

    this.data = remote.data;
    this.remote = env;
  }

  async uploadCodeToEnv(env, includeMetadata) {
    if (!this.name) {
      log(chalk`Failed uploading {red ${this.path}}. No name found.`);
      return;
    }

    write(chalk`Uploading preset {green ${this.name}} to {green ${env}}: `);

    if (this.immutable) {
      log(chalk`{magenta IMMUTABLE}. Nothing to do.`);
      return;
    } //First query the api to see if this already exists.


    let remote = await Preset.getByName(env, this.name);

    if (remote) {
      //If it exists we can replace it
      write("replace, ");

      if (includeMetadata) {
        await lib.makeAPIRequest({
          env,
          path: `/presets/${remote.id}`,
          method: "PATCH",
          payload: {
            data: {
              attributes: this.data.attributes,
              type: "presets"
            }
          }
        });
        write("metadata OK, ");
      }

      await this.uploadPresetData(env, remote.id);
    } else {
      write("create, ");
      let metadata = {
        data: this.data
      };

      if (!this.relationships["providerType"]) {
        throw new AbortError("Cannot acclimatize shelled presets. (try creating it on the env first)");
      }

      await this.acclimatize(env);
      write("Posting to create preset... ");
      let res = await lib.makeAPIRequest({
        env,
        path: `/presets`,
        method: "POST",
        payload: metadata,
        timeout: 5000
      });
      let id = res.data.id;
      write(chalk`Created id {green ${id}}... Uploading Code... `);
      await this.uploadPresetData(env, id);
    }

    write("Done. ");

    if (this.test) {
      log("test...");
      this.runTest(env);
    } else {
      log("No test");
    }
  }

  getLocalMetadata() {
    return JSON.parse(fs__default.readFileSync(this.localmetadatapath, "utf-8"));
  }

  getLocalCode() {
    return fs__default.readFileSync(this.path, "utf-8");
  }

}

defineAssoc(Preset, "_nameInner", "data.attributes.providerSettings.PresetName");
defineAssoc(Preset, "_nameOuter", "data.attributes.name");
defineAssoc(Preset, "id", "data.id");
defineAssoc(Preset, "attributes", "data.attributes");
defineAssoc(Preset, "relationships", "data.relationships");
defineAssoc(Preset, "remote", "meta.remote");
defineAssoc(Preset, "_code", "meta.code");
defineAssoc(Preset, "_path", "meta.path");
defineAssoc(Preset, "isGeneric", "meta.isGeneric");
defineAssoc(Preset, "ext", "meta.ext");
Preset.endpoint = "presets";

class Notification extends RallyBase {
  constructor({
    data,
    remote
  }) {
    super();
    this.data = data;
    this.meta = {};
    this.remote = remote;
  }

  static async getAllPreCollect(notifications) {
    return notifications.sort((a, b) => {
      return a.attributes.type.localeCompare(b.attributes.type) || a.attributes.name.localeCompare(b.attributes.name);
    });
  }

  chalkPrint(pad = false) {
    let id = String("N-" + this.id);
    if (pad) id = id.padStart(4);
    return chalk`{green ${id}}: {blue ${this.type}} - {green ${this.name}}`;
  }

}

defineAssoc(Notification, "id", "data.id");
defineAssoc(Notification, "name", "data.attributes.name");
defineAssoc(Notification, "address", "data.attributes.address");
defineAssoc(Notification, "type", "data.attributes.type");
defineAssoc(Notification, "remote", "meta.remote");
Notification.endpoint = "notificationPresets";

class Rule extends RallyBase {
  constructor({
    path: path$$1,
    data,
    remote
  } = {}) {
    super();

    if (path$$1) {
      path$$1 = path.resolve(path$$1);
      let f = fs__default.readFileSync(path$$1, "utf-8");
      data = JSON.parse(fs__default.readFileSync(path$$1, "utf-8"));
    }

    if (!data) {
      data = Rule.newShell();
    }

    this.data = data;
    this.meta = {};
    this.remote = remote;
    this.isGeneric = !this.remote;
  }

  static newShell() {
    return {
      "attributes": {
        "description": "-",
        "priority": "PriorityNorm",
        "starred": false
      },
      "relationships": {},
      "type": "workflowRules"
    };
  }

  async acclimatize(env) {
    this.remote = env;
    let preset = await this.resolveField(Preset, "preset", false, "specific");
    let pNext = await this.resolveField(Rule, "passNext", false, "specific");
    let eNext = await this.resolveField(Rule, "errorNext", false, "specific");
    let proType = await this.resolveField(Provider, "providerType", false, "specific");
    let dynamicNexts = await this.resolveField(Rule, "dynamicNexts", true, "specific");
    let enterNotif = await this.resolveField(Notification, "enterNotifications", true, "specific");
    let errorNotif = await this.resolveField(Notification, "errorNotifications", true, "specific");
    let passNotif = await this.resolveField(Notification, "passNotifications", true, "specific");
  }

  async saveA(env) {
    if (lib.isLocalEnv(env)) return;
    return await this.createIfNotExist(env);
  }

  async saveB(env) {
    if (!this.isGeneric) {
      await this.resolve();
    }

    this.cleanup();

    if (lib.isLocalEnv(env)) {
      fs__default.writeFileSync(this.localpath, JSON.stringify(this.data, null, 4));
    } else {
      await this.acclimatize(env);
      await this.uploadRemote(env);
    }
  }

  get immutable() {
    return false;
  }

  async createIfNotExist(env) {
    write(chalk`First pass rule {green ${this.name}} to {green ${env}}: `);

    if (this.immutable) {
      log(chalk`{magenta IMMUTABLE}. Nothing to do.`);
      return;
    } //First query the api to see if this already exists.


    let remote = await Rule.getByName(env, this.name);
    this.idMap = this.idMap || {};

    if (remote) {
      this.idMap[env] = remote.id;
      log(chalk`exists ${remote.chalkPrint(false)}`);
      return;
    } //If it exists we can replace it


    write("create, ");
    let res = await lib.makeAPIRequest({
      env,
      path: `/workflowRules`,
      method: "POST",
      payload: {
        data: {
          attributes: {
            name: this.name
          },
          type: "workflowRules"
        }
      }
    });
    this.idMap = this.idMap || {};
    this.idMap[env] = res.data.id;
    write("id ");
    log(this.idMap[env]);
  }

  async patchStrip() {
    delete this.data.attributes.createdAt;
    delete this.data.attributes.starred;
    delete this.data.attributes.updatedAt; // TEMP FIX FOR BUG IN SDVI

    if (this.relationships.passMetadata && this.relationships.passMetadata[0]) {
      log("HAS PASS");
      log(this.name);
      log("HAS PASS");
    }

    delete this.relationships.passMetadata;

    if (this.relationships.errorMetadata && this.relationships.errorMetadata[0]) {
      log("HAS PASS");
      log(this.name);
      log("HAS PASS");
    }

    delete this.relationships.errorMetadata; // This is commented out because it was fixed.
    //for(let key in this.relationships){
    //let relationship = this.relationships[key];
    //if(!relationship.data || relationship.data instanceof Array && !relationship.data[0]){
    //delete this.relationships[key];
    //}
    //}
  }

  async uploadRemote(env) {
    write(chalk`Uploading rule {green ${this.name}} to {green ${env}}: `);

    if (this.immutable) {
      log(chalk`{magenta IMMUTABLE}. Nothing to do.`);
      return;
    }

    if (this.idMap[env]) {
      this.remote = env;
      await this.patchStrip();
      this.data.id = this.idMap[env]; //If it exists we can replace it

      write("replace, ");
      let res = await lib.makeAPIRequest({
        env,
        path: `/workflowRules/${this.idMap[env]}`,
        method: "PATCH",
        payload: {
          data: this.data
        },
        fullResponse: true
      });
      log(chalk`response {yellow ${res.statusCode}}`);

      if (res.statusCode !== 200) {
        log(res.body);
        log(JSON.stringify(this.data, null, 4));
      }
    } else {
      throw Error("Bad idmap!");
    }
  }

  get localpath() {
    return path.join(configObject.repodir, "silo-rules", this.name + ".json");
  }

  async resolve() {
    let preset = await this.resolveField(Preset, "preset", false);
    log(preset);
    let pNext = await this.resolveField(Rule, "passNext", false);
    let eNext = await this.resolveField(Rule, "errorNext", false);
    let proType = await this.resolveField(Provider, "providerType", false); //log("Dynamic nexts")

    let dynamicNexts = await this.resolveField(Rule, "dynamicNexts", true); //log(dynamicNexts);

    let enterNotif = await this.resolveField(Notification, "enterNotifications", true);
    let errorNotif = await this.resolveField(Notification, "errorNotifications", true);
    let passNotif = await this.resolveField(Notification, "passNotifications", true); //TODO Unsupported

    delete this.relationships["enterMetadata"];
    delete this.relationships["errorMetadata"];
    this.isGeneric = true;
    return {
      preset,
      proType,
      pNext,
      eNext,
      dynamicNexts,
      errorNotif,
      enterNotif,
      passNotif
    };
  }

  chalkPrint(pad = true) {
    let id = String("R-" + (this.remote && this.remote + "-" + this.id || "LOCAL"));
    if (pad) id = id.padStart(10);

    try {
      return chalk`{green ${id}}: {blue ${this.name}}`;
    } catch (e) {
      return this.data;
    }
  }

}

defineAssoc(Rule, "name", "data.attributes.name");
defineAssoc(Rule, "description", "data.attributes.description");
defineAssoc(Rule, "id", "data.id");
defineAssoc(Rule, "relationships", "data.relationships");
defineAssoc(Rule, "isGeneric", "meta.isGeneric");
defineAssoc(Rule, "remote", "meta.remote");
defineAssoc(Rule, "idMap", "meta.idMap");
Rule.endpoint = "workflowRules";

class SupplyChain {
  constructor(startingRule, stopRule) {
    if (startingRule) {
      this.startingRule = startingRule;
      this.stopRule = stopRule;
      this.remote = startingRule.remote;
    }
  }

  async calculate() {
    write("Getting rules... ");
    this.allRules = await Rule.getAll(this.remote);
    log(this.allRules.length);
    write("Getting presets... ");
    this.allPresets = await Preset.getAll(this.remote);
    log(this.allPresets.length);
    write("Getting providers... ");
    this.allProviders = await Provider.getAll(this.remote);
    log(this.allProviders.length);
    write("Getting notifications... ");
    this.allNotifications = await Notification.getAll(this.remote);
    log(this.allNotifications.length);
    write("Downloading code... ");
    await Promise.all(this.allPresets.arr.map(obj => obj.downloadCode()));
    log("Done!"); //fs.writeFileSync("test.json", JSON.stringify(this, null, 4))
    //Now we have everything we need to find a whole supply chain

    write("Calculating Supply chain... ");
    log(this.startingRule.chalkPrint());
    let allRuleNames = this.allRules.arr.map(x => x.name).filter(x => x.length >= 4);
    let allPresetNames = this.allPresets.arr.map(x => x.name).filter(x => x.length >= 4);
    let allNotifNames = this.allNotifications.arr.map(x => x.name).filter(x => x.length >= 4);
    let requiredNotifications = new Set();
    let ruleQueue = [this.startingRule];
    let presetQueue = [];

    for (let currentRule of ruleQueue) {
      if (currentRule === this.stopRule) continue;
      let {
        eNext,
        pNext,
        preset,
        passNotif,
        errorNotif,
        enterNotif
      } = await currentRule.resolve();
      passNotif.forEach(n => requiredNotifications.add(n));
      enterNotif.forEach(n => requiredNotifications.add(n));
      errorNotif.forEach(n => requiredNotifications.add(n));
      if (eNext && !ruleQueue.includes(eNext)) ruleQueue.push(eNext);
      if (pNext && !ruleQueue.includes(eNext)) ruleQueue.push(pNext);
      let neededPresets = preset.findStringsInCode(allPresetNames);
      neededPresets = neededPresets.map(x => this.allPresets.findByName(x));
      let neededRules = preset.findStringsInCode(allRuleNames);
      neededRules = neededRules.map(x => this.allRules.findByName(x));
      preset.findStringsInCode(allNotifNames).map(str => this.allNotifications.findByName(str)).forEach(notif => requiredNotifications.add(notif));
      neededPresets.push(preset);

      for (let p of neededPresets) if (!presetQueue.includes(p)) presetQueue.push(p);

      for (let p of neededRules) if (!ruleQueue.includes(p)) ruleQueue.push(p);

      if (configObject.verbose) {
        write(currentRule.chalkPrint(false));
        log(":");
        write("  ");
        write(preset.chalkPrint(false));
        log(":");
        write("  Pass Next: ");
        if (pNext) write(pNext.chalkPrint(false));else write("None");
        log("");
        write("  Err  Next: ");
        if (eNext) write(eNext.chalkPrint(false));else write("None");
        log("");
        log("  Rules:");

        for (let p of neededRules) log("    " + p.chalkPrint(true));

        log("  Presets:");

        for (let p of neededPresets) log("    " + p.chalkPrint(true));

        log("\n");
      }
    }

    log("Done!");
    this.rules = new Collection(ruleQueue);
    this.presets = new Collection(presetQueue);
    requiredNotifications.delete(undefined);
    this.notifications = new Collection([...requiredNotifications]);
  }

  async log() {
    log("Required notifications: ");
    this.notifications.log();
    write("Required rules: ");
    log(this.rules.arr.length);
    this.rules.log();
    write("Required presets: ");
    log(this.presets.arr.length);
    this.presets.log();
  }

  async syncTo(env) {
    for (let preset of this.presets) {
      await preset.save(env);
    }

    if (this.rules.arr[0]) {
      log("Starting create phase for rules");

      for (let rule of this.rules) {
        await rule.saveA(env);
      }

      log("OK");
      log("Starting link phase for rules");
      Rule.removeCache(env);

      for (let rule of this.rules) {
        await rule.saveB(env);
      }
    }
  }

}

require("source-map-support").install();
const rallyFunctions = {
  async bestPagintation() {
    global.silentAPI = true;

    for (let i = 10; i <= 30; i += 5) {
      console.time("test with " + i);
      let dl = await lib.indexPathFast("DEV", `/workflowRules?page=1p${i}`);
      console.timeEnd("test with " + i);
    }
  },

  async uploadPresets(env, presets, createFunc = () => false) {
    for (let preset of presets) {
      await preset.uploadCodeToEnv(env, createFunc);
    }
  },

  //Dummy test access
  async testAccess(env) {
    if (lib.isLocalEnv(env)) {
      //TODO
      return true;
    }

    let result = await lib.makeAPIRequest({
      env,
      path: "/providers?page=1p1",
      fullResponse: true,
      timeout: 1000
    });
    return result.statusCode;
  }

};

var allIndexBundle = /*#__PURE__*/Object.freeze({
  rallyFunctions: rallyFunctions,
  SupplyChain: SupplyChain,
  Preset: Preset,
  Rule: Rule,
  Provider: Provider,
  Notification: Notification,
  get configFile () { return configFile; },
  loadConfig: loadConfig,
  setConfig: setConfig,
  get configObject () { return configObject; },
  lib: lib,
  AbortError: AbortError,
  APIError: APIError,
  UnconfiguredEnvError: UnconfiguredEnvError,
  ProtectedEnvError: ProtectedEnvError,
  Collection: Collection,
  RallyBase: RallyBase
});

var version = "1.8.3";

const inquirer = importLazy("inquirer");
const readdir = importLazy("recursive-readdir");
let hasAutoCompletePrompt = false;

function addAutoCompletePrompt() {
  if (hasAutoCompletePrompt) return;
  hasAutoCompletePrompt = true;
  inquirer.registerPrompt("autocomplete", require("inquirer-autocomplete-prompt"));
}

async function $api(propArray) {
  const defaults = {
    DEV: "https://discovery-dev.sdvi.com/api/v2",
    UAT: "https://discovery-uat.sdvi.com/api/v2",
    PROD: "https://discovery.sdvi.com/api/v2"
  };
  let q;

  if (propArray && propArray[1]) {
    q = {
      envs: [propArray[1]]
    };
  } else {
    //Create a checkbox prompt to choose enviornments
    q = await inquirer.prompt([{
      type: "checkbox",
      name: "envs",
      message: `What enviornments would you like to configure?`,
      choices: Object.keys(defaults).map(name => ({
        name,
        checked: true
      }))
    }]);
  } //Each env should ask 2 for two things: The url and the key.


  let questions = q.envs.map(env => {
    let defaultKey = process.env[`rally_api_key_${env}`];

    if (configObject && configObject.api && configObject.api[env]) {
      defaultKey = configObject.api[env].key;
    }

    return [{
      type: "input",
      name: `api.${env}.url`,
      message: `What is the url endpoint for ${env}`,
      default: defaults[env]
    }, {
      type: "input",
      name: `api.${env}.key`,
      message: `What is your api key for ${env}`,
      default: defaultKey
    }];
  }); //flatten and ask

  questions = [].concat(...questions);
  q = await inquirer.prompt(questions);

  if (propArray) {
    q.api = { ...configObject.api,
      ...q.api
    };
  }

  return q;
}
async function $chalk(propArray) {
  return {
    chalk: await askQuestion("Would you like chalk enabled (Adds coloring)?")
  };
}
async function $restrictUAT(propArray) {
  return {
    restrictUAT: await askQuestion("Would you like to protect UAT?")
  };
}
async function $repodir(propArray) {
  return await inquirer.prompt([{
    type: "input",
    name: `repodir`,
    message: `Where is your rally repository?`,
    default: process.env["rally_repo_path"]
  }]);
}
async function $defaultEnv(propArray) {
  return await inquirer.prompt([{
    type: "input",
    name: `defaultEnv`,
    message: `Default enviornment?`,
    default: "DEV"
  }]);
} //Internal usage/testing

async function selectProvider(providers, autoDefault = false) {
  let defaultProvider = providers.findByName("SdviEvaluate");

  if (autoDefault) {
    return defaultProvider;
  } else {
    let q = await inquirer.prompt([{
      type: "list",
      name: "provider",
      default: defaultProvider,
      choices: providers.arr.map(x => ({
        name: x.chalkPrint(true),
        value: x
      }))
    }]);
    return q.provider;
  }
}
async function selectLocal(path$$1, typeName, Class) {
  addAutoCompletePrompt();
  let basePath = path.join(configObject.repodir, path$$1);
  let f = await readdir(basePath);
  let objs = f.map(name => new Class({
    path: name
  }));
  let objsMap = objs.map(x => ({
    name: x.chalkPrint(true),
    value: x
  }));
  let none = {
    name: chalk`      {red None}: {red None}`,
    value: null
  };
  objsMap.unshift(none);
  let q = await inquirer.prompt([{
    type: "autocomplete",
    name: "obj",
    message: `What ${typeName} do you want?`,
    source: async (sofar, input) => {
      return objsMap.filter(x => input ? x.name.toLowerCase().includes(input.toLowerCase()) : true);
    }
  }]);
  return q.obj;
}
async function selectPreset(purpose = "preset") {
  return selectLocal("silo-presets", "preset", Preset);
}
async function selectRule(purpose = "rule") {
  return selectLocal("silo-rules", purpose, Rule);
}
async function askInput(name, question, def) {
  return (await inquirer.prompt([{
    type: "input",
    name: "ok",
    message: question,
    default: def
  }])).ok;
}
async function askQuestion(question) {
  return (await inquirer.prompt([{
    type: "confirm",
    name: "ok",
    message: question
  }])).ok;
}

var configHelpers = /*#__PURE__*/Object.freeze({
  $api: $api,
  $chalk: $chalk,
  $restrictUAT: $restrictUAT,
  $repodir: $repodir,
  $defaultEnv: $defaultEnv,
  selectProvider: selectProvider,
  selectLocal: selectLocal,
  selectPreset: selectPreset,
  selectRule: selectRule,
  askInput: askInput,
  askQuestion: askQuestion
});

var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _dec12, _dec13, _dec14, _dec15, _dec16, _dec17, _dec18, _dec19, _dec20, _dec21, _dec22, _dec23, _dec24, _dec25, _dec26, _dec27, _dec28, _dec29, _dec30, _dec31, _obj;

require("source-map-support").install();
let argv = argparse(process.argv.slice(2), {
  string: ["file", "env"],
  //boolean: ["no-protect"],
  default: {
    protect: true
  },
  alias: {
    f: "file",
    e: "env"
  }
}); //help menu helper

function printHelp(help, short) {
  let helpText$$1 = chalk`
{white ${help.name}}: ${help.text}
    Usage: ${help.usage || "<unknown>"}
`; //Trim newlines

  helpText$$1 = helpText$$1.substring(1, helpText$$1.length - 1);

  if (!short) {
    for (let param$$1 of help.params || []) {
      helpText$$1 += chalk`\n    {blue ${param$$1.param}}: ${param$$1.desc}`;
    }

    for (let arg$$1 of help.args || []) {
      helpText$$1 += chalk`\n    {blue ${arg$$1.short}}, {blue ${arg$$1.long}}: ${arg$$1.desc}`;
    }
  }

  return helpText$$1;
}

async function getFilesFromArgs(args) {
  let lastArg = args._.shift();

  if (args.file) {
    let files = args.file;
    if (typeof files === "string") files = [files];
    return files;
  }

  if (lastArg == "-") {
    log("Reading from stdin");

    let getStdin = require("get-stdin");

    let stdin = await getStdin();
    let files = stdin.split("\n");
    if (files[files.length - 1] === "") files.pop();
    return files;
  } else {
    args._.push(lastArg);
  }
}

let presetsub = {
  async before(args) {
    this.env = args.env;
    if (!this.env) throw new AbortError("No env supplied");
    this.files = await getFilesFromArgs(args);
  },

  async $grab(args) {
    if (!this.files) {
      throw new AbortError("No files provided to grab (use --file argument)");
    }

    log(chalk`Grabbing {green ${this.files.length}} preset(s) metadata from {green ${this.env}}.`);
    let presets = this.files.map(path$$1 => new Preset({
      path: path$$1,
      remote: false
    }));

    for (let preset of presets) {
      await preset.grabMetadata(this.env);
      await preset.saveLocalMetadata();
    }
  },

  async $create(args) {
    let provider, name$$1, ext;

    if (args.provider) {
      provider = args.provider;
      ext = args.ext;
    } else {
      provider = await selectProvider((await Provider.getAll(this.env)));
      ext = (await provider.getEditorConfig()).fileExt;
    }

    if (args.name) {
      name$$1 = args.name;
    } else {
      name$$1 = await askInput("Preset Name", "What is the preset name?");
    }

    let preset = new Preset();
    preset.providerType = {
      name: provider.name
    };
    preset.isGeneric = true;
    preset.name = name$$1;
    preset.ext = ext;

    if (provider.name === "SdviEvaluate") {
      preset._code = `'''\nname: ${name$$1}\n'''\n\n# code here\n`;
    } else {
      preset._code = "";
    }

    preset.saveLocalMetadata();
    preset.saveLocalFile();
  },

  async $list(args) {
    log("Loading...");
    let presets = await Preset.getAll(this.env);

    if (args.resolve) {
      for (let preset of presets) {
        let resolve = await preset.resolve(this.env);

        if (args.attach) {
          let {
            proType
          } = resolve;
          proType.editorConfig.helpText = "";
          preset.meta = { ...preset.meta,
            proType
          };
        }
      }
    }

    if (configObject.rawOutput) return presets;
    log(chalk`{yellow ${presets.length}} presets on {green ${this.env}}.`);

    for (let preset of presets) log(preset.chalkPrint());
  },

  async $upload(args) {
    if (!this.files) {
      throw new AbortError("No files provided to upload (use --file argument)");
    }

    log(chalk`Uploading {green ${this.files.length}} preset(s) to {green ${this.env}}.`);
    let presets = this.files.map(path$$1 => new Preset({
      path: path$$1,
      remote: false
    }));
    await rallyFunctions.uploadPresets(this.env, presets);
  },

  async $diff(args) {
    let file = this.files[0];

    if (!this.files) {
      throw new AbortError("No files provided to diff (use --file argument)");
    }

    let preset = new Preset({
      path: file,
      remote: false
    });

    if (!preset.name) {
      throw new AbortError(chalk`No preset header found. Cannot get name.`);
    }

    let preset2 = await Preset.getByName(this.env, preset.name);

    if (!preset2) {
      throw new AbortError(chalk`No preset found with name {red ${preset.name}} on {blue ${this.env}}`);
    }

    await preset2.downloadCode();

    let tempfile = require("tempy").file;

    let temp = tempfile({
      extension: preset.ext
    });
    fs.writeFileSync(temp, preset2.code);
    let ptr = `${file},${temp}`; //raw output returns "file1" "file2"

    if (configObject.rawOutput) return ptr; //standard diff

    argv.command = argv.command || "diff";
    await spawn(argv.command, [file, temp], {
      stdio: "inherit"
    });
  },

  async unknown(arg$$1, args) {
    log(chalk`Unknown action {red ${arg$$1}} try '{white rally help preset}'`);
  }

};
let rulesub = {
  async before(args) {
    this.env = args.env;
    if (!this.env) throw new AbortError("No env supplied");
  },

  async $list(args) {
    log("Loading...");
    let rules = await Rule.getRules(this.env);
    if (configObject.rawOutput) return rules;
    log(chalk`{yellow ${rules.length}} rules on {green ${this.env}}.`);

    for (let rule of rules) log(rule.chalkPrint());
  },

  async $create(args) {
    let preset = await selectPreset();
    let passNext = await selectRule("'On Exit OK'");
    let errorNext = await selectRule("'On Exit Error'");
    let name$$1 = await askInput("Rule Name", "What is the rule name?");
    let desc = await askInput("Description", "Enter a description.");
    let dynamicNexts = [];
    let next;

    while (next = await selectRule("dynamic next")) {
      let name$$1 = await askInput("Key", "Key name for dynamic next");
      dynamicNexts.push({
        meta: {
          transition: name$$1
        },
        type: "workflowRules",
        name: next.name
      });
    }

    let rule = new Rule();
    rule.name = name$$1;
    rule.description = desc;
    rule.relationships.preset = {
      data: {
        name: preset.name,
        type: "presets"
      }
    };
    if (errorNext) rule.relationships.errorNext = {
      data: {
        name: errorNext.name,
        type: "workflowRules"
      }
    };
    if (passNext) rule.relationships.passNext = {
      data: {
        name: passNext.name,
        type: "workflowRules"
      }
    };

    if (dynamicNexts[0]) {
      rule.relationships.dynamicNexts = {
        data: dynamicNexts
      };
    }

    rule.saveB();
  },

  async unknown(arg$$1, args) {
    log(chalk`Unknown action {red ${arg$$1}} try '{white rally help rule}'`);
  }

};
let jupytersub = {
  async before(args) {
    this.input = args._.shift() || "main.ipynb";
    this.output = args._.shift() || "main.py";
  },

  async $build(args) {
    let cmd = `jupyter nbconvert --to python ${this.input} --TagRemovePreprocessor.remove_cell_tags={\"remove_cell\"} --output ${this.output} --TemplateExporter.exclude_markdown=True --TemplateExporter.exclude_input_prompt=True --TemplateExporter.exclude_output_prompt=True`.split(" ");
    log(chalk`Compiling GCR file {green ${this.input}} into {green ${this.output}} using jupyter...`);

    try {
      let {
        timestr
      } = await spawn(cmd[0], cmd.slice(1));
      log(chalk`Complete in ~{green.bold ${timestr}}.`);
    } catch (e) {
      if (e.code !== "ENOENT") throw e;
      log(chalk`Cannot run the build command. Make sure that you have jupyter notebook installed.\n{green pip install jupyter}`);
      return;
    }
  }

};

async function categorizeString(str) {
  str = str.trim();
  let match;

  if (match = /^(\w)-(\w{1,10})-(\d{1,10}):/.exec(str)) {
    if (match[1] === "P") {
      return await Preset.getById(match[2], match[3]);
    } else if (match[1] === "R") {
      return await Rule.getById(match[2], match[3]);
    } else {
      return null;
    }
  } else if (match = /silo\-(\w+)\//.exec(str)) {
    switch (match[1]) {
      case "presets":
        return new Preset({
          path: str
        });

      case "rules":
        return new Rule({
          path: str
        });

      case "metadata":
        return await Preset.fromMetadata(str);
    }
  } else {
    return null;
  }
}

let supplysub = {
  async before(args) {
    this.env = args.env;
    if (!this.env) throw new AbortError("No env supplied");
    this.files = await getFilesFromArgs(args);
  },

  //Calculate a supply chain based on a starting rule at the top of the stack
  async $calc(args) {
    let name$$1 = args._.shift();

    let stopName = args._.shift();

    if (!name$$1) {
      throw new AbortError("No starting rule supplied");
    }

    let rules = await Rule.getRules(this.env);
    let start = rules.findByNameContains(name$$1);
    let stop;
    if (stopName) stop = rules.findByNameContains(stopName);

    if (!start) {
      throw new AbortError(chalk`No starting rule found by name {blue ${name$$1}}`);
    }

    log(chalk`Analzying supply chain: ${start.chalkPrint(false)} - ${stop ? stop.chalkPrint(false) : "(open)"}`);
    this.chain = new SupplyChain(start, stop);
    await this.chain.calculate();
    await this.postAction(args);
  },

  async postAction(args) {
    //Now that we ahve a supply chain object, do something with it
    if (args["to"]) {
      this.chain.log();

      if (this.chain.presets.arr[0]) {
        log("Loading code");
        await Promise.all(this.chain.presets.arr.map(obj => obj.downloadCode()));
        log("Done");
      }

      await this.chain.syncTo(args["to"]);
    } else if (args["diff"]) {
      //Very basic diff
      let env = args["diff"];
      await Promise.all(this.chain.presets.arr.map(obj => obj.downloadCode()));
      await Promise.all(this.chain.presets.arr.map(obj => obj.resolve()));
      let otherPresets = await Promise.all(this.chain.presets.arr.map(obj => Preset.getByName(env, obj.name)));
      otherPresets = new Collection(otherPresets.filter(x => x));
      await Promise.all(otherPresets.arr.map(obj => obj.downloadCode()));
      await Promise.all(otherPresets.arr.map(obj => obj.resolve()));

      for (let preset of this.chain.presets) {
        let otherPreset = otherPresets.arr.find(x => x.name === preset.name);
        log(preset.chalkPrint(true));

        if (otherPreset) {
          log(otherPreset.chalkPrint(true));
        } else {
          otherPreset = {};
          log(chalk`{red (None)}`);
        }

        if (preset.code === otherPreset.code) {
          log("Code Same");
        } else {
          log("Code Different");
        }
      }
    } else {
      await this.chain.log();
    }
  },

  async $make(args) {
    let set = new Set();

    for (let file of this.files) {
      set.add((await categorizeString(file)));
    }

    let files = [...set];
    files = files.filter(f => f);
    this.chain = new SupplyChain();
    this.chain.rules = new Collection(files.filter(f => f instanceof Rule));
    this.chain.presets = new Collection(files.filter(f => f instanceof Preset));
    this.chain.notifications = new Collection([]);
    await this.postAction(args);
  },

  async unknown(arg$$1, args) {
    log(chalk`Unknown action {red ${arg$$1}} try '{white rally help supply}'`);
  }

};

function subCommand(object) {
  object = {
    before() {},

    after() {},

    unknown() {},

    ...object
  };
  return async function (args) {
    //Grab the next arg on the stack, find a function tied to it, and run
    let arg$$1 = args._.shift();

    let key = "$" + arg$$1;
    let ret;

    if (object[key]) {
      await object.before(args);
      ret = await object[key](args);
      await object.after(args);
    } else {
      if (arg$$1 === undefined) arg$$1 = "(None)";
      object.unknown(arg$$1, args);
    }

    return ret;
  };
}

let cli = (_dec = helpText(`Display the help menu`), _dec2 = usage(`rally help [subhelp]`), _dec3 = param("subhelp", "The name of the command to see help for"), _dec4 = helpText("Rally tools jupyter interface. Requires jupyter to be installed."), _dec5 = usage("rally jupyter build [in] [out]"), _dec6 = param("in/out", "input and output file for jupyter. By default main.ipyrb and main.py"), _dec7 = helpText(`Preset related actions`), _dec8 = usage(`rally preset [action] --env <enviornment> --file [file1] --file [file2] ...`), _dec9 = param("action", "The action to perform. Can be upload, diff, list"), _dec10 = arg("-e", "--env", "The enviornment you wish to perform the action on"), _dec11 = arg("-f", "--file", "A file to act on"), _dec12 = arg("~", "--command", "If the action is diff, this is the command to run instead of diff"), _dec13 = helpText(`Rule related actions`), _dec14 = usage(`rally rule [action] --env [enviornment]`), _dec15 = param("action", "The action to perform. Only list is supported right now"), _dec16 = arg("-e", "--env", "The enviornment you wish to perform the action on"), _dec17 = helpText(`supply chain related actions`), _dec18 = usage(`rally supply [action] [identifier] --env [enviornment]`), _dec19 = param("action", "The action to perform. Can be calc."), _dec20 = param("identifier", "If the action is calc, then this identifier should be the first rule in the chain."), _dec21 = arg("-e", "--env", "The enviornment you wish to perform the action on"), _dec22 = helpText(`List all available providers, or find one by name/id`), _dec23 = usage(`rally providers [identifier] --env [env] --raw`), _dec24 = param("identifier", "Either the name or id of the provider"), _dec25 = arg("-e", "--env", "The enviornment you wish to perform the action on"), _dec26 = arg("~", "--raw", "Raw output of command. If [identifier] is given, then print editorConfig too"), _dec27 = helpText(`Change config for rally tools`), _dec28 = usage("rally config [key] --set [value] --raw"), _dec29 = param("key", chalk`Key you want to edit. For example, {green chalk} or {green api.DEV}`), _dec30 = arg("~", "--set", "If this value is given, no interactive prompt will launch and the config option will change."), _dec31 = arg("~", "--raw", "Raw output of json config"), (_obj = {
  async help(args) {
    let arg$$1 = args._.shift();

    if (arg$$1) {
      let help = helpEntries[arg$$1];

      if (!help) {
        log(chalk`No help found for '{red ${arg$$1}}'`);
      } else {
        log(printHelp(helpEntries[arg$$1]));
      }
    } else {
      for (let helpArg in helpEntries) {
        log(printHelp(helpEntries[helpArg], true));
      }
    }
  },

  async jupyter(args) {
    return subCommand(jupytersub)(args);
  },

  //@helpText(`Print input args, for debugging`)
  async printArgs(args) {
    log(args);
  },

  async preset(args) {
    return subCommand(presetsub)(args);
  },

  async rule(args) {
    return subCommand(rulesub)(args);
  },

  async supply(args) {
    return subCommand(supplysub)(args);
  },

  async providers(args) {
    let env = args.env;
    if (!env) return errorLog("No env supplied.");

    let ident = args._.shift();

    let providers = await Provider.getAll(env);

    if (ident) {
      let pro = providers.arr.find(x => x.id == ident || x.name.includes(ident));

      if (!pro) {
        log(chalk`Couldn't find provider by {green ${ident}}`);
      } else {
        log(pro.chalkPrint(false));
        let econfig = await pro.getEditorConfig();

        if (args.raw) {
          return pro;
        } else {
          if (econfig.helpText.length > 100) {
            econfig.helpText = "<too long to display>";
          }

          if (econfig.completions.length > 5) {
            econfig.completions = "<too long to display>";
          }

          log(econfig);
        }
      }
    } else {
      if (args.raw) return providers;

      for (let pro of providers) log(pro.chalkPrint());
    }
  },

  async config(args) {
    let prop = args._.shift();

    let propArray = prop && prop.split("."); //if(!await configHelpers.askQuestion(`Would you like to create a new config file in ${configFile}`)) return;

    let newConfigObject;

    if (!prop) {
      if (configObject.rawOutput) return configObject;
      log("Creating new config");
      newConfigObject = { ...configObject
      };

      for (let helperName in configHelpers) {
        if (helperName.startsWith("$")) {
          newConfigObject = { ...newConfigObject,
            ...(await configHelpers[helperName](false))
          };
        }
      }
    } else {
      log(chalk`Editing option {green ${prop}}`);

      if (args.set) {
        newConfigObject = { ...configObject,
          [prop]: args.set
        };
      } else {
        let ident = "$" + propArray[0];

        if (configHelpers[ident]) {
          newConfigObject = { ...configObject,
            ...(await configHelpers[ident](propArray))
          };
        } else {
          log(chalk`No helper for {red ${ident}}`);
          return;
        }
      }
    }

    newConfigObject.hasConfig = true; //Create readable json and make sure the user is ok with it

    let newConfig = JSON.stringify(newConfigObject, null, 4);
    log(newConfig); //-y or --set will make this not prompt

    if (!args.y && !args.set && !(await askQuestion("Write this config to disk?"))) return;
    fs.writeFileSync(configFile, newConfig, {
      mode: 0o600
    });
    log(chalk`Created file {green ${configFile}}.`);
  },

  async test(args) {
    await Provider.getAll("DEV"); //allIndexBundle.lib.indexPathFast({
    //env: "DEV", path: "/presets",
    //})
  },

  //Used to test startup and teardown speed.
  noop() {
    return true;
  }

}, (_applyDecoratedDescriptor(_obj, "help", [_dec, _dec2, _dec3], Object.getOwnPropertyDescriptor(_obj, "help"), _obj), _applyDecoratedDescriptor(_obj, "jupyter", [_dec4, _dec5, _dec6], Object.getOwnPropertyDescriptor(_obj, "jupyter"), _obj), _applyDecoratedDescriptor(_obj, "preset", [_dec7, _dec8, _dec9, _dec10, _dec11, _dec12], Object.getOwnPropertyDescriptor(_obj, "preset"), _obj), _applyDecoratedDescriptor(_obj, "rule", [_dec13, _dec14, _dec15, _dec16], Object.getOwnPropertyDescriptor(_obj, "rule"), _obj), _applyDecoratedDescriptor(_obj, "supply", [_dec17, _dec18, _dec19, _dec20, _dec21], Object.getOwnPropertyDescriptor(_obj, "supply"), _obj), _applyDecoratedDescriptor(_obj, "providers", [_dec22, _dec23, _dec24, _dec25, _dec26], Object.getOwnPropertyDescriptor(_obj, "providers"), _obj), _applyDecoratedDescriptor(_obj, "config", [_dec27, _dec28, _dec29, _dec30, _dec31], Object.getOwnPropertyDescriptor(_obj, "config"), _obj)), _obj));

async function unknownCommand(cmd) {
  log(chalk`Unknown command {red ${cmd}}.`);
}

async function noCommand() {
  write(chalk`
Rally Tools {yellow v${version} (alpha)} CLI
by John Schmidt <John_Schmidt@discovery.com>
`); //Prompt users to setup one time config.

  if (!configObject.hasConfig) {
    write(chalk`
It looks like you haven't setup the config yet. Please run '{green rally config}'.
`);
    return;
  } //API Access tests


  for (let env of ["UAT", "DEV", "PROD", "LOCAL"]) {
    //Test access. Returns HTTP response code
    let resultStr;

    try {
      let result = await rallyFunctions.testAccess(env); //Create a colored display and response

      resultStr = chalk`{yellow ${result} <unknown>}`;
      if (result === 200) resultStr = chalk`{green 200 OK}`;else if (result === 401) resultStr = chalk`{red 401 No Access}`;else if (result >= 500) resultStr = chalk`{yellow ${result} API Down?}`;else if (result === true) resultStr = chalk`{green OK}`;else if (result === false) resultStr = chalk`{red BAD}`;
    } catch (e) {
      if (e instanceof UnconfiguredEnvError) {
        resultStr = chalk`{yellow Unconfigured}`;
      } else if (e instanceof APIError) {
        if (!e.response.body) {
          resultStr = chalk`{red Timeout (?)}`;
        }
      } else {
        throw e;
      }
    }

    log(chalk`   ${env}: ${resultStr}`);
  }
}

async function $main() {
  //Supply --config to load a different config file
  if (argv.config) loadConfig(argv.config); // First we need to decide if the user wants color or not. If they do want
  // color, we need to make sure we use the right mode

  chalk.enabled = configObject.hasConfig ? configObject.chalk : true;

  if (chalk.level === 0 || !chalk.enabled) {
    let force = argv["force-color"];

    if (force) {
      chalk.enabled = true;

      if (force === true && chalk.level === 0) {
        chalk.level = 1;
      } else if (Number(force)) {
        chalk.level = Number(force);
      }
    }
  } //This flag being true allows you to modify UAT and PROD


  if (!argv["protect"]) {
    configObject.dangerModify = true;
  } //This enables raw output for some functions


  if (argv["raw"]) {
    configObject.rawOutput = true;

    global.log = () => {};

    global.errorLog = () => {};

    global.write = () => {};
  } //Default enviornment should normally be from config, but it can be
  //overridden by the -e/--env flag


  if (configObject.defaultEnv) {
    argv.env = argv.env || configObject.defaultEnv;
  } //Enable verbose logging in some places.


  if (argv["vverbose"]) {
    configObject.verbose = argv["vverbose"];
    configObject.vverbose = true;
  } else if (argv["verbose"]) {
    configObject.verbose = argv["verbose"];
  } //copy argument array to new object to allow modification


  argv._old = argv._.slice(); //Take first argument after `node bundle.js`
  //If there is no argument, display the default version info and API access.

  let func = argv._.shift();

  if (func) {
    if (!cli[func]) return await unknownCommand(func);

    try {
      //Call the cli function
      let ret = await cli[func](argv);

      if (ret) {
        write(chalk.white("CLI returned: "));
        if (ret instanceof Collection) ret = ret.arr; //Directly use console.log so that --raw works as intended.

        if (typeof ret === "object") {
          console.log(JSON.stringify(ret, null, 4));
        } else {
          console.log(ret);
        }
      }
    } catch (e) {
      if (e instanceof AbortError) {
        log(chalk`{red CLI Aborted}: ${e.message}`);
      } else {
        throw e;
      }
    }
  } else {
    await noCommand();
  }
}

async function main$1(...args) {
  //Catch all for errors to avoid ugly default node promise catcher
  try {
    await $main(...args);
  } catch (e) {
    errorLog(e.stack);
  }
} // If this is an imported module, then we should exec the cli interface.
// Oterwise just export everything.


if (require.main === module) {
  main$1();
} else {
  module.exports = allIndexBundle;
}
//# sourceMappingURL=bundle.js.map

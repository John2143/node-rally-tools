#!/usr/bin/env node
/*----------------------------------------------
 * Generated by rollup. Written by John Schmidt.
 * Rally Tools CLI v2.5.0
 *--------------------------------------------*/
const importLazy = require("import-lazy")(require);

'use strict';

var argparse = require('minimist');
var chalk$1 = require('chalk');
var os = require('os');
var fs = require('fs');
var child_process = require('child_process');
var perf_hooks = require('perf_hooks');
var rp = require('request-promise');
var path = require('path');
var moment = require('moment');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var argparse__default = /*#__PURE__*/_interopDefaultLegacy(argparse);
var chalk__default = /*#__PURE__*/_interopDefaultLegacy(chalk$1);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var rp__default = /*#__PURE__*/_interopDefaultLegacy(rp);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var moment__default = /*#__PURE__*/_interopDefaultLegacy(moment);

function _asyncIterator(iterable) {
  var method;

  if (typeof Symbol === "function") {
    if (Symbol.asyncIterator) {
      method = iterable[Symbol.asyncIterator];
      if (method != null) return method.call(iterable);
    }

    if (Symbol.iterator) {
      method = iterable[Symbol.iterator];
      if (method != null) return method.call(iterable);
    }
  }

  throw new TypeError("Object is not async iterable");
}

function _AwaitValue(value) {
  this.wrapped = value;
}

function _AsyncGenerator(gen) {
  var front, back;

  function send(key, arg) {
    return new Promise(function (resolve, reject) {
      var request = {
        key: key,
        arg: arg,
        resolve: resolve,
        reject: reject,
        next: null
      };

      if (back) {
        back = back.next = request;
      } else {
        front = back = request;
        resume(key, arg);
      }
    });
  }

  function resume(key, arg) {
    try {
      var result = gen[key](arg);
      var value = result.value;
      var wrappedAwait = value instanceof _AwaitValue;
      Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {
        if (wrappedAwait) {
          resume("next", arg);
          return;
        }

        settle(result.done ? "return" : "normal", arg);
      }, function (err) {
        resume("throw", err);
      });
    } catch (err) {
      settle("throw", err);
    }
  }

  function settle(type, value) {
    switch (type) {
      case "return":
        front.resolve({
          value: value,
          done: true
        });
        break;

      case "throw":
        front.reject(value);
        break;

      default:
        front.resolve({
          value: value,
          done: false
        });
        break;
    }

    front = front.next;

    if (front) {
      resume(front.key, front.arg);
    } else {
      back = null;
    }
  }

  this._invoke = send;

  if (typeof gen.return !== "function") {
    this.return = undefined;
  }
}

if (typeof Symbol === "function" && Symbol.asyncIterator) {
  _AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
    return this;
  };
}

_AsyncGenerator.prototype.next = function (arg) {
  return this._invoke("next", arg);
};

_AsyncGenerator.prototype.throw = function (arg) {
  return this._invoke("throw", arg);
};

_AsyncGenerator.prototype.return = function (arg) {
  return this._invoke("return", arg);
};

function _wrapAsyncGenerator(fn) {
  return function () {
    return new _AsyncGenerator(fn.apply(this, arguments));
  };
}

function _awaitAsyncGenerator(value) {
  return new _AwaitValue(value);
}

function _asyncGeneratorDelegate(inner, awaitWrap) {
  var iter = {},
      waiting = false;

  function pump(key, value) {
    waiting = true;
    value = new Promise(function (resolve) {
      resolve(inner[key](value));
    });
    return {
      done: false,
      value: awaitWrap(value)
    };
  }

  if (typeof Symbol === "function" && Symbol.iterator) {
    iter[Symbol.iterator] = function () {
      return this;
    };
  }

  iter.next = function (value) {
    if (waiting) {
      waiting = false;
      return value;
    }

    return pump("next", value);
  };

  if (typeof inner.throw === "function") {
    iter.throw = function (value) {
      if (waiting) {
        waiting = false;
        throw value;
      }

      return pump("throw", value);
    };
  }

  if (typeof inner.return === "function") {
    iter.return = function (value) {
      return pump("return", value);
    };
  }

  return iter;
}

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

let configFile = null;

if (os.homedir) {
  configFile = os.homedir() + "/.rallyconfig";
}

let configObject;
function loadConfig(file) {
  if (file) configFile = file;
  if (!configFile) return;
  configObject = {
    hasConfig: true
  };

  try {
    let json = fs.readFileSync(configFile);
    configObject = JSON.parse(json);
    configObject.hasConfig = true;
  } catch (e) {
    if (e.code == "ENOENT") {
      configObject.hasConfig = false; //ok, they should probably make a config
    } else {
      throw e;
    }
  }
}
function loadConfigFromArgs(args) {
  let tempConfig = {
    hasConfig: true,
    ...args.config
  };
  configObject = tempConfig;
}
function setConfig(obj) {
  configObject = obj;
}

//these are the help entries for each command
let helpEntries = {};

let helpEntry = name => helpEntries[name] ? helpEntries[name] : helpEntries[name] = {
  name
}; //short description


function helpText(text) {
  return function (func, name) {
    helpEntry(name).text = text;
    return func;
  };
} //flag type argument like -f or --file

function arg(long, short, desc) {
  return function (func, name) {
    let args = helpEntry(name).args = helpEntry(name).args || [];
    args.unshift({
      long,
      short,
      desc
    });
    return func;
  };
} //normal argument

function param(param, desc) {
  return function (func, name) {
    let params = helpEntry(name).params = helpEntry(name).params || [];
    params.unshift({
      param,
      desc
    });
    return func;
  };
} //usage string

function usage(usage) {
  return function (func, name) {
    usage = usage.replace(/[\[<](\w+)[\]>]/g, chalk`[{blue $1}]`);
    helpEntry(name).usage = usage;
    return func;
  };
}
//function retuns obj.a.b.c

function deepAccess(obj, path) {
  let o = obj;

  for (let key of path) {
    if (!o) return [];
    o = o[key];
  }

  return o;
} //This takes a class as the first argument, then adds a getter/setter pair that
//corresponds to an object in this.data


function defineAssoc(classname, shortname, path) {
  path = path.split(".");
  let lastKey = path.pop();
  Object.defineProperty(classname.prototype, shortname, {
    get() {
      return deepAccess(this, path)[lastKey];
    },

    set(val) {
      deepAccess(this, path)[lastKey] = val;
    }

  });
}

function spawn(options, ...args) {
  if (typeof options !== "object") {
    args.unshift(options);
    options = {};
  } //todo options


  return new Promise((resolve, reject) => {
    let start = perf_hooks.performance.now();
    let stdout = "";
    let stderr = "";
    let cp = child_process.spawn(...args);
    let write = global.write;

    if (options.noecho) {
      write = () => {};
    }

    if (cp.stdout) cp.stdout.on("data", chunk => {
      stdout += chunk;
      write(chunk);
    });
    if (cp.stderr) cp.stderr.on("data", chunk => {
      stderr += chunk;
      write(chunk);
    });
    cp.on("error", reject);
    cp.on("close", code => {
      let end = perf_hooks.performance.now();
      let time = end - start;
      let timestr = time > 1000 ? (time / 100 | 0) / 10 + "s" : (time | 0) + "ms";
      resolve({
        stdout,
        stderr,
        exitCode: code,
        time,
        timestr
      });
    });
  });
}

global.chalk = chalk__default['default'];

global.log = (...text) => console.log(...text);

global.write = (...text) => process.stdout.write(...text);

global.elog = (...text) => console.error(...text);

global.ewrite = (...text) => process.stderr.write(...text);

global.errorLog = (...text) => log(...text.map(chalk__default['default'].red));

class lib {
  //This function takes 2 required arguemnts:
  // env: the enviornment you wish to use
  // and either:
  //  'path', the short path to the resource. ex '/presets/'
  //  'path_full', the full path to the resource like 'https://discovery-dev.sdvi.com/presets'
  //
  // If the method is anything but GET, either payload or body should be set.
  // payload should be a javascript object to be turned into json as the request body
  // body should be a string that is passed as the body. for example: the python code of a preset.
  //
  // qs are the querystring parameters, in a key: value object.
  // {filter: "name=test name"} becomes something like 'filter=name=test+name'
  //
  // headers are the headers of the request. "Content-Type" is already set if
  //   payload is given as a parameter
  //
  // fullResponse should be true if you want to receive the request object,
  //  not just the returned data.
  static async makeAPIRequest({
    env,
    path,
    path_full,
    fullPath,
    payload,
    body,
    method = "GET",
    qs,
    headers = {},
    fullResponse = false,
    timeout = configObject.timeout || 20000
  }) {
    var _configObject$api;

    //backwards compatability from ruby script
    if (fullPath) path_full = fullPath; //Keys are defined in enviornment variables

    let config = configObject === null || configObject === void 0 ? void 0 : (_configObject$api = configObject.api) === null || _configObject$api === void 0 ? void 0 : _configObject$api[env];

    if (!config) {
      throw new UnconfiguredEnvError(env);
    }

    if (method !== "GET" && !configObject.dangerModify) {
      if (env === "UAT" && configObject.restrictUAT || env === "PROD") {
        throw new ProtectedEnvError(env);
      }
    }

    let rally_api_key = config.key;
    let rally_api = config.url;

    if (path && path.startsWith("/v1.0/")) {
      rally_api = rally_api.replace("/api/v2", "/api");
    }

    path = path_full || rally_api + path;

    if (payload) {
      body = JSON.stringify(payload, null, 4);
    }

    if (payload) {
      headers["Content-Type"] = "application/vnd.api+json";
    }

    let fullHeaders = {
      //SDVI ignores this header sometimes.
      Accept: "application/vnd.api+json",
      "X-SDVI-Client-Application": "Discovery-rtlib-" + (configObject.appName || "commandline"),
      ...headers
    };

    if (configObject.vvverbose) {
      log(`${method} @ ${path}`);
      log(JSON.stringify(fullHeaders, null, 4));

      if (body) {
        log(body);
      } else {
        log("(No body");
      }
    }

    let requestOptions = {
      method,
      body,
      qs,
      uri: path,
      timeout,
      auth: {
        bearer: rally_api_key
      },
      headers: fullHeaders,
      simple: false,
      resolveWithFullResponse: true
    };
    let response;

    try {
      response = await rp__default['default'](requestOptions);

      if (configObject.vverbose || configObject.vvverbose) {
        log(chalk__default['default']`${method} @ ${response.request.uri.href}`);
      }
    } catch (e) {
      if ((e === null || e === void 0 ? void 0 : e.cause.code) === "ESOCKETTIMEDOUT") {
        throw new APIError(response || {}, requestOptions, body);
      } else {
        throw e;
      }
    } //Throw an error for any 5xx or 4xx


    if (!fullResponse && ![200, 201, 202, 203, 204].includes(response.statusCode)) {
      throw new APIError(response, requestOptions, body);
    }

    let contentType = response.headers["content-type"];
    let isJSONResponse = contentType === "application/vnd.api+json" || contentType === "application/json";

    if (configObject.vvverbose) {
      log(response.body);
    }

    if (fullResponse) {
      return response;
    } else if (isJSONResponse) {
      var _response, _response$body;

      if ([200, 201, 202, 203, 204].includes(response.statusCode) && !((_response = response) === null || _response === void 0 ? void 0 : (_response$body = _response.body) === null || _response$body === void 0 ? void 0 : _response$body.trim())) return {};

      try {
        return JSON.parse(response.body);
      } catch (e) {
        log(response.body);
        throw new AbortError("Body is not valid json: ");
      }
    } else {
      return response.body;
    }
  } //Index a json endpoint that returns a {links} field.
  //This function returns the merged data objects as an array
  //
  //Additonal options (besides makeAPIRequest options):
  // - Observe: function to be called for each set of data from the api


  static async indexPath(env, path) {
    let all = [];
    let opts = typeof env === "string" ? {
      env,
      path
    } : env;
    let json = await this.makeAPIRequest(opts);
    let [numPages, pageSize] = this.numPages(json.links.last); //log(`num pages: ${numPages} * ${pageSize}`);

    all = [...json.data];

    while (json.links.next) {
      json = await this.makeAPIRequest({ ...opts,
        path_full: json.links.next
      });
      if (opts.observe) await opts.observe(json.data);
      all = [...all, ...json.data];
    }

    return all;
  } //Returns number of pages and pagination size


  static numPages(str) {
    return /page=(\d+)p(\d+)/.exec(str).slice(1);
  }

  static arrayChunk(array, chunkSize) {
    let newArr = [];

    for (let i = 0; i < array.length; i += chunkSize) {
      newArr.push(array.slice(i, i + chunkSize));
    }

    return newArr;
  }

  static async doPromises(promises, result = [], cb) {
    for (let promise of promises) {
      let res = await promise;
      result.push(res);

      if (cb) {
        cb(res.data);
      }
    }

    return result;
  }

  static clearProgress(size = 30) {
    if (!configObject.globalProgress) return;
    process.stderr.write(`\r${" ".repeat(size + 15)}\r`);
  }

  static async drawProgress(i, max, size = process.stdout.columns - 15 || 15) {
    if (!configObject.globalProgress) return;
    if (size > 45) size = 45;
    let pct = Number(i) / Number(max); //clamp between 0 and 1

    pct = pct < 0 ? 0 : pct > 1 ? 1 : pct;
    let numFilled = Math.floor(pct * size);
    let numEmpty = size - numFilled;
    this.clearProgress(size);
    process.stderr.write(`[${"*".repeat(numFilled)}${" ".repeat(numEmpty)}] ${i} / ${max}`);
  }

  static async keepalive(func, inputData, {
    chunksize = 20,
    observe = async _ => _,
    progress = configObject.globalProgress
  } = {}) {
    let total = inputData ? inputData.length : func.length;
    let i = 0;

    let createPromise = () => {
      let ret;
      if (i >= total) return [];

      if (inputData) {
        ret = [i, func(inputData[i])];
      } else {
        ret = [i, func[i]()];
      }

      i++;
      return ret;
    };

    let values = [];
    let finished = 0;
    if (progress) process.stderr.write("\n");
    let threads = [...this.range(chunksize)].map(async whichThread => {
      while (true) {
        let [i, currentPromise] = createPromise();
        if (i == undefined) break;
        values[i] = await observe((await currentPromise));
        if (progress) this.drawProgress(++finished, total);
      }
    });
    await Promise.all(threads);
    if (progress) process.stderr.write("\n");
    return values;
  }

  static *range(start, end) {
    if (end === undefined) {
      end = start;
      start = 0;
    }

    while (start < end) yield start++;
  } //Index a json endpoint that returns a {links} field.
  //
  //This function is faster than indexPath because it can guess the pages it
  //needs to retreive so that it can request all assets at once.
  //
  //This function assumes that the content from the inital request is the
  //first page, so starting on another page may cause issues. Consider
  //indexPath for that.
  //
  //Additional opts, besides default indexPath opts:
  // - chunksize[10]: How often to break apart concurrent requests


  static async indexPathFast(env, path) {
    let opts = typeof env === "string" ? {
      env,
      path
    } : env; //Create a copy of the options in case we need to have a special first request

    let start = opts.start || 1;
    let initOpts = { ...opts
    };

    if (opts.pageSize) {
      initOpts.qs = { ...opts.qs
      };
      initOpts.qs.page = `${start}p${opts.pageSize}`;
    }

    let json = await this.makeAPIRequest(initOpts);
    if (opts.observe && opts.start !== 1) json = await opts.observe(json);
    let baselink = json.links.first;

    const linkToPage = page => baselink.replace(`page=1p`, `page=${page}p`);

    let [numPages, pageSize] = this.numPages(json.links.last); //Construct an array of all the requests that are done simultanously.
    //Assume that the content from the inital request is the first page.

    let allResults = await this.keepalive(this.makeAPIRequest, [...this.range(start + 1, Number(numPages) + 1 || opts.limit + 1)].map(i => ({ ...opts,
      path_full: linkToPage(i)
    })), {
      chunksize: opts.chunksize,
      observe: opts.observe
    });

    if (start == 1) {
      allResults.unshift(json);
    }

    this.clearProgress();
    let all = [];

    for (let result of allResults) {
      for (let item of result.data) {
        all.push(item);
      }
    }

    return all;
  }

  static isLocalEnv(env) {
    return !env || env === "LOCAL" || env === "LOC";
  }

  static envName(env) {
    if (this.isLocalEnv(env)) return "LOCAL";
    return env;
  }

}
class AbortError extends Error {
  constructor(message) {
    super(message);
    Error.captureStackTrace(this, this.constructor);
    this.name = "AbortError";
  }

}
class APIError extends Error {
  constructor(response, opts, body) {
    super(chalk__default['default']`
{reset Request returned} {yellow ${response === null || response === void 0 ? void 0 : response.statusCode}}{
{green ${JSON.stringify(opts, null, 4)}}
{green ${body}}
{reset ${response.body}}
===============================
{red ${response.body ? "Request timed out" : "Bad response from API"}}
===============================
        `);
    this.response = response;
    this.opts = opts;
    this.body = body;
    Error.captureStackTrace(this, this.constructor);
    this.name = "ApiError";
  }

}
class UnconfiguredEnvError extends AbortError {
  constructor(env) {
    super("Unconfigured enviornment: " + env);
    this.name = "Unconfigured Env Error";
  }

}
class ProtectedEnvError extends AbortError {
  constructor(env) {
    super("Protected enviornment: " + env);
    this.name = "Protected Env Error";
  }

}
class FileTooLargeError extends Error {
  constructor(file) {
    super(`File ${file.parentAsset ? file.parentAsset.name : "(unknown)"}/${file.name} size is: ${file.sizeGB}g (> ~.2G)`);
    this.name = "File too large error";
  }

}
class Collection {
  constructor(arr) {
    this.arr = arr;
  }

  [Symbol.iterator]() {
    return this.arr[Symbol.iterator]();
  }

  findById(id) {
    return this.arr.find(x => x.id == id);
  }

  findByName(name) {
    return this.arr.find(x => x.name == name);
  }

  findByNameContains(name) {
    return this.arr.find(x => x.name.includes(name));
  }

  log() {
    for (let d of this) {
      if (d) {
        log(d.chalkPrint(true));
      } else {
        log(chalk__default['default']`{red (None)}`);
      }
    }
  }

  get length() {
    return this.arr.length;
  }

}
class RallyBase {
  static handleCaching() {
    if (!this.cache) this.cache = [];
  }

  static isLoaded(env) {
    if (!this.hasLoadedAll) return;
    return this.hasLoadedAll[env];
  }

  static async getById(env, id, qs) {
    this.handleCaching();

    for (let item of this.cache) {
      if (item.id == id && item.remote === env || `${env}-${id}` === item.metastring) return item;
    }

    let data = await lib.makeAPIRequest({
      env,
      path: `/${this.endpoint}/${id}`,
      qs
    });

    if (data.data) {
      let o = new this({
        data: data.data,
        remote: env,
        included: data.included
      });
      this.cache.push(o);
      return o;
    }
  }

  static async getByName(env, name, qs) {
    this.handleCaching();

    for (let item of this.cache) {
      if (item.name === name && item.remote === env) return item;
    }

    let data = await lib.makeAPIRequest({
      env,
      path: `/${this.endpoint}`,
      qs: { ...qs,
        filter: `name=${name}` + (qs ? qs.filter : "")
      }
    }); //TODO included might not wokr correctly here

    if (data.data[0]) {
      let o = new this({
        data: data.data[0],
        remote: env,
        included: data.included
      });
      this.cache.push(o);
      return o;
    }
  }

  static async getAllPreCollect(d) {
    return d;
  }

  static async getAll(env) {
    this.handleCaching();
    let datas = await lib.indexPathFast({
      env,
      path: `/${this.endpoint}`,
      pageSize: "50",
      qs: {
        sort: "id"
      }
    });
    datas = await this.getAllPreCollect(datas);
    let all = new Collection(datas.map(data => new this({
      data,
      remote: env
    })));
    this.cache = [...this.cache, ...all.arr];
    return all;
  }

  static async removeCache(env) {
    this.handleCaching();
    this.cache = this.cache.filter(x => x.remote !== env);
  } //Specific turns name into id based on env
  //Generic turns ids into names


  async resolveApply(type, dataObj, direction) {
    let obj;

    if (direction == "generic") {
      obj = await type.getById(this.remote, dataObj.id);

      if (obj) {
        dataObj.name = obj.name;
      }
    } else if (direction == "specific") {
      obj = await type.getByName(this.remote, dataObj.name);

      if (obj) {
        dataObj.id = obj.id;
      }
    }

    return obj;
  } //Type is the baseclass you are looking for (should extend RallyBase)
  //name is the name of the field
  //isArray is true if it has multiple cardinailty, false if it is single
  //direction gets passed directly to resolveApply


  async resolveField(type, name, isArray = false, direction = "generic") {
    // ignore empty fields
    let field = this.relationships[name];
    if (!(field === null || field === void 0 ? void 0 : field.data)) return;

    if (isArray) {
      return await Promise.all(field.data.map(o => this.resolveApply(type, o, direction)));
    } else {
      return await this.resolveApply(type, field.data, direction);
    }
  }

  cleanup() {
    for (let [key, val] of Object.entries(this.relationships)) {
      //Remove ids from data
      if (val.data) {
        if (val.data.id) {
          delete val.data.id;
        } else if (val.data[0]) {
          for (let x of val.data) delete x.id;
        }
      }

      delete val.links;
    } // organization is unused (?)


    delete this.relationships.organization; // id is specific to envs
    // but save source inside meta string in case we need it

    this.metastring = this.remote + "-" + this.data.id;
    delete this.data.id; // links too

    delete this.data.links;
  }

}
function sleep(time = 1000) {
  return new Promise(resolve => setTimeout(resolve, time));
}
function* zip(...items) {
  let iters = items.map(x => x[Symbol.iterator]());

  for (;;) {
    let r = [];

    for (let i of iters) {
      let next = i.next();
      if (next.done) return;
      r.push(next.value);
    }

    yield r;
  }
}
function unordered(_x) {
  return _unordered.apply(this, arguments);
}

function _unordered() {
  _unordered = _wrapAsyncGenerator(function* (proms) {
    let encapsulatedPromises = proms.map(async (x, i) => [i, await x]);

    while (encapsulatedPromises.length > 0) {
      let [ind, result] = yield _awaitAsyncGenerator(Promise.race(encapsulatedPromises.filter(x => x)));
      yield result;
      encapsulatedPromises[ind] = undefined;
    }
  });
  return _unordered.apply(this, arguments);
}

const inquirer = importLazy("inquirer");
const readdir = importLazy("recursive-readdir");
let hasAutoCompletePrompt = false;
function addAutoCompletePrompt() {
  if (hasAutoCompletePrompt) return;
  hasAutoCompletePrompt = true;
  inquirer.registerPrompt("autocomplete", require("inquirer-autocomplete-prompt"));
}
async function $api(propArray) {
  let q;
  q = await inquirer.prompt([{
    type: "input",
    name: "company",
    message: `What is your company?`,
    default: `discovery`
  }]);
  let company = q.company;
  const defaults = {
    DEV: `https://${company}-dev.sdvi.com/api/v2`,
    UAT: `https://${company}-uat.sdvi.com/api/v2`,
    QA: `https://${company}-qa.sdvi.com/api/v2`,
    PROD: `https://${company}.sdvi.com/api/v2`
  };

  if (propArray && propArray[1]) {
    q = {
      envs: [propArray[1]]
    };
  } else {
    //Create a checkbox prompt to choose enviornments
    q = await inquirer.prompt([{
      type: "checkbox",
      name: "envs",
      message: `What enviornments would you like to configure?`,
      choices: Object.keys(defaults).map(name => ({
        name,
        checked: true
      }))
    }]);
  } //Each env should ask 2 for two things: The url and the key.


  let questions = q.envs.map(env => {
    let defaultKey = process.env[`rally_api_key_${env}`];

    if (configObject && configObject.api && configObject.api[env]) {
      defaultKey = configObject.api[env].key;
    }

    return [{
      type: "input",
      name: `api.${env}.url`,
      message: `What is the api endpoint for ${env}?`,
      default: defaults[env]
    }, {
      type: "input",
      name: `api.${env}.key`,
      message: `What is your api key for ${env}?`,
      default: defaultKey
    }];
  }); //flatten and ask

  questions = [].concat(...questions);
  q = await inquirer.prompt(questions);

  if (propArray) {
    q.api = { ...configObject.api,
      ...q.api
    };
  }

  return q;
}
async function $chalk(propArray) {
  return {
    chalk: await askQuestion("Would you like chalk enabled (Adds coloring)?")
  };
}
async function $restrictUAT(propArray) {
  return {
    restrictUAT: await askQuestion("Would you like to protect UAT?")
  };
}
async function $repodir(propArray) {
  return await inquirer.prompt([{
    type: "input",
    name: `repodir`,
    message: `Where is your rally repository (empty for N/A)?`,
    default: process.env["rally_repo_path"]
  }]);
}
async function $appName(propArray) {
  let defaultAppName = "cmdline-" + (process.env.USERNAME || process.env.LOGNAME);
  let project = await askInput("Application name?", defaultAppName);

  if (project === "none" || project === "-" || project === "" || !project) {
    project = null;
  }

  return {
    appName: project
  };
}
async function $project(propArray) {
  let project = await askInput("Subproject directory?");

  if (project === "none" || project === "-" || project === "" || !project) {
    project = null;
  }

  return {
    project
  };
}
async function $defaultEnv(propArray) {
  return await inquirer.prompt([{
    type: "input",
    name: `defaultEnv`,
    message: `Default enviornment?`,
    default: "DEV"
  }]);
} //Internal usage/testing

async function selectProvider(providers, autoDefault = false) {
  addAutoCompletePrompt();
  let defaultProvider = providers.findByName("SdviEvaluate");

  if (autoDefault) {
    return defaultProvider;
  } else {
    let choices = providers.arr.map(x => ({
      name: x.chalkPrint(true),
      value: x
    }));
    let q = await inquirer.prompt([{
      type: "autocomplete",
      name: "provider",
      default: defaultProvider,
      source: async (sofar, input) => {
        return choices.filter(x => input ? x.value.name.toLowerCase().includes(input.toLowerCase()) : true);
      }
    }]);
    return q.provider;
  }
}
async function loadLocals(path$1, Class) {
  let basePath = configObject.repodir;
  let objs = (await readdir(basePath)).filter(name => name.includes(path$1)).filter(name => !path.basename(name).startsWith(".")).map(name => new Class({
    path: name
  }));
  return objs;
}
async function selectLocal(path, typeName, Class, canSelectNone = true) {
  addAutoCompletePrompt();
  let objs = await loadLocals(path, Class);
  let objsMap = objs.map(x => ({
    name: x.chalkPrint(true),
    value: x
  }));
  let none = {
    name: chalk`      {red None}: {red None}`,
    value: null
  };
  if (canSelectNone) objsMap.unshift(none);
  let q = await inquirer.prompt([{
    type: "autocomplete",
    name: "obj",
    message: `What ${typeName} do you want?`,
    source: async (sofar, input) => {
      return objsMap.filter(x => input ? x.name.toLowerCase().includes(input.toLowerCase()) : true);
    }
  }]);
  return q.obj;
}
async function selectPreset({
  purpose = "preset",
  canSelectNone
}) {
  return selectLocal("silo-presets", purpose, Preset, canSelectNone);
}
async function selectRule({
  purpose = "rule",
  canSelectNone
}) {
  return selectLocal("silo-rules", purpose, Rule, canSelectNone);
}
async function askInput(question, def) {
  return (await inquirer.prompt([{
    type: "input",
    name: "ok",
    message: question,
    default: def
  }])).ok;
}
async function askQuestion(question) {
  return (await inquirer.prompt([{
    type: "confirm",
    name: "ok",
    message: question
  }])).ok;
}

var configHelpers = /*#__PURE__*/Object.freeze({
  __proto__: null,
  inquirer: inquirer,
  addAutoCompletePrompt: addAutoCompletePrompt,
  $api: $api,
  $chalk: $chalk,
  $restrictUAT: $restrictUAT,
  $repodir: $repodir,
  $appName: $appName,
  $project: $project,
  $defaultEnv: $defaultEnv,
  selectProvider: selectProvider,
  loadLocals: loadLocals,
  selectLocal: selectLocal,
  selectPreset: selectPreset,
  selectRule: selectRule,
  askInput: askInput,
  askQuestion: askQuestion
});

class Provider extends RallyBase {
  constructor({
    data,
    remote
  }) {
    super();
    this.data = data;
    this.meta = {};
    this.remote = remote;
  } //cached


  async getEditorConfig() {
    if (this.editorConfig) return this.editorConfig;
    this.editorConfig = await lib.makeAPIRequest({
      env: this.remote,
      path_full: this.data.links.editorConfig
    });
    this.editorConfig.fileExt = await this.getFileExtension();
    return this.editorConfig;
  }

  static async getAllPreCollect(providers) {
    return providers.sort((a, b) => {
      return a.attributes.category.localeCompare(b.attributes.category) || a.attributes.name.localeCompare(b.attributes.name);
    });
  }

  async getFileExtension() {
    let config = await this.getEditorConfig();
    let map = {
      python: "py",
      text: "txt",

      getmap(key) {
        if (this.name === "Aurora") return "zip";
        if (this[key]) return this[key];
        return key;
      }

    };
    return map.getmap(config.lang);
  }

  chalkPrint(pad = true) {
    let id = String(this.id);
    if (pad) id = id.padStart(4);
    return chalk`{green ${id}}: {blue ${this.category}} - {green ${this.name}}`;
  }

}

defineAssoc(Provider, "id", "data.id");
defineAssoc(Provider, "name", "data.attributes.name");
defineAssoc(Provider, "category", "data.attributes.category");
defineAssoc(Provider, "remote", "meta.remote");
defineAssoc(Provider, "editorConfig", "meta.editorConfig");
Provider.endpoint = "providerTypes";

class File extends RallyBase {
  constructor({
    data,
    remote,
    included,
    parent
  }) {
    super();
    this.data = data;
    this.meta = {};
    this.remote = remote;
    this.parentAsset = parent;
  }

  chalkPrint(pad = false) {
    let id = String("F-" + (this.remote && this.remote + "-" + this.id || "LOCAL"));
    if (pad) id = id.padStart(15);
    return chalk`{green ${id}}: {blue ${this.data.attributes ? this.name : "(lite file)"}} {red ${this.sizeHR}}`;
  }

  canBeDownloaded() {
    return this.sizeGB <= .2;
  }

  async getContent(force = false) {
    if (!this.canBeDownloaded() && !force) {
      throw new FileTooLargeError(this);
    }

    return lib.makeAPIRequest({
      env: this.remote,
      fullPath: this.contentLink
    });
  }

  async delete(remove = true) {
    return lib.makeAPIRequest({
      env: this.remote,
      fullPath: this.selfLink,
      method: "DELETE"
    });
  }

  get size() {
    return Object.values(this.data.attributes.instances)[0].size;
  }

  get sizeGB() {
    return Math.round(this.size / 1024 / 1024 / 1024 * 10) / 10;
  }

  get sizeHR() {
    let units = ["B", "K", "M", "G", "T"];
    let unitIdx = 0;
    let size = this.size;

    while (size > 1000) {
      size /= 1024;
      unitIdx++;
    }

    if (size > 100) {
      size = Math.round(size);
    } else {
      size = Math.round(size * 10) / 10;
    }

    return size + units[unitIdx];
  }

  get instancesList() {
    let instances = [];

    for (let [key, val] of Object.entries(this.instances)) {
      let n = {
        id: key
      };
      Object.assign(n, val);
      instances.push(n);
    }

    return instances;
  }

  static rslURL(instance) {
    return `rsl://${instance.storageLocationName}/${instance.name}`;
  }

}

defineAssoc(File, "id", "data.id");
defineAssoc(File, "name", "data.attributes.label");
defineAssoc(File, "contentLink", "data.links.content");
defineAssoc(File, "selfLink", "data.links.self");
defineAssoc(File, "label", "data.attributes.label");
defineAssoc(File, "md5", "data.attributes.md5");
defineAssoc(File, "sha512", "data.attributes.sha512");
defineAssoc(File, "tags", "data.attributes.tagList");
defineAssoc(File, "instances", "data.attributes.instances");
File.endpoint = null;

async function findLineInFile(renderedPreset, lineNumber) {
  let trueFileLine = lineNumber;
  let linedRenderedPreset = renderedPreset.split("\n").slice(2, -2);
  renderedPreset = renderedPreset.split("\n").slice(2, -2).join("\n");
  let includeLocation = renderedPreset.split("\n").filter(x => x.includes("@include"));
  let endIncludeNumber = -1,
      addTabDepth = 2;
  let lineBeforeIncludeStatement = '';
  let withinInclude = true;

  if (lineNumber > linedRenderedPreset.indexOf(includeLocation[includeLocation.length - 1])) {
    addTabDepth = 0;
    withinInclude = false;
  }

  for (let index = includeLocation.length - 1; index >= 0; index--) {
    let currIncludeIndex = linedRenderedPreset.indexOf(includeLocation[index]);
    let tabDepth = includeLocation[index].split("  ").length;

    if (lineNumber > currIncludeIndex) {
      if (includeLocation[index].split(" ").filter(Boolean)[1] != "ERROR:") {
        if (lineBeforeIncludeStatement.split("  ").length == tabDepth && withinInclude) {
          trueFileLine = trueFileLine - currIncludeIndex;
          break;
        } else if (lineBeforeIncludeStatement.split("  ").length + addTabDepth == tabDepth && endIncludeNumber == -1) {
          endIncludeNumber = currIncludeIndex;
        } else if (lineBeforeIncludeStatement.split("  ").length + addTabDepth == tabDepth) {
          trueFileLine = trueFileLine - (endIncludeNumber - currIncludeIndex);
          endIncludeNumber = -1;
        }
      }
    } else {
      lineBeforeIncludeStatement = includeLocation[index];
    }
  }

  let funcLine = "";

  for (let line of linedRenderedPreset.slice(0, lineNumber).reverse()) {
    let match = /def (\w+)/.exec(line);

    if (match) {
      funcLine = match[1];
      break;
    }
  }

  let includeFilename;

  if (lineBeforeIncludeStatement != "") {
    includeFilename = lineBeforeIncludeStatement.slice(1).trim().slice(14, -1);
  } else {
    includeFilename = null;
  }

  if (includeLocation.length !== 0) {
    trueFileLine -= 1;
    lineNumber -= 1;
  }

  return {
    lineNumber: trueFileLine,
    includeFilename,
    line: linedRenderedPreset[lineNumber],
    funcLine
  };
}
function printOutLine(eLine) {
  return log(chalk`{blue ${eLine.includeFilename || "Main"}}:{green ${eLine.lineNumber}} in ${eLine.funcLine}
${eLine.line}`);
}
async function getArtifact(env, artifact, jobid) {
  let path = `/jobs/${jobid}/artifacts/${artifact}`;
  let art = lib.makeAPIRequest({
    env,
    path
  }).catch(_ => null);
  return await art;
}
async function getInfo(env, jobid) {
  let trace = getArtifact(env, "trace", jobid);
  let renderedPreset = getArtifact(env, "preset", jobid);
  let result = getArtifact(env, "result", jobid);
  let error = getArtifact(env, "error", jobid);
  let output = getArtifact(env, "output", jobid);
  [trace, renderedPreset, result, output, error] = await Promise.all([trace, renderedPreset, result, output, error]);
  return {
    trace,
    renderedPreset,
    result,
    output,
    error
  };
}
const tracelineRegex = /^(?:[\d.]+) ([\w ]+):(\d+): (.+)/;
function parseTraceLine(line) {
  let info = tracelineRegex.exec(line);

  if (!info) {
    return {
      full: line,
      parsed: false,
      content: line
    };
  }

  return {
    absoluteTime: info[0],
    presetName: info[1],
    lineNumber: info[2],
    text: info[3],
    content: info[3],
    full: line,
    parsed: true
  };
}
async function parseTrace(env, jobid) {
  let {
    trace,
    renderedPreset
  } = await getInfo(env, jobid);
  let errorLines = [];
  let shouldBreak = 0;

  for (let tr of trace.split("\n\n").reverse()) {
    errorLines.push(tr);
    shouldBreak--;
    if (tr.includes("Exception")) shouldBreak = 1;
    if (tr.includes("raised")) shouldBreak = 1;
    if (!shouldBreak) break;
  }

  let errorList = [];

  for (let errLine of errorLines) {
    let info = parseTraceLine(errLine);

    if (!info.parsed) {
      errorList.push((await findLineInFile(renderedPreset, info.lineNumber)));
    } else {
      errorList.push(errLine);
    }
  }

  return errorList;
}
const Trace = {
  parseTrace,
  printOutLine,
  getInfo,
  findLineInFile
};

class Asset extends RallyBase {
  constructor({
    data,
    remote,
    included,
    lite
  }) {
    super();
    this.data = data;
    this.meta = {};
    this.remote = remote;

    if (included) {
      this.meta.metadata = Asset.normalizeMetadata(included);
    }

    this.lite = !!lite;
  }

  static normalizeMetadata(payload) {
    let newMetadata = {};

    for (let md of payload) {
      if (md.type !== "metadata") continue;
      newMetadata[md.attributes.usage] = md.attributes.metadata;
    }

    return newMetadata;
  }

  async getMetadata(forceRefresh = false) {
    if (this.meta.metadata && !forceRefresh) return this.meta.metadata;
    let req = await lib.makeAPIRequest({
      env: this.remote,
      path: `/movies/${this.id}/metadata?page=1p100`
    });
    return this.meta.metadata = Asset.normalizeMetadata(req.data);
  }

  async patchMetadata(metadata) {
    if (metadata.Workflow) {
      //FIXME
      //Currently, WORKFLOW_METADATA cannot be patched via api: we need to
      //start a ephemeral eval to upload it
      let md = JSON.stringify(JSON.stringify(metadata.Workflow));
      let fakePreset = {
        code: `WORKFLOW_METADATA.update(json.loads(${md}))`
      };
      await this.startEphemeralEvaluateIdeal(fakePreset);
      log("WFMD Patched using ephemeralEval");
    }

    if (metadata.Metadata) {
      let req = await lib.makeAPIRequest({
        env: this.remote,
        path: `/movies/${this.id}/metadata/Metadata`,
        method: "PATCH",
        payload: {
          "data": {
            "type": "metadata",
            "attributes": {
              "metadata": metadata.Metadata
            }
          }
        }
      });
      log("MD Patched");
    }
  }

  static lite(id, remote) {
    return new this({
      data: {
        id
      },
      remote,
      lite: true
    });
  }

  chalkPrint(pad = false) {
    let id = String("A-" + (this.remote && this.remote + "-" + this.id || "LOCAL"));
    if (pad) id = id.padStart(15);
    return chalk`{green ${id}}: {blue ${this.data.attributes ? this.name : "(lite asset)"}}`;
  }

  static async createNew(name, env) {
    let req = await lib.makeAPIRequest({
      env,
      path: "/assets",
      method: "POST",
      payload: {
        data: {
          attributes: {
            name
          },
          type: "assets"
        }
      }
    });
    return new this({
      data: req.data,
      remote: env
    });
  }

  async delete() {
    let req = await lib.makeAPIRequest({
      env: this.remote,
      path: "/assets/" + this.id,
      method: "DELETE"
    });
  }

  async getFiles(refresh = false) {
    if (this._files && !refresh) return this._files;
    let req = await lib.indexPathFast({
      env: this.remote,
      path: `/assets/${this.id}/files`,
      method: "GET"
    }); //return req;

    return this._files = new Collection(req.map(x => new File({
      data: x,
      remote: this.remote,
      parent: this
    })));
  }

  async addFile(label, fileuris) {
    if (!Array.isArray(fileuris)) fileuris = [fileuris];
    let instances = {};

    for (let i = 0; i < fileuris.length; i++) {
      instances[String(i + 1)] = {
        uri: fileuris[i]
      };
    }

    let req = await lib.makeAPIRequest({
      env: this.remote,
      path: "/files",
      method: "POST",
      payload: {
        "data": {
          "attributes": {
            label,
            instances
          },
          "relationships": {
            "asset": {
              "data": {
                id: this.id,
                "type": "assets"
              }
            }
          },
          "type": "files"
        }
      }
    });
    return req;
  }

  async startWorkflow(jobName, {
    initData,
    priority
  } = {}) {
    let attributes = {};

    if (initData) {
      //Convert init data to string
      initData = typeof initData === "string" ? initData : JSON.stringify(initData);
      attributes.initData = initData;
    }

    if (priority) {
      attributes.priority = priority;
    }

    let req = await lib.makeAPIRequest({
      env: this.remote,
      path: "/workflows",
      method: "POST",
      payload: {
        "data": {
          "type": "workflows",
          attributes,
          "relationships": {
            "movie": {
              "data": {
                id: this.id,
                "type": "movies"
              }
            },
            "rule": {
              "data": {
                "attributes": {
                  "name": jobName
                },
                "type": "rules"
              }
            }
          }
        }
      }
    });
    return req;
  }

  static async startAnonWorkflow(env, jobName, {
    initData,
    priority
  } = {}) {
    let attributes = {};

    if (initData) {
      //Convert init data to string
      initData = typeof initData === "string" ? initData : JSON.stringify(initData);
      attributes.initData = initData;
    }

    if (priority) {
      attributes.priority = priority;
    }

    let req = await lib.makeAPIRequest({
      env,
      path: "/workflows",
      method: "POST",
      payload: {
        "data": {
          "type": "workflows",
          attributes,
          "relationships": {
            "rule": {
              "data": {
                "attributes": {
                  "name": jobName
                },
                "type": "rules"
              }
            }
          }
        }
      }
    });
    return req;
  }

  async startEphemeralEvaluateIdeal(preset, dynamicPresetData, isBinary = false) {
    let res;
    const env = this.remote;
    let provider = await Provider.getByName(this.remote, "SdviEvaluate");
    write(chalk`Starting ephemeral evaluate on ${this.chalkPrint(false)}...`); // Fire and forget.

    let evalInfo = await lib.makeAPIRequest({
      env: this.remote,
      path: "/jobs",
      method: "POST",
      payload: {
        data: {
          attributes: {
            category: provider.category,
            providerTypeName: provider.name,
            rallyConfiguration: {},
            //we need to strip invalid utf8 characters from the
            //buffer before we encode it or the sdvi backend dies
            providerData: Buffer.from(preset.code, isBinary && "binary" || "utf8").toString("base64"),
            dynamicPresetData
          },
          type: "jobs",
          relationships: {
            movie: {
              data: {
                id: this.id,
                type: "movies"
              }
            }
          }
        }
      }
    });
    write(" Waiting for finish...\n");
    let dots = 0;

    for (;;) {
      res = await lib.makeAPIRequest({
        env,
        path_full: evalInfo.data.links.self
      });
      write(`\r${res.data.attributes.state}${".".repeat(dots++)}         `);

      if (dots === 5) {
        dots = 1;
      }

      if (res.data.attributes.state == "Complete") {
        write(chalk`{green  Done}...\n`);
        break;
      }

      await sleep(500);
    }

    return;
  }

  async startEvaluate(presetid, dynamicPresetData) {
    // Fire and forget.
    let data = await lib.makeAPIRequest({
      env: this.remote,
      path: "/jobs",
      method: "POST",
      payload: {
        data: {
          type: "jobs",
          attributes: {
            dynamicPresetData
          },
          relationships: {
            movie: {
              data: {
                id: this.id,
                type: "movies"
              }
            },
            preset: {
              data: {
                id: presetid,
                type: "presets"
              }
            }
          }
        }
      }
    });
    return data;
  }

  async rename(newName) {
    let req = await lib.makeAPIRequest({
      env: this.remote,
      path: `/assets/${this.id}`,
      method: "PATCH",
      payload: {
        data: {
          attributes: {
            name: newName
          },
          type: "assets"
        }
      }
    });
    this.name = newName;
    return req;
  }

  async migrate(targetEnv) {
    configObject.globalProgress = false;
    log(`Creating paired file in ${targetEnv}`); //Fetch metadata in parallel, we await it later

    let _mdPromise = this.getMetadata();

    let name = "DNAP_John_Test";
    let targetAsset = await Asset.getByName(targetEnv, name);

    if (targetAsset) {
      log(`Asset already exists ${targetAsset.chalkPrint()}`); //if(configObject.script) process.exit(10);
    } else {
      targetAsset = await Asset.createNew(name, targetEnv);
      log(`Asset created ${targetAsset.chalkPrint()}`);
    } //wait for metadata to be ready before patching


    await _mdPromise;
    log("Adding asset metadata");
    await targetAsset.patchMetadata(this.md);
    let fileCreations = [];

    for (let file of await this.getFiles()) {
      //Check for any valid copy-able instances
      for (let inst of file.instancesList) {
        //We need to skip internal files
        if (inst.storageLocationName === "Rally Platform Bucket") continue;
        log(`Adding file: ${file.chalkPrint()}`);
        fileCreations.push(targetAsset.addFileInstance(file, inst));
      }
    }

    await Promise.all(fileCreations);
  }

  async addFileInstance(file, inst, tagList = []) {
    let newInst = {
      uri: File.rslURL(inst),
      name: inst.name,
      size: inst.size,
      lastModified: inst.lastModified,
      storageLocationName: inst.storageLocationName
    };
    let request = lib.makeAPIRequest({
      env: this.remote,
      path: `/files`,
      method: "POST",
      payload: {
        data: {
          type: "files",
          attributes: {
            label: file.label,
            tagList,
            instances: {
              "1": newInst
            }
          },
          relationships: {
            asset: {
              data: {
                id: this.id,
                type: "assets"
              }
            }
          }
        }
      }
    });

    try {
      let fileData = await request;
      let newFile = new File({
        data: fileData.data,
        remote: this.remote,
        parent: this
      });
      if (configObject.script) console.log(inst.uri, newFile.instancesList[0].uri);
    } catch (e) {
      log(chalk`{red Failed file: ${file.chalkPrint()}}`);
    }
  }

  async downloadFile(label, destFolder) {
    let files = await this.getFiles();
    let file = files.findByName(label);
    let c = await file.getContent();

    if (destFolder) {
      let filePath = path__default['default'].join(destFolder, file.instancesList[0].name);
      fs__default['default'].writeFileSync(filePath, c);
    } else {
      console.log(c);
    }
  }

  async deleteFile(label) {
    let files = await this.getFiles();
    let file = files.findByName(label);
    if (!file) return false;
    await file.delete(false); //mode=forget

    return true;
  }

  async grep(text, {
    artifact = "trace",
    nameOnly = false,
    ordering = null
  }) {
    function reorderPromises(_x) {
      return _reorderPromises.apply(this, arguments);
    }

    function _reorderPromises() {
      _reorderPromises = _wrapAsyncGenerator(function* (p) {
        ////yield in order we got it
        //yield* p[Symbol.iterator]();
        ////yield in order of first to finish
        //yield* unordered(p);
        //yield in chronological order
        let k = yield _awaitAsyncGenerator(Promise.all(p));
        yield* _asyncGeneratorDelegate(_asyncIterator(k.sort(([e1, _a], [e2, _b]) => {
          return e1.attributes.completedAt - e2.attributes.completedAt;
        })), _awaitAsyncGenerator);
      });
      return _reorderPromises.apply(this, arguments);
    }

    elog("Reading jobs...");
    let r = await lib.indexPathFast({
      env: this.remote,
      path: "/jobs",
      qs: {
        filter: `movieId=${this.id}`
      }
    });
    elog("Getting job artifacts...");

    function highlight(line, text) {
      let parts = line.split(text);
      return parts.join(chalk`{blue ${text}}`);
    }

    function parseLine(x) {
      if (artifact === "trace") {
        return parseTraceLine(x);
      } else {
        //fake the output from parseTraceLine to make it look right
        return {
          content: x
        };
      }
    } //let evals = r.filter(x => x.attributes.providerTypeName === "SdviEvaluate");


    let evals = r;
    let zipped = evals.map(async x => [x, await getArtifact(this.remote, artifact, x.id)]);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;

    var _iteratorError;

    try {
      for (var _iterator = _asyncIterator(reorderPromises(zipped)), _step, _value; _step = await _iterator.next(), _iteratorNormalCompletion = _step.done, _value = await _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {
        let [e, trace] = _value;
        if (!trace) continue;
        let lines = trace.split("\n").map(parseLine);
        let matching = lines.filter(x => x.content.includes(text));

        if (matching.length > 0) {
          let preset = await Preset.getById(this.remote, e.relationships.preset.data.id);

          if (nameOnly) {
            log(chalk`{red ${preset.name}} ${e.id} {blue ${matching.length}} matche(s)`);
          } else if (configObject.rawOutput) {
            console.log(matching.map(x => chalk`{red ${preset.name}}:${highlight(x.content, text)}`).join("\n"));
          } else {
            log(chalk`{red ${preset.name}} ${e.id}`);
            log(matching.map(x => `  ${highlight(x.content, text)}`).join("\n"));
          }
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          await _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  async analyze() {
    await lib.makeAPIRequest({
      env: this.remote,
      path: "/v1.0/analysis",
      method: "POST",
      payload: {
        "movieId": this.id,
        "latestVersion": true
      }
    });
  }

}

defineAssoc(Asset, "id", "data.id");
defineAssoc(Asset, "name", "data.attributes.name");
defineAssoc(Asset, "remote", "meta.remote");
defineAssoc(Asset, "md", "meta.metadata");
defineAssoc(Asset, "lite", "meta.lite");
Asset.endpoint = "movies";

let home;

if (os.homedir) {
  home = os.homedir();
}

const colon = /:/g;
const siloLike = /(silo\-\w+?)s?\/([^\/]+)\.([\w1234567890]+)$/g;
function pathTransform(path) {
  if (path.includes(":")) {
    //Ignore the first colon in window-like filesystems
    path = path.slice(0, 3) + path.slice(3).replace(colon, "--");
  }

  if (configObject.invertedPath) {
    path = path.replace(siloLike, "$2-$1.$3");
  }

  if (path.includes("\\342\\200\\220")) {
    path = path.replace("\\342\\200\\220", "‐");
  }

  return path;
}
function readFileSync(path, options) {
  return fs__default['default'].readFileSync(pathTransform(path), options);
} //Create writefilesync, with ability to create directory if it doesnt exist

function writeFileSync(path$1, data, options, dircreated = false) {
  path$1 = pathTransform(path$1);

  try {
    return fs__default['default'].writeFileSync(path$1, data, options);
  } catch (e) {
    if (dircreated) throw e;
    let directory = path.dirname(path$1);

    try {
      fs__default['default'].statSync(directory);
      throw e;
    } catch (nodir) {
      fs__default['default'].mkdirSync(directory);
      return writeFileSync(path$1, data, options, true);
    }
  }
}

let exists = {};

class Preset extends RallyBase {
  constructor({
    path: path$1,
    remote,
    data,
    subProject
  } = {}) {
    // Get full path if possible
    if (path$1) {
      path$1 = path.resolve(path$1);

      if (path.dirname(path$1).includes("silo-metadata")) {
        throw new AbortError("Constructing preset from metadata file");
      }
    }

    super(); // Cache by path

    if (path$1) {
      if (exists[pathTransform(path$1)]) return exists[pathTransform(path$1)];
      exists[pathTransform(path$1)] = this;
    }

    this.meta = {};
    this.subproject = subProject;
    this.remote = remote;

    if (lib.isLocalEnv(this.remote)) {
      if (path$1) {
        this.path = path$1;
        let pathspl = this.path.split(".");
        this.ext = pathspl[pathspl.length - 1];

        try {
          this.code = this.getLocalCode();
        } catch (e) {
          if (e.code === "ENOENT" && configObject.ignoreMissing) {
            this.missing = true;
            return undefined;
          } else {
            log(chalk`{red Node Error} ${e.message}`);
            throw new AbortError("Could not load code of local file");
          }
        }

        let name = this.parseFilenameForName() || this.parseCodeForName();

        try {
          this.data = this.getLocalMetadata();
          this.isGeneric = true;
          name = this.name;
        } catch (e) {
          log(chalk`{yellow Warning}: ${path$1} does not have a readable metadata file! Looking for ${this.localmetadatapath}`);
          this.data = Preset.newShell(name);
          this.isGeneric = false;
        }

        this.name = name;
      } else {
        this.data = Preset.newShell();
      }
    } else {
      this.data = data; //this.name = data.attributes.name;
      //this.id = data.id;

      this.isGeneric = false;
    }

    this.data.attributes.rallyConfiguration = undefined;
    this.data.attributes.systemManaged = undefined;
  } //Given a metadata file, get its actualy file


  static async fromMetadata(path, subproject) {
    let data;

    try {
      data = JSON.parse(readFileSync(path));
    } catch (e) {
      if (e.code === "ENOENT" && configObject.ignoreMissing) {
        return null;
      } else {
        throw e;
      }
    }

    let providerType = data.relationships.providerType.data.name;
    let provider = await Provider.getByName("DEV", providerType);

    if (!provider) {
      log(chalk`{red The provider type {green ${providerType}} does not exist}`);
      log(chalk`{red Skipping {green ${path}}.}`);
      return null;
    }

    let ext = await provider.getFileExtension();
    let name = data.attributes.name;
    let realpath = Preset.getLocalPath(name, ext, subproject);
    return new Preset({
      path: realpath,
      subProject: subproject
    });
  }

  static newShell(name = undefined) {
    return {
      "attributes": {
        "providerSettings": {
          "PresetName": name
        }
      },
      "relationships": {},
      "type": "presets"
    };
  }

  cleanup() {
    super.cleanup();
    delete this.attributes["createdAt"];
    delete this.attributes["updatedAt"];
  }

  async acclimatize(env) {
    if (!this.isGeneric) throw new AbortError("Cannot acclimatize non-generics or shells");
    let providers = await Provider.getAll(env);
    let ptype = this.relationships["providerType"];
    ptype = ptype.data;
    let provider = providers.findByName(ptype.name);
    ptype.id = provider.id;
  }

  get test() {
    if (!this.code) return [];
    const regex = /[^-]autotest:\s?([\w\d_\-. \/]+)[\r\s\n]*?/gm;
    let match;
    let matches = [];

    while (match = regex.exec(this.code)) {
      matches.push(match[1]);
    }

    return matches;
  }

  async runTest(env) {
    let remote = await Preset.getByName(env, this.name);

    for (let test of this.test) {
      log("Tests...");
      let asset;

      if (test.startsWith("id")) {
        let match = /id:\s*(\d+)/g.exec(test);

        if (!match) {
          log(chalk`{red Could not parse autotest} ${test}.`);
          throw new AbortError("Could not properly parse the preset header");
        }

        asset = await Asset.getById(env, match[1]);
      } else {
        asset = await Asset.getByName(env, test);
      }

      if (!asset) {
        log(chalk`{yellow No movie found}, skipping test.`);
        continue;
      }

      log(chalk`Starting job {green ${this.name}} on ${asset.chalkPrint(false)}... `);
      await asset.startEvaluate(remote.id);
    }
  }

  async resolve() {
    if (this.isGeneric) return;
    let proType = await this.resolveField(Provider, "providerType");
    this.ext = await proType.getFileExtension();
    this.isGeneric = true;
    return {
      proType
    };
  }

  async saveLocal() {
    await this.saveLocalMetadata();
    await this.saveLocalFile();
  }

  async saveLocalMetadata() {
    if (!this.isGeneric) {
      await this.resolve();
      this.cleanup();
    }

    writeFileSync(this.localmetadatapath, JSON.stringify(this.data, null, 4));
  }

  async saveLocalFile() {
    writeFileSync(this.localpath, this.code);
  }

  async uploadRemote(env, shouldTest = true) {
    await this.uploadCodeToEnv(env, true, shouldTest);
  }

  async save(env, shouldTest = true) {
    this.saved = true;

    if (!this.isGeneric) {
      await this.resolve();
    }

    this.cleanup();

    if (lib.isLocalEnv(env)) {
      log(chalk`Saving preset {green ${this.name}} to {blue ${lib.envName(env)}}.`);
      await this.saveLocal();
    } else {
      await this.uploadRemote(env, shouldTest);
    }
  }

  async downloadCode() {
    if (!this.remote || this.code) return this.code;
    let code = await lib.makeAPIRequest({
      env: this.remote,
      path_full: this.data.links.providerData,
      json: false
    }); //match header like 
    // # c: d
    // # b
    // # a
    // ##################

    let headerRegex = /(^# .+[\r\n]+)+#+[\r\n]+/gim;
    let hasHeader = headerRegex.exec(code);

    if (hasHeader) {
      this.header = code.substring(0, hasHeader[0].length - 1);
      code = code.substring(hasHeader[0].length);
    }

    return this.code = code;
  }

  get code() {
    if (this._code) return this._code;
  }

  set code(v) {
    this._code = v;
  }

  chalkPrint(pad = true) {
    let id = String("P-" + (this.remote && this.remote + "-" + this.id || "LOCAL"));
    let sub = "";

    if (this.subproject) {
      sub = chalk`{yellow ${this.subproject}}`;
    }

    if (pad) id = id.padStart(10);

    if (this.name == undefined) {
      return chalk`{green ${id}}: ${sub}{red ${this.path}}`;
    } else if (this.meta.proType) {
      return chalk`{green ${id}}: ${sub}{red ${this.meta.proType.name}} {blue ${this.name}}`;
    } else {
      return chalk`{green ${id}}: ${sub}{blue ${this.name}}`;
    }
  }

  parseFilenameForName() {
    if (this.path.endsWith(".jinja") || this.path.endsWith(".json")) {
      return path.basename(this.path).replace("_", " ").replace("-", " ").replace(".json", "").replace(".jinja", "");
    }
  }

  parseCodeForName() {
    const name_regex = /name\s?:\s*?([\w\d. \/]+).*$/;
    const match = name_regex.exec(this.code);
    if (match) return match[1];
  }

  findStringsInCode(strings) {
    if (!this.code) return [];
    return strings.filter(str => {
      let regex = new RegExp(str);
      return !!this.code.match(regex);
    });
  }

  static getLocalPath(name, ext, subproject) {
    return path__default['default'].join(configObject.repodir, subproject || "", "silo-presets", name + "." + ext);
  }

  get localpath() {
    return Preset.getLocalPath(this.name, this.ext, this.subproject);
  }

  get path() {
    if (this._path) return this._path;
  }

  set path(val) {
    this._path = val;
  }

  get name() {
    return this._nameOuter;
  }

  set name(val) {
    if (!this._nameInner) this._nameInner = val;
    this._nameOuter = val;
  }

  set providerType(value) {
    this.relationships["providerType"] = {
      data: { ...value,
        type: "providerTypes"
      }
    };
  }

  get localmetadatapath() {
    if (this.path) {
      return this.path.replace("silo-presets", "silo-metadata").replace(new RegExp(this.ext + "$"), "json");
    }

    return path__default['default'].join(configObject.repodir, this.subproject || "", "silo-metadata", this.name + ".json");
  }

  get immutable() {
    return this.name.includes("Constant") && !configObject.updateImmutable;
  }

  async uploadPresetData(env, id) {
    var _this$relationships, _this$relationships$p, _this$relationships$p2;

    if (this.code.trim() === "NOUPLOAD") {
      write(chalk`code skipped {yellow :)}, `);
      return;
    }

    let code = this.code;
    let headers = {};
    let providerName = (_this$relationships = this.relationships) === null || _this$relationships === void 0 ? void 0 : (_this$relationships$p = _this$relationships.providerType) === null || _this$relationships$p === void 0 ? void 0 : (_this$relationships$p2 = _this$relationships$p.data) === null || _this$relationships$p2 === void 0 ? void 0 : _this$relationships$p2.name;

    if (!configObject.skipHeader && (providerName === "SdviEvaluate" || providerName === "SdviEvalPro")) {
      write(chalk`generate header, `);
      let repodir = configObject.repodir;
      let localpath = this.path.replace(repodir, "");
      if (localpath.startsWith("/")) localpath = localpath.substring(1);

      try {
        let {
          stdout: headerText
        } = await spawn({
          noecho: true
        }, "sh", [path__default['default'].join(configObject.repodir, `bin/header.sh`), moment__default['default'](Date.now()).format("ddd YYYY/MM/DD hh:mm:ssa"), localpath]);
        code = headerText + code;
        write(chalk`header ok, `);
      } catch (e) {
        write(chalk`missing unix, `);
      }
    } //binary presets


    if (providerName == "Vantage") {
      code = Buffer.from(code).toString("base64");
      headers["Content-Transfer-Encoding"] = "base64";
    }

    let res = await lib.makeAPIRequest({
      env,
      path: `/presets/${id}/providerData`,
      body: code,
      method: "PUT",
      fullResponse: true,
      timeout: 10000,
      headers
    });
    write(chalk`code up {yellow ${res.statusCode}}, `);
  }

  async grabMetadata(env) {
    let remote = await Preset.getByName(env, this.name);
    this.isGeneric = false;

    if (!remote) {
      throw new AbortError(`No file found on remote ${env} with name ${this.name}`);
    }

    this.data = remote.data;
    this.remote = env;
  }

  async deleteRemoteVersion(env, id = null) {
    if (lib.isLocalEnv(env)) return false;

    if (!id) {
      let remote = await Preset.getByName(env, this.name);
      id = remote.id;
    }

    return await lib.makeAPIRequest({
      env,
      path: `/presets/${id}`,
      method: "DELETE"
    });
  }

  async delete() {
    if (lib.isLocalEnv(this.remote)) return false;
    return await this.deleteRemoteVersion(this.remote, this.id);
  }

  async uploadCodeToEnv(env, includeMetadata, shouldTest = true) {
    if (!this.name) {
      let match;

      if (match = /^(#|["']{3})\s*EPH (\d+)/.exec(this.code.trim())) {
        let a = await Asset.getById(env, Number(match[2]));
        return a.startEphemeralEvaluateIdeal(this);
      } else {
        log(chalk`Failed uploading {red ${this.path}}. No name found.`);
        return;
      }
    }

    write(chalk`Uploading preset {green ${this.name}} to {green ${env}}: `);

    if (this.immutable) {
      log(chalk`{magenta IMMUTABLE}. Nothing to do.`);
      return;
    } //First query the api to see if this already exists.


    let remote = await Preset.getByName(env, this.name);

    if (remote) {
      //If it exists we can replace it
      write("replace, ");

      if (includeMetadata) {
        let payload = {
          data: {
            attributes: this.data.attributes,
            type: "presets"
          }
        };

        if (this.relationships.tagNames) {
          payload.relationships = {
            tagNames: this.relationships.tagNames
          };
        }

        let res = await lib.makeAPIRequest({
          env,
          path: `/presets/${remote.id}`,
          method: "PATCH",
          payload,
          fullResponse: true
        });
        write(chalk`metadata {yellow ${res.statusCode}}, `);

        if (res.statusCode == 500) {
          log(chalk`skipping code upload, did not successfully upload metadata`);
          return;
        }
      }

      await this.uploadPresetData(env, remote.id);
    } else {
      write("create, ");
      let metadata = {
        data: this.data
      };

      if (!this.relationships["providerType"]) {
        throw new AbortError("Cannot acclimatize shelled presets. (try creating it on the env first)");
      }

      await this.acclimatize(env);
      write("Posting to create preset... ");
      let res = await lib.makeAPIRequest({
        env,
        path: `/presets`,
        method: "POST",
        payload: metadata,
        timeout: 5000
      });
      let id = res.data.id;
      write(chalk`Created id {green ${id}}... Uploading Code... `);
      await this.uploadPresetData(env, id);
    }

    if (this.test[0] && shouldTest) {
      await this.runTest(env);
    } else {
      log("No tests. Done.");
    }
  }

  getLocalMetadata() {
    return JSON.parse(readFileSync(this.localmetadatapath, "utf-8"));
  }

  getLocalCode() {
    //todo fixup for binary presets, see uploadPresetData
    return readFileSync(this.path, "utf-8");
  }

  parseHeaderInfo() {
    var _$exec$, _$exec$2, _$exec$3, _$exec$4, _$exec$5, _$exec$6, _$exec$7;

    if (!this.header) return null;
    let abs = {
      built: (_$exec$ = /Built On:(.+)/.exec(this.header)[1]) === null || _$exec$ === void 0 ? void 0 : _$exec$.trim(),
      author: (_$exec$2 = /Author:(.+)/.exec(this.header)[1]) === null || _$exec$2 === void 0 ? void 0 : _$exec$2.trim(),
      build: (_$exec$3 = /Build:(.+)/.exec(this.header)[1]) === null || _$exec$3 === void 0 ? void 0 : _$exec$3.trim(),
      version: (_$exec$4 = /Version:(.+)/.exec(this.header)[1]) === null || _$exec$4 === void 0 ? void 0 : _$exec$4.trim(),
      branch: (_$exec$5 = /Branch:(.+)/.exec(this.header)[1]) === null || _$exec$5 === void 0 ? void 0 : _$exec$5.trim(),
      commit: (_$exec$6 = /Commit:(.+)/.exec(this.header)[1]) === null || _$exec$6 === void 0 ? void 0 : _$exec$6.trim(),
      local: (_$exec$7 = /Local File:(.+)/.exec(this.header)[1]) === null || _$exec$7 === void 0 ? void 0 : _$exec$7.trim()
    };
    let tryFormats = [[true, "ddd MMM DD HH:mm:ss YYYY"], [false, "ddd YYYY/MM/DD LTS"]];

    for (let [isUTC, format] of tryFormats) {
      let date;

      if (isUTC) {
        date = moment__default['default'].utc(abs.built, format);
      } else {
        date = moment__default['default'](abs.built, format);
      }

      if (!date.isValid()) continue;
      abs.offset = date.fromNow();
      break;
    }

    return abs;
  }

  async printRemoteInfo(env) {
    let remote = await Preset.getByName(env, this.name);
    await remote.downloadCode();
    let i = remote.parseHeaderInfo();

    if (i) {
      log(chalk`
                ENV: {red ${env}}, updated {yellow ~${i.offset}}
                Built on {blue ${i.built}} by {green ${i.author}}
                From ${i.build || "(unknown)"} on ${i.branch} ({yellow ${i.commit}})
            `.replace(/^[ \t]+/gim, "").trim());
    } else {
      log(chalk`No header on {red ${env}}`);
    }
  }

  async getInfo(envs) {
    await this.printDepends();

    for (let env of envs.split(",")) {
      await this.printRemoteInfo(env);
    }
  }

  async printDepends(indent = 0, locals = null, seen = {}) {
    let includeRegex = /@include "(.+)"/gim; //let includeRegex = /@include/g;

    let includes = [];
    let inc;

    while (inc = includeRegex.exec(this.code)) {
      includes.push(inc[1]);
    } //let includes = this.code
    //.split("\n")
    //.map(x => includeRegex.exec(x))
    //.filter(x => x)
    //.map(x => x[1]);
    //log(includes);


    if (!locals) {
      locals = new Collection((await loadLocals("silo-presets", Preset)));
    }

    log(Array(indent + 1).join(" ") + "- " + this.name);

    for (let include of includes) {
      if (seen[include]) {
        log(Array(indent + 1).join(" ") + "  - (seen) " + include);
      } else {
        seen[include] = true;
        let file = await locals.findByName(include);

        if (file) {
          await file.printDepends(indent + 2, locals, seen);
        } else {
          log(Array(indent + 1).join(" ") + "  - (miss) " + include);
        }
      }
    }
  }

}

defineAssoc(Preset, "_nameInner", "data.attributes.providerSettings.PresetName");
defineAssoc(Preset, "_nameOuter", "data.attributes.name");
defineAssoc(Preset, "id", "data.id");
defineAssoc(Preset, "attributes", "data.attributes");
defineAssoc(Preset, "relationships", "data.relationships");
defineAssoc(Preset, "remote", "meta.remote");
defineAssoc(Preset, "_code", "meta.code");
defineAssoc(Preset, "_path", "meta.path");
defineAssoc(Preset, "isGeneric", "meta.isGeneric");
defineAssoc(Preset, "ext", "meta.ext");
defineAssoc(Preset, "subproject", "meta.project");
defineAssoc(Preset, "metastring", "meta.metastring");
Preset.endpoint = "presets";

class Notification extends RallyBase {
  constructor({
    data,
    remote
  }) {
    super();
    this.data = data;
    this.meta = {};
    this.remote = remote;
  }

  static async getAllPreCollect(notifications) {
    return notifications.sort((a, b) => {
      return a.attributes.type.localeCompare(b.attributes.type) || a.attributes.name.localeCompare(b.attributes.name);
    });
  }

  chalkPrint(pad = false) {
    let id = String("N-" + this.id);
    if (pad) id = id.padStart(4);
    return chalk`{green ${id}}: {blue ${this.type}} - {green ${this.name}}`;
  }

}

defineAssoc(Notification, "id", "data.id");
defineAssoc(Notification, "name", "data.attributes.name");
defineAssoc(Notification, "address", "data.attributes.address");
defineAssoc(Notification, "type", "data.attributes.type");
defineAssoc(Notification, "remote", "meta.remote");
Notification.endpoint = "notificationPresets";

class Rule extends RallyBase {
  constructor({
    path: path$1,
    data,
    remote,
    subProject
  } = {}) {
    super();

    if (path$1) {
      path$1 = path.resolve(path$1);

      try {
        let f = readFileSync(path$1, "utf-8");
        data = JSON.parse(readFileSync(path$1, "utf-8"));
      } catch (e) {
        if (e.code === "ENOENT") {
          if (configObject.ignoreMissing) {
            this.missing = true;
            return undefined;
          } else {
            throw new AbortError("Could not load code of local file");
          }
        } else {
          throw new AbortError(`Unreadable JSON in ${path$1}. ${e}`);
        }
      }
    }

    this.meta = {};
    this.subproject = subProject;

    if (!data) {
      data = Rule.newShell();
    }

    this.data = data;
    this.remote = remote;
    this.isGeneric = !this.remote;
  }

  static newShell() {
    return {
      "attributes": {
        "description": "-",
        "priority": "PriorityNorm",
        "starred": false
      },
      "relationships": {},
      "type": "workflowRules"
    };
  }

  async acclimatize(env) {
    this.remote = env;
    let preset = await this.resolveField(Preset, "preset", false, "specific");
    let pNext = await this.resolveField(Rule, "passNext", false, "specific");
    let eNext = await this.resolveField(Rule, "errorNext", false, "specific");
    let proType = await this.resolveField(Provider, "providerType", false, "specific");
    let dynamicNexts = await this.resolveField(Rule, "dynamicNexts", true, "specific");
    let enterNotif = await this.resolveField(Notification, "enterNotifications", true, "specific");
    let errorNotif = await this.resolveField(Notification, "errorNotifications", true, "specific");
    let passNotif = await this.resolveField(Notification, "passNotifications", true, "specific");
  }

  async saveA(env) {
    if (lib.isLocalEnv(env)) return;
    return await this.createIfNotExist(env);
  }

  async saveB(env) {
    if (!this.isGeneric) {
      await this.resolve();
    }

    this.cleanup();

    if (lib.isLocalEnv(env)) {
      log(chalk`Saving rule {green ${this.name}} to {blue ${lib.envName(env)}}.`);
      writeFileSync(this.localpath, JSON.stringify(this.data, null, 4));
    } else {
      await this.acclimatize(env);
      await this.uploadRemote(env);
    }
  }

  get immutable() {
    return false;
  }

  async createIfNotExist(env) {
    write(chalk`First pass rule {green ${this.name}} to {green ${env}}: `);

    if (this.immutable) {
      log(chalk`{magenta IMMUTABLE}. Nothing to do.`);
      return;
    } //First query the api to see if this already exists.


    let remote = await Rule.getByName(env, this.name);
    this.idMap = this.idMap || {};

    if (remote) {
      this.idMap[env] = remote.id;
      log(chalk`exists ${remote.chalkPrint(false)}`);
      return;
    } //If it exists we can replace it


    write("create, ");
    let res = await lib.makeAPIRequest({
      env,
      path: `/workflowRules`,
      method: "POST",
      payload: {
        data: {
          attributes: {
            name: this.name
          },
          type: "workflowRules"
        }
      }
    });
    this.idMap = this.idMap || {};
    this.idMap[env] = res.data.id;
    write("id ");
    log(this.idMap[env]);
  }

  async patchStrip() {
    delete this.data.attributes.createdAt;
    delete this.data.attributes.starred;
    delete this.data.attributes.updatedAt; // TEMP FIX FOR BUG IN SDVI

    if (this.relationships.passMetadata && this.relationships.passMetadata[0]) {
      log("HAS PASS");
      log(this.name);
      log("HAS PASS");
    }

    delete this.relationships.passMetadata;

    if (this.relationships.errorMetadata && this.relationships.errorMetadata[0]) {
      log("HAS PASS");
      log(this.name);
      log("HAS PASS");
    }

    delete this.relationships.errorMetadata; // This is commented out because it was fixed.
    //for(let key in this.relationships){
    //let relationship = this.relationships[key];
    //if(!relationship.data || relationship.data instanceof Array && !relationship.data[0]){
    //delete this.relationships[key];
    //}
    //}
  }

  async uploadRemote(env) {
    write(chalk`Uploading rule {green ${this.name}} to {green ${env}}: `);

    if (this.immutable) {
      log(chalk`{magenta IMMUTABLE}. Nothing to do.`);
      return;
    }

    if (this.idMap[env]) {
      this.remote = env;
      await this.patchStrip();
      this.data.id = this.idMap[env]; //If it exists we can replace it

      write("replace, ");
      let res = await lib.makeAPIRequest({
        env,
        path: `/workflowRules/${this.idMap[env]}`,
        method: "PATCH",
        payload: {
          data: this.data
        },
        fullResponse: true
      });
      log(chalk`response {yellow ${res.statusCode}}`);

      if (res.statusCode !== 200) {
        log(res.body);
        log(JSON.stringify(this.data, null, 4));
      }
    } else {
      throw Error("Bad idmap!");
    }
  }

  get localpath() {
    return path.join(configObject.repodir, this.subproject || "", "silo-rules", this.name + ".json");
  }

  async resolve() {
    let preset = await this.resolveField(Preset, "preset", false); //log(preset);

    let pNext = await this.resolveField(Rule, "passNext", false);
    let eNext = await this.resolveField(Rule, "errorNext", false);
    let proType = await this.resolveField(Provider, "providerType", false); //log("Dynamic nexts")

    let dynamicNexts = await this.resolveField(Rule, "dynamicNexts", true); //log(dynamicNexts);

    let enterNotif = await this.resolveField(Notification, "enterNotifications", true);
    let errorNotif = await this.resolveField(Notification, "errorNotifications", true);
    let passNotif = await this.resolveField(Notification, "passNotifications", true); //TODO Unsupported

    delete this.relationships["enterMetadata"];
    delete this.relationships["errorMetadata"];
    this.isGeneric = true;
    return {
      preset,
      proType,
      pNext,
      eNext,
      dynamicNexts,
      errorNotif,
      enterNotif,
      passNotif
    };
  }

  chalkPrint(pad = true) {
    let id = String("R-" + (this.remote && this.remote + "-" + this.id || "LOCAL"));
    let sub = "";

    if (this.subproject) {
      sub = chalk`{yellow ${this.subproject}}`;
    }

    if (pad) id = id.padStart(10);

    try {
      return chalk`{green ${id}}: ${sub}{blue ${this.name}}`;
    } catch (e) {
      return this.data;
    }
  }

}

defineAssoc(Rule, "name", "data.attributes.name");
defineAssoc(Rule, "description", "data.attributes.description");
defineAssoc(Rule, "id", "data.id");
defineAssoc(Rule, "relationships", "data.relationships");
defineAssoc(Rule, "isGeneric", "meta.isGeneric");
defineAssoc(Rule, "remote", "meta.remote");
defineAssoc(Rule, "subproject", "meta.project");
defineAssoc(Rule, "idMap", "meta.idMap");
Rule.endpoint = "workflowRules";

//Move project into silo metadata
//move autotest into silo metadata
//

class SupplyChain {
  constructor(startingRule, stopRule) {
    if (startingRule) {
      this.startingRule = startingRule;
      this.stopRule = stopRule;
      this.remote = startingRule.remote;
    }
  }

  async downloadPresetCode(objs = this.allPresets) {
    log("Downloading code... ");
    await lib.keepalive(objs.arr.map(x => () => x.downloadCode()));
  }

  async calculate() {
    log("Getting rules... ");
    this.allRules = await Rule.getAll(this.remote);
    log(this.allRules.length);
    log("Getting presets... ");
    this.allPresets = await Preset.getAll(this.remote);
    log(this.allPresets.length);
    log("Getting providers... ");
    this.allProviders = await Provider.getAll(this.remote);
    log(this.allProviders.length);
    log("Getting notifications... ");
    this.allNotifications = await Notification.getAll(this.remote);
    log(this.allNotifications.length);

    if (!this.startingRule) {
      this.rules = this.allRules;
      this.presets = this.allPresets;
      this.notifications = new Collection([]);
      await this.downloadPresetCode();
      return;
    } else {
      await this.downloadPresetCode();
    }

    log("Done!"); //Now we have everything we need to find a whole supply chain

    write("Calculating Supply chain... ");
    log(this.startingRule.chalkPrint());
    let allRuleNames = this.allRules.arr.map(x => x.name).filter(x => x.length >= 4);
    let allPresetNames = this.allPresets.arr.map(x => x.name).filter(x => x.length >= 4);
    let allNotifNames = this.allNotifications.arr.map(x => x.name).filter(x => x.length >= 4);
    let requiredNotifications = new Set();
    let ruleQueue = [this.startingRule];
    let presetQueue = [];

    for (let currentRule of ruleQueue) {
      if (currentRule === this.stopRule) continue;
      let {
        eNext,
        pNext,
        preset,
        passNotif,
        errorNotif,
        enterNotif
      } = await currentRule.resolve();
      passNotif.forEach(n => requiredNotifications.add(n));
      enterNotif.forEach(n => requiredNotifications.add(n));
      errorNotif.forEach(n => requiredNotifications.add(n));
      if (eNext && !ruleQueue.includes(eNext)) ruleQueue.push(eNext);
      if (pNext && !ruleQueue.includes(eNext)) ruleQueue.push(pNext);
      let neededPresets = preset.findStringsInCode(allPresetNames);
      neededPresets = neededPresets.map(x => this.allPresets.findByName(x));
      let neededRules = preset.findStringsInCode(allRuleNames);
      neededRules = neededRules.map(x => this.allRules.findByName(x));
      preset.findStringsInCode(allNotifNames).map(str => this.allNotifications.findByName(str)).forEach(notif => requiredNotifications.add(notif));
      neededPresets.push(preset);

      for (let p of neededPresets) if (!presetQueue.includes(p)) presetQueue.push(p);

      for (let p of neededRules) if (!ruleQueue.includes(p)) ruleQueue.push(p);

      if (configObject.verbose) {
        write(currentRule.chalkPrint(false));
        log(":");
        write("  ");
        write(preset.chalkPrint(false));
        log(":");
        write("  Pass Next: ");
        if (pNext) write(pNext.chalkPrint(false));else write("None");
        log("");
        write("  Err  Next: ");
        if (eNext) write(eNext.chalkPrint(false));else write("None");
        log("");
        log("  Rules:");

        for (let p of neededRules) log("    " + p.chalkPrint(true));

        log("  Presets:");

        for (let p of neededPresets) log("    " + p.chalkPrint(true));

        log("\n");
      }
    }

    log("Done!");
    this.rules = new Collection(ruleQueue);
    this.presets = new Collection(presetQueue);
    requiredNotifications.delete(undefined);
    this.notifications = new Collection([...requiredNotifications]);
  }

  async log() {
    if (this.notifications.arr.length > 0) {
      log("Required notifications: ");
      this.notifications.log();
    }

    if (this.rules.arr.length > 0) {
      write("Required rules: ");
      log(this.rules.arr.length);
      this.rules.log();
    }

    if (this.presets.arr.length > 0) {
      write("Required presets: ");
      log(this.presets.arr.length);
      this.presets.log();
    }

    if (configObject.rawOutput) {
      return {
        presets: this.presets.arr,
        rules: this.rules.arr,
        notifications: this.notifications.arr
      };
    }
  }

  async deleteTo(env) {
    for (let preset of this.presets) {
      try {
        await preset.deleteRemoteVersion(env);
      } catch (e) {
        log(e);
      }
    }
  }

  async syncTo(env) {
    for (let preset of this.presets) {
      try {
        await preset.save(env);
      } catch (e) {
        log(e);
      }
    }

    if (this.rules.arr[0]) {
      log("Starting create phase for rules");

      for (let rule of this.rules) {
        try {
          await rule.saveA(env);
        } catch (e) {
          log(e);
        }
      }

      log("OK");
      log("Starting link phase for rules");
      Rule.removeCache(env);

      for (let rule of this.rules) {
        try {
          await rule.saveB(env);
        } catch (e) {
          log(e);
        }
      }
    }
  }

}

class User extends RallyBase {
  constructor({
    data,
    remote
  }) {
    super();
    this.data = data;
    this.meta = {};
    this.remote = remote;
  }

  chalkPrint(pad = false) {
    let id = String("U-" + this.id);
    if (pad) id = id.padStart(7);
    return chalk`{green ${id}}: {blue ${this.name}}`;
  }

}

defineAssoc(User, "id", "data.id");
defineAssoc(User, "name", "data.attributes.name");
defineAssoc(User, "email", "data.attributes.email");
defineAssoc(User, "remote", "meta.remote");
User.endpoint = "users";

class Tag extends RallyBase {
  constructor({
    data,
    remote
  } = {}) {
    super();
    this.meta = {};
    this.remote = remote;
    this.data = data; //this.data.attributes.rallyConfiguration = undefined;
    //this.data.attributes.systemManaged = undefined;
  }

  chalkPrint(pad = true) {
    let id = String("T-" + this.remote + "-" + this.id);
    if (pad) id = id.padStart(10);
    let prefix = this.curated ? "blue +" : "red -";
    return chalk`{green ${id}}: {${prefix}${this.name}}`;
  }

  static async create(env, name, {
    notCurated
  } = {}) {
    return new Tag({
      data: await lib.makeAPIRequest({
        env,
        path: `/${this.endpoint}`,
        method: "POST",
        payload: {
          data: {
            attributes: {
              name,
              curated: notCurated ? false : true
            },
            type: "tagNames"
          }
        }
      }),
      remote: env
    });
  }

}

defineAssoc(Tag, "id", "data.id");
defineAssoc(Tag, "attributes", "data.attributes");
defineAssoc(Tag, "relationships", "data.relationships");
defineAssoc(Tag, "name", "data.attributes.name");
defineAssoc(Tag, "curated", "data.attributes.curated");
defineAssoc(Tag, "remote", "meta.remote");
Tag.endpoint = "tagNames";

require("source-map-support").install();
const rallyFunctions = {
  async bestPagintation() {
    global.silentAPI = true;

    for (let i = 10; i <= 30; i += 5) {
      console.time("test with " + i);
      let dl = await lib.indexPathFast("DEV", `/workflowRules?page=1p${i}`);
      console.timeEnd("test with " + i);
    }
  },

  async uploadPresets(env, presets, createFunc = () => false) {
    for (let preset of presets) {
      await preset.uploadCodeToEnv(env, createFunc);
    }
  },

  //Dummy test access
  async testAccess(env) {
    if (lib.isLocalEnv(env)) {
      let repodir = configObject.repodir;

      if (repodir) {
        try {
          fs__default['default'].lstatSync(repodir).isDirectory();
          return true;
        } catch (e) {
          return false;
        }
      } else {
        throw new UnconfiguredEnvError();
      }
    }

    let result = await lib.makeAPIRequest({
      env,
      path: "/providers?page=1p1",
      fullResponse: true,
      timeout: 1000
    });
    return result.statusCode;
  }

};

var allIndexBundle = /*#__PURE__*/Object.freeze({
  __proto__: null,
  rallyFunctions: rallyFunctions,
  SupplyChain: SupplyChain,
  Preset: Preset,
  Rule: Rule,
  Provider: Provider,
  Notification: Notification,
  Asset: Asset,
  User: User,
  Tag: Tag,
  Trace: Trace,
  get configFile () { return configFile; },
  loadConfig: loadConfig,
  loadConfigFromArgs: loadConfigFromArgs,
  setConfig: setConfig,
  get configObject () { return configObject; },
  lib: lib,
  AbortError: AbortError,
  APIError: APIError,
  UnconfiguredEnvError: UnconfiguredEnvError,
  ProtectedEnvError: ProtectedEnvError,
  FileTooLargeError: FileTooLargeError,
  Collection: Collection,
  RallyBase: RallyBase,
  sleep: sleep,
  zip: zip,
  unordered: unordered
});

var version = "2.6.1";

var baseCode = {
  SdviContentMover: `{
    "tasks": [
        {
            "operation": "copy" | "move" | "delete",

            "source": {
                "optional": true | false,

                # must specify either inventory OR externalStorage
                "inventory": {
                    "labels": ["<label>" | "*", ],
                    "tags": ["<tag>", ],
                    "storageSet": ["<storage location name>" | "*", ],    # only valid for move & delete tasks
                    "expandCollections": true | false
                },
                "externalStorage": {
                    "uri": "<protocol>://<host>/<path>/<file>",
                    "credentials": {
                        "key": "<parameter store key>",
                        "roleArn": "<role to assume to access the parameter store>",
                        "roleId": "<external ID to be used in role assumption>",
                        "region": "<AWS region of the parameter store>"
                    }
                }
            },

            "destination": {
                "name": "<path within the storage location>/<filename>",
                "overwrite": "never" | "notInAnyAsset" | "notInOtherAsset" | "always",
                "storageMetadata": {"<key>": "<value>",...} | "<sourceStorageMetadata>",

                # must specify either inventory OR externalStorage
                "inventory": {
                    "storage": "<storage location name>",
                    "newLabel": "<fileLabel>",
                    "newTags": ["<tag>", "<tag>"],
                },
                "externalStorage": {
                    "uri": "<protocol>://<host>",
                    "credentials": {
                        "key": "<parameter store key>",
                        "roleArn": "<role to assume to access the parameter store>",
                        "roleId": "<external ID to be used in role assumption>",
                        "region": "<AWS region of the parameter store>"
                    }
                }
            }
        },

        {
            <another task>
        },

        {
            <another task>
        },

        ...

    ]
}`,
  SdviEvaluate: `'''
name: {name}
'''

# code here`,
  SdviEvalPro: `'''
name: {name}
'''

import rally

def evalMain(context):
    # code here`
};

var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _dec12, _dec13, _dec14, _dec15, _dec16, _dec17, _dec18, _dec19, _dec20, _dec21, _dec22, _dec23, _dec24, _dec25, _dec26, _dec27, _dec28, _dec29, _dec30, _dec31, _dec32, _dec33, _dec34, _dec35, _dec36, _dec37, _dec38, _dec39, _dec40, _dec41, _dec42, _dec43, _dec44, _dec45, _dec46, _dec47, _dec48, _dec49, _dec50, _dec51, _dec52, _dec53, _dec54, _dec55, _dec56, _dec57, _dec58, _dec59, _dec60, _dec61, _obj;

require("source-map-support").install();
let argv = argparse__default['default'](process.argv.slice(2), {
  string: ["file", "env"],
  //boolean: ["no-protect"],
  boolean: ["anon"],
  default: {
    protect: true
  },
  alias: {
    f: "file",
    e: "env"
  }
}); //help menu helper

function printHelp(help, short) {
  let helpText = chalk`
{white ${help.name}}: ${help.text}
    Usage: ${help.usage || "<unknown>"}
`; //Trim newlines

  helpText = helpText.substring(1, helpText.length - 1);

  if (!short) {
    for (let param of help.params || []) {
      helpText += chalk`\n    {blue ${param.param}}: ${param.desc}`;
    }

    for (let arg of help.args || []) {
      helpText += chalk`\n    {blue ${arg.short}}, {blue ${arg.long}}: ${arg.desc}`;
    }
  }

  return helpText;
}

async function getFilesFromArgs(args) {
  let lastArg = args._.shift();

  if (args.file) {
    let files = args.file;
    if (typeof files === "string") files = [files];
    return files;
  }

  if (lastArg == "-") {
    log("Reading from stdin");

    let getStdin = require("get-stdin");

    let stdin = await getStdin();
    let files = stdin.split("\n");
    if (files[files.length - 1] === "") files.pop();
    return files;
  } else {
    args._.push(lastArg);
  }
}

let presetsub = {
  async before(args) {
    this.env = args.env;
    if (!this.env) throw new AbortError("No env supplied");
    this.files = await getFilesFromArgs(args);
  },

  async $grab(args) {
    if (!this.files) {
      throw new AbortError("No files provided to grab (use --file argument)");
    }

    log(chalk`Grabbing {green ${this.files.length}} preset(s) metadata from {green ${this.env}}.`);
    let presets = this.files.map(path => new Preset({
      path,
      remote: false
    }));

    for (let preset of presets) {
      //TODO small refactor
      await preset.grabMetadata(this.env);
      await preset.saveLocalMetadata();

      if (args.full) {
        let remo = await Preset.getByName(this.env, preset.name);
        await remo.resolve();
        await remo.downloadCode();
        await remo.saveLocalFile();
      }
    }
  },

  async $create(args) {
    let provider, name, ext;

    if (args.provider) {
      provider = {
        name: args.provider
      };
      ext = args.ext;
    } else {
      provider = await selectProvider((await Provider.getAll(this.env)));
      ext = (await provider.getEditorConfig()).fileExt;
    }

    if (args.name) {
      name = args.name;
    } else {
      name = await askInput("Preset Name", "What is the preset name?");
    }

    let preset = new Preset({
      subProject: configObject.project
    });
    preset.providerType = {
      name: provider.name
    };
    preset.isGeneric = true;
    preset.name = name;
    preset.ext = ext;

    if (baseCode[provider.name]) {
      preset._code = baseCode[provider.name].replace("{name}", name);
    } else {
      preset._code = " ";
    }

    preset.saveLocalMetadata();
    if (!args["only-metadata"]) preset.saveLocalFile();
  },

  async $list(args) {
    elog("Loading...");
    let presets = await Preset.getAll(this.env);

    if (args.resolve) {
      Provider.getAll(this.env);

      for (let preset of presets) {
        let resolve = await preset.resolve(this.env);

        if (args.attach) {
          let {
            proType
          } = resolve;
          proType.editorConfig.helpText = "";
          preset.meta = { ...preset.meta,
            proType
          };
        }
      }
    }

    if (configObject.rawOutput) return presets;
    log(chalk`{yellow ${presets.length}} presets on {green ${this.env}}.`);
    presets.arr.sort((a, b) => {
      return Number(a.attributes.updatedAt) - Number(b.attributes.updatedAt);
    });

    for (let preset of presets) {
      log(preset.chalkPrint());
    }
  },

  async $upload(args) {
    if (!this.files) {
      throw new AbortError("No files provided to upload (use --file argument)");
    }

    log(chalk`Uploading {green ${this.files.length}} preset(s) to {green ${this.env}}.`);
    let presets = this.files.map(path => new Preset({
      path,
      remote: false
    }));
    await rallyFunctions.uploadPresets(this.env, presets);
  },

  async $deleteRemote(args) {
    let file = this.files[0];

    if (!this.files) {
      throw new AbortError("No files provided to diff (use --file argument)");
    }

    let preset = new Preset({
      path: file,
      remote: false
    });

    if (!preset.name) {
      throw new AbortError(chalk`No preset header found. Cannot get name.`);
    }

    let preset2 = await Preset.getByName(this.env, preset.name);

    if (!preset2) {
      throw new AbortError(chalk`No preset found with name {red ${preset.name}} on {blue ${this.env}}`);
    }

    log(chalk`Deleting ${preset2.chalkPrint(true)}.`);
    log((await preset2.delete()));
  },

  async $diff(args) {
    let file = this.files[0];

    if (!this.files) {
      throw new AbortError("No files provided to diff (use --file argument)");
    }

    let preset = new Preset({
      path: file,
      remote: false
    });

    if (!preset.name) {
      throw new AbortError(chalk`No preset header found. Cannot get name.`);
    }

    let preset2 = await Preset.getByName(this.env, preset.name);

    if (!preset2) {
      throw new AbortError(chalk`No preset found with name {red ${preset.name}} on {blue ${this.env}}`);
    }

    await preset2.downloadCode();

    let tempfile = require("tempy").file;

    let temp = tempfile({
      extension: `${this.env}.${preset.ext}`
    });
    fs.writeFileSync(temp, preset2.code);
    let ptr = `${file},${temp}`; //raw output returns "file1" "file2"

    if (configObject.rawOutput) {
      if (args["only-new"]) return temp;else return ptr;
    } //standard diff


    argv.command = argv.command || "diff";
    await spawn(argv.command, [file, temp], {
      stdio: "inherit"
    });
  },

  async $info(args) {
    if (!this.files) {
      throw new AbortError("No files provided to diff (use --file argument)");
    }

    let file = this.files[0];
    let preset = new Preset({
      path: file,
      remote: false
    });

    if (!preset.name) {
      throw new AbortError(chalk`No preset header found. Cannot get name.`);
    }

    await preset.getInfo(args.env);
  },

  async unknown(arg, args) {
    log(chalk`Unknown action {red ${arg}} try '{white rally help preset}'`);
  }

};
let rulesub = {
  async before(args) {
    this.env = args.env;
    if (!this.env) throw new AbortError("No env supplied");
  },

  async $list(args) {
    elog("Loading...");
    let rules = await Rule.getAll(this.env);
    if (configObject.rawOutput) return rules;
    log(chalk`{yellow ${rules.length}} rules on {green ${this.env}}.`);
    rules.arr.sort((a, b) => {
      return Number(a.data.attributes.updatedAt) - Number(b.data.attributes.updatedAt);
    });

    for (let rule of rules) log(rule.chalkPrint());
  },

  async $create(args) {
    let preset = await selectPreset({
      canSelectNone: false
    });
    let passNext = await selectRule({
      purpose: "'On Exit OK'"
    });
    let errorNext = await selectRule({
      purpose: "'On Exit Error'"
    });
    let name = await askInput("Rule Name", "What is the rule name?");
    name = name.replace("@", preset.name);
    let desc = await askInput("Description", "Enter a description.");
    let dynamicNexts = [];
    let next;

    while (next = await selectRule({
      purpose: "dynamic next"
    })) {
      let name = await askInput("Key", "Key name for dynamic next");
      dynamicNexts.push({
        meta: {
          transition: name
        },
        type: "workflowRules",
        name: next.name
      });
    }

    let rule = new Rule({
      subProject: configObject.project
    });
    rule.name = name;
    rule.description = desc;
    rule.relationships.preset = {
      data: {
        name: preset.name,
        type: "presets"
      }
    };
    if (errorNext) rule.relationships.errorNext = {
      data: {
        name: errorNext.name,
        type: "workflowRules"
      }
    };
    if (passNext) rule.relationships.passNext = {
      data: {
        name: passNext.name,
        type: "workflowRules"
      }
    };

    if (dynamicNexts[0]) {
      rule.relationships.dynamicNexts = {
        data: dynamicNexts
      };
    }

    rule.saveB();
  },

  async unknown(arg, args) {
    log(chalk`Unknown action {red ${arg}} try '{white rally help rule}'`);
  }

};
let jupytersub = {
  async before(args) {
    this.input = args._.shift() || "main.ipynb";
    this.output = args._.shift() || "main.py";
  },

  async $build(args) {
    let cmd = `jupyter nbconvert --to python ${this.input} --TagRemovePreprocessor.remove_cell_tags={\"remove_cell\"} --output ${this.output} --TemplateExporter.exclude_markdown=True --TemplateExporter.exclude_input_prompt=True --TemplateExporter.exclude_output_prompt=True`.split(" ");
    log(chalk`Compiling GCR file {green ${this.input}} into {green ${this.output}} using jupyter...`);

    try {
      let {
        timestr
      } = await spawn(cmd[0], cmd.slice(1));
      log(chalk`Complete in ~{green.bold ${timestr}}.`);
    } catch (e) {
      if (e.code !== "ENOENT") throw e;
      log(chalk`Cannot run the build command. Make sure that you have jupyter notebook installed.\n{green pip install jupyter}`);
      return;
    }
  }

};

async function categorizeString(str, defaultSubproject = undefined) {
  str = str.trim();

  if (str.startsWith('"')) {
    str = str.slice(1, -1);
  }

  if (match = /^(\w)-(\w{1,10})-(\d{1,10}):/.exec(str)) {
    if (match[1] === "P") {
      let ret = await Preset.getById(match[2], match[3]); //TODO modify for subproject a bit

      return ret;
    } else if (match[1] === "R") {
      return await Rule.getById(match[2], match[3]);
    } else {
      return null;
    }
  } else if (match = /^([\w \/\\\-_]*)[\/\\]?silo\-(\w+)[\/\\]/.exec(str)) {
    try {
      switch (match[2]) {
        case "presets":
          return new Preset({
            path: str,
            subProject: match[1]
          });

        case "rules":
          return new Rule({
            path: str,
            subProject: match[1]
          });

        case "metadata":
          return await Preset.fromMetadata(str, match[1]);
      }
    } catch (e) {
      log(e);
    }
  } else {
    return null;
  }
}

let tagsub = {
  async before(args) {
    this.env = args.env;
    if (!this.env) throw new AbortError("No env supplied");
  },

  async $list(args) {
    elog("Loading...");
    let tags = await Tag.getAll(this.env);
    if (configObject.rawOutput) return tags;
    log(chalk`{yellow ${tags.length}} tags on {green ${this.env}}.`);
    tags.arr.sort((a, b) => {
      return Number(a.data.attributes.updatedAt) - Number(b.data.attributes.updatedAt);
    });

    for (let tag of tags) log(tag.chalkPrint());
  },

  async $create(args) {
    return Tag.create(this.env, args._.shift());
  }

};
let supplysub = {
  async before(args) {
    this.env = args.env;
    if (!this.env) throw new AbortError("No env supplied");
    this.files = await getFilesFromArgs(args);
  },

  //Calculate a supply chain based on a starting rule at the top of the stack
  async $calc(args) {
    let name = args._.shift();

    let stopName = args._.shift();

    if (!name) {
      throw new AbortError("No starting rule or @ supplied");
    }

    if (name === "@") {
      log(chalk`Silo clone started`);
      this.chain = new SupplyChain();
      this.chain.remote = args.env;
    } else {
      let rules = await Rule.getAll(this.env);
      let stop, start;
      start = rules.findByNameContains(name);
      if (stopName) stop = rules.findByNameContains(stopName);

      if (!start) {
        throw new AbortError(chalk`No starting rule found by name {blue ${name}}`);
      }

      log(chalk`Analzying supply chain: ${start.chalkPrint(false)} - ${stop ? stop.chalkPrint(false) : "(open)"}`);
      this.chain = new SupplyChain(start, stop);
    }

    await this.chain.calculate();
    return await this.postAction(args);
  },

  async postAction(args) {
    //Now that we ahve a supply chain object, do something with it
    if (args["to"]) {
      this.chain.log();

      if (this.chain.presets.arr[0]) {
        await this.chain.downloadPresetCode(this.chain.presets);
        log("Done");
      }

      if (Array.isArray(args["to"])) {
        for (let to of args["to"]) {
          await this.chain.syncTo(to);
        }
      } else {
        await this.chain.syncTo(args["to"]);
      }
    } else if (args["delete"]) {
      if (Array.isArray(args["delete"])) {
        for (let to of args["delete"]) {
          await this.chain.deleteTo(to);
        }
      } else {
        await this.chain.deleteTo(args["delete"]);
      }
    } else if (args["diff"]) {
      //Very basic diff
      let env = args["diff"];
      await Promise.all(this.chain.presets.arr.map(obj => obj.downloadCode()));
      await Promise.all(this.chain.presets.arr.map(obj => obj.resolve()));
      let otherPresets = await Promise.all(this.chain.presets.arr.map(obj => Preset.getByName(env, obj.name)));
      otherPresets = new Collection(otherPresets.filter(x => x));
      await Promise.all(otherPresets.arr.map(obj => obj.downloadCode()));
      await Promise.all(otherPresets.arr.map(obj => obj.resolve()));

      const printPresets = (preset, otherPreset) => {
        log(preset.chalkPrint(true));

        if (otherPreset.name) {
          log(otherPreset.chalkPrint(true));
        } else {
          log(chalk`{red (None)}`);
        }
      };

      for (let preset of this.chain.presets) {
        let otherPreset = otherPresets.arr.find(x => x.name === preset.name) || {};
        preset.code = preset.code.replace(/[\r\n ]/, "");
        otherPreset.code = (otherPreset.code || "").replace(/[\r\n ]/, "");

        if (preset.code === otherPreset.code) {
          if (!args["ignore-same"]) {
            printPresets(preset, otherPreset);
            log("Code Same");
          }
        } else {
          printPresets(preset, otherPreset);

          if (args["ignore-same"]) {
            log("-------");
          } else {
            log("Code Different");
          }
        }
      }
    } else {
      return await this.chain.log();
    }
  },

  async $make(args) {
    let set = new Set();
    let hints = args.hint ? Array.isArray(args.hint) ? args.hint : [args.hint] : []; //TODO modify for better hinting, and add this elsewhere

    for (let hint of hints) {
      if (hint === "presets-uat") {
        log("got hint");
        await Preset.getAll("UAT");
      }
    }

    for (let file of this.files) {
      set.add((await categorizeString(file)));
    }

    let files = [...set];
    files = files.filter(f => f && !f.missing);
    this.chain = new SupplyChain();
    this.chain.rules = new Collection(files.filter(f => f instanceof Rule));
    this.chain.presets = new Collection(files.filter(f => f instanceof Preset));
    this.chain.notifications = new Collection([]);
    return await this.postAction(args);
  },

  async unknown(arg, args) {
    log(chalk`Unknown action {red ${arg}} try '{white rally help supply}'`);
  }

};

function subCommand(object) {
  object = {
    before() {},

    after() {},

    unknown() {},

    ...object
  };
  return async function (args) {
    //Grab the next arg on the stack, find a function tied to it, and run
    let arg = args._.shift();

    let key = "$" + arg;
    let ret;

    if (object[key]) {
      await object.before(args);
      ret = await object[key](args);
      await object.after(args);
    } else {
      if (arg === undefined) arg = "(None)";
      object.unknown(arg, args);
    }

    return ret;
  };
}

let cli = (_dec = helpText(`Display the help menu`), _dec2 = usage(`rally help [subhelp]`), _dec3 = param("subhelp", "The name of the command to see help for"), _dec4 = helpText("Rally tools jupyter interface. Requires jupyter to be installed."), _dec5 = usage("rally jupyter build [in] [out]"), _dec6 = param("in/out", "input and output file for jupyter. By default main.ipyrb and main.py"), _dec7 = helpText(`Preset related actions`), _dec8 = usage(`rally preset [action] --env <enviornment> --file [file1] --file [file2] ...`), _dec9 = param("action", "The action to perform. Can be upload, diff, list, deleteRemote"), _dec10 = arg("-e", "--env", "The enviornment you wish to perform the action on"), _dec11 = arg("-f", "--file", "A file to act on"), _dec12 = arg("~", "--command", "If the action is diff, this is the command to run instead of diff"), _dec13 = helpText(`Rule related actions`), _dec14 = usage(`rally rule [action] --env [enviornment]`), _dec15 = param("action", "The action to perform. Only list is supported right now"), _dec16 = arg("-e", "--env", "The enviornment you wish to perform the action on"), _dec17 = helpText(`supply chain related actions`), _dec18 = usage(`rally supply [action] [identifier] --env [enviornment] [post actions]`), _dec19 = param("action", "The action to perform. Can be calc or make."), _dec20 = param("identifier", "If the action is calc, then this identifier should be the first rule in the chain. If this is make, then supply '-' to read from stdin"), _dec21 = param("post actions", "The action to perform on the created supply chain. See commands below"), _dec22 = arg("-e", "--env", "(calc only) environment to do the calculation on"), _dec23 = arg("~", "--diff", "(post action) Use as `--diff [env]`. List all files with differences on the given env."), _dec24 = arg("~", "--to", "(post action) Use as `--to [env]`. Upload all objects."), _dec25 = arg("~", "--delete", "(post action) Use as `--delete [env]`. The reverse of uploading. Only presets are supported right now."), _dec26 = helpText(`tags stuff`), _dec27 = usage(`rally tags [action]`), _dec28 = param("action", "The action to perform. Can be list or create."), _dec29 = arg("-e", "--env", "The enviornment you wish to perform the action on"), _dec30 = helpText(`print out some trace info`), _dec31 = usage(`rally trace -e [env] [jobid]`), _dec32 = param("jobid", "a job id like b86d7d90-f0a5-4622-8754-486ca8e9ecbd"), _dec33 = arg("-e", "--env", "The enviornment you wish to perform the action on"), _dec34 = helpText(`List all available providers, or find one by name/id`), _dec35 = usage(`rally providers [identifier] --env [env] --raw`), _dec36 = param("identifier", "Either the name or id of the provider"), _dec37 = arg("-e", "--env", "The enviornment you wish to perform the action on"), _dec38 = arg("~", "--raw", "Raw output of command. If [identifier] is given, then print editorConfig too"), _dec39 = helpText(`Change config for rally tools`), _dec40 = usage("rally config [key] --set [value] --raw"), _dec41 = param("key", chalk`Key you want to edit. For example, {green chalk} or {green api.DEV}`), _dec42 = arg("~", "--set", "If this value is given, no interactive prompt will launch and the config option will change."), _dec43 = arg("~", "--raw", "Raw output of json config"), _dec44 = helpText(`create/modify asset or files inside asset`), _dec45 = usage("rally asset [action] [action...]"), _dec46 = param("action", chalk`Actions are create, delete, launch, addfile, metadata, show, patchMetadata, and launchEvalute, deleteFile, downloadFile, grep, analyze. You can supply multiple actions to chain them.`), _dec47 = arg(`-i`, `--id`, chalk`MOVIE_ID of asset to select`), _dec48 = arg(`-n`, `--name`, chalk`MOVIE_NAME of asset. with {white create}, '{white #}' will be replaced with a uuid. Default is '{white TEST_#}'`), _dec49 = arg(`~`, `--anon`, chalk`Supply this if no asset is needed (used to lauch anonymous workflows)`), _dec50 = arg(`-j`, `--job-name`, chalk`Job name to start (used with launch and launchEvalute)`), _dec51 = arg(`~`, `--init-data`, chalk`Init data to use when launching job. can be string, or {white @path/to/file} for a file`), _dec52 = arg(`~`, `--file-label`, chalk`File label (used with addfile)`), _dec53 = arg(`~`, `--file-uri`, chalk`File s3 uri. Can use multiple uri's for the same label (used with addfile)`), _dec54 = arg(`~`, `--metadata`, chalk`Metadata to use with patchMetadata. Can be string, or {white @path/to/file} for a file. Data must contain a top level key Metadata, or Workflow. Metadata will be pached into METADATA. Workflow will be patched into WORKFLOW_METADATA(not currently available)`), _dec55 = arg(`~`, `--priority`, chalk`set the priority of all launched jobs`), _dec56 = arg(`~`, `--new-name`, chalk`set the new name`), _dec57 = arg(`~`, `--target-env`, chalk`migrate to the env (when using migrate)`), _dec58 = arg(`~`, `--to-folder`, chalk`Folder to download to when using downloadFile. If no folder is given, writes to stdout.`), _dec59 = arg(`~`, `--artifact`, chalk`This is the artifact to grep on. Defaults to trace. Values are "trace", "preset", "result", "error", "output"`), _dec60 = arg(`~`, `--on`, chalk`alias for artifact`), _dec61 = arg(`~`, `--name-only`, chalk`Only show preset name and number of matches when greping`), (_obj = {
  async help(args) {
    let arg = args._.shift();

    if (arg) {
      let help = helpEntries[arg];

      if (!help) {
        log(chalk`No help found for '{red ${arg}}'`);
      } else {
        log(printHelp(helpEntries[arg]));
      }
    } else {
      for (let helpArg in helpEntries) {
        log(printHelp(helpEntries[helpArg], true));
      }
    }
  },

  async jupyter(args) {
    return subCommand(jupytersub)(args);
  },

  //@helpText(`Print input args, for debugging`)
  async printArgs(args) {
    log(args);
  },

  async preset(args) {
    return subCommand(presetsub)(args);
  },

  async rule(args) {
    return subCommand(rulesub)(args);
  },

  async supply(args) {
    return subCommand(supplysub)(args);
  },

  async tag(args) {
    return subCommand(tagsub)(args);
  },

  async trace(args) {
    let jobId = args._.shift();

    if (!jobId) throw new AbortError("No job id");
    if (!args.env) throw new AbortError("no env");

    let ln = args._.shift();

    if (!ln) {
      log("is trace");
      let traceInfo = await parseTrace(args.env, jobId);

      for (let line of traceInfo) {
        if (typeof line == "string") {
          log(chalk.red(line));
        } else {
          printOutLine(line);
        }
      }
    } else {
      log("is ln");
      let {
        renderedPreset
      } = await getInfo(args.env, jobId);
      return findLineInFile(renderedPreset, Number(ln));
    }
  },

  async providers(args) {
    let env = args.env;
    if (!env) return errorLog("No env supplied.");

    let ident = args._.shift();

    let providers = await Provider.getAll(env);

    if (ident) {
      let pro = providers.arr.find(x => x.id == ident || x.name.includes(ident));

      if (!pro) {
        log(chalk`Couldn't find provider by {green ${ident}}`);
      } else {
        log(pro.chalkPrint(false));
        let econfig = await pro.getEditorConfig();

        if (args.raw) {
          return pro;
        } else {
          if (econfig.helpText.length > 100) {
            econfig.helpText = "<too long to display>";
          }

          if (econfig.completions.length > 5) {
            econfig.completions = "<too long to display>";
          }

          log(econfig);
        }
      }
    } else {
      if (args.raw) return providers;

      for (let pro of providers) log(pro.chalkPrint());
    }
  },

  async config(args) {
    let prop = args._.shift();

    let propArray = prop && prop.split("."); //if(!await configHelpers.askQuestion(`Would you like to create a new config file in ${configFile}`)) return;

    let newConfigObject;

    if (!prop) {
      if (configObject.rawOutput) return configObject;
      log("Creating new config");
      newConfigObject = { ...configObject
      };

      for (let helperName in configHelpers) {
        if (helperName.startsWith("$")) {
          newConfigObject = { ...newConfigObject,
            ...(await configHelpers[helperName](false))
          };
        }
      }
    } else {
      log(chalk`Editing option {green ${prop}}`);

      if (args.set) {
        newConfigObject = { ...configObject,
          [prop]: args.set
        };
      } else {
        let ident = "$" + propArray[0];

        if (configHelpers[ident]) {
          newConfigObject = { ...configObject,
            ...(await configHelpers[ident](propArray))
          };
        } else {
          log(chalk`No helper for {red ${ident}}`);
          return;
        }
      }
    }

    newConfigObject.hasConfig = true; //Create readable json and make sure the user is ok with it

    let newConfig = JSON.stringify(newConfigObject, null, 4);
    log(newConfig); //-y or --set will make this not prompt

    if (!args.y && !args.set && !(await askQuestion("Write this config to disk?"))) return;
    fs.writeFileSync(configFile, newConfig, {
      mode: 0o600
    });
    log(chalk`Created file {green ${configFile}}.`);
  },

  async silo() {
    let s = new Silo("UAT");
    await s.grep();
  },

  //@arg(`~`,  `--any`,        chalk`allows grep to grep for any preset/provider, not just sdviEval`)
  async asset(args) {
    function uuid(args) {
      const digits = 16;
      return String(Math.floor(Math.random() * Math.pow(10, digits))).padStart(digits, "0");
    }

    let name = args.name || `TEST_#`;
    let env = args.env;
    let asset;

    let arg = args._.shift();

    if (!arg) {
      throw new AbortError(chalk`Missing arguments: see {white 'rally help asset'}`);
    }

    if (args.anon) {
      args._.unshift(arg);
    } else if (arg == "create") {
      name = name.replace("#", uuid());
      asset = await Asset.createNew(name, env);
    } else {
      args._.unshift(arg);

      if (args.id) {
        asset = Asset.lite(args.id, env);
      } else {
        asset = await Asset.getByName(env, args.name);
      }
    }

    if (!asset && !args.anon) {
      throw new AbortError("No asset found/created");
    }

    let launchArg = 0;
    let fileArg = 0;

    let arrayify = (obj, i) => Array.isArray(obj) ? obj[i] : i == 0 ? obj : undefined;

    function getInitData(args, launchArg) {
      let initData = arrayify(args["init-data"], launchArg);

      if (initData && initData.startsWith("@")) {
        let initDataFile = initData.slice(1);

        if (initDataFile === "-") {
          log(chalk`Reading init data from {grey stdin}`);
          initData = fs.readFileSync(0, "utf-8");
        } else {
          log(chalk`Reading init data from {white ${initData.slice(1)}}`);
          initData = fs.readFileSync(initDataFile, "utf-8");
        }
      }

      return initData;
    }

    while (arg = args._.shift()) {
      if (arg === "launch") {
        let initData = getInitData(args, launchArg);
        let jobName = arrayify(args["job-name"], launchArg);
        let p = await Rule.getByName(env, jobName);

        if (!p) {
          throw new AbortError(`Cannot launch job ${jobName}, does not exist (?)`);
        } else {
          log(chalk`Launching ${p.chalkPrint(false)} on ${asset ? asset.chalkPrint(false) : "(None)"}`);
        }

        if (asset) {
          await asset.startWorkflow(jobName, {
            initData,
            priority: args.priority
          });
        } else {
          await Asset.startAnonWorkflow(env, jobName, {
            initData,
            priority: args.priority
          });
        }

        launchArg++;
      } else if (arg === "launchEvaluate") {
        let initData = getInitData(args, launchArg);
        let jobName = arrayify(args["job-name"], launchArg);
        let jobData;
        let ephemeralEval = false;
        let p;

        if (jobName.startsWith("@")) {
          ephemeralEval = true;
          jobData = fs.readFileSync(jobName.slice(1));
        } else {
          p = await Preset.getByName(env, jobName);

          if (!p) {
            throw new AbortError(`Cannot launch preset ${jobName}, does not exist (?)`);
          } else {
            log(chalk`Launching ${p.chalkPrint(false)} on ${asset ? asset.chalkPrint(false) : "(None)"}`);
          }
        }

        if (ephemeralEval) {
          throw new AbortError("could not start");
        } else {
          await asset.startEvaluate(p.id, initData);
        }

        launchArg++;
      } else if (arg === "addfile") {
        let label = arrayify(args["file-label"], fileArg);
        let uri = arrayify(args["file-uri"], fileArg);

        if (label === undefined || !uri) {
          throw new AbortError("Number of file-label and file-uri does not match");
        }

        await asset.addFile(label, uri);
        log(chalk`Added file ${label}`);
        fileArg++;
      } else if (arg === "delete") {
        await asset.delete();
      } else if (arg === "create") {
        throw new AbortError(`Cannot have more than 1 create/get per asset call`);
      } else if (arg === "show" || arg == "load") {
        if (asset.lite) asset = await Asset.getById(env, asset.id);
        if (arg == "show") log(asset);
      } else if (arg === "metadata" || arg === "md") {
        log((await asset.getMetadata(true)));
      } else if (arg === "migrate") {
        await asset.migrate(args["target-env"]);
      } else if (arg === "patchMetadata") {
        let initData = arrayify(args["metadata"], launchArg);

        if (initData && initData.startsWith("@")) {
          log(chalk`Reading data from {white ${initData.slice(1)}}`);
          initData = fs.readFileSync(initData.slice(1), "utf-8");
        }

        initData = JSON.parse(initData);
        await asset.patchMetadata(initData);
      } else if (arg === "rename") {
        let newName = args["new-name"];
        let oldName = asset.name;
        await asset.rename(newName);
        log(chalk`Rename: {green ${oldName}} -> {green ${newName}}`);
      } else if (arg === "downloadfile" || arg === "downloadFile") {
        let label = arrayify(args["file-label"], fileArg);

        if (!label) {
          throw new AbortError("No label supplied");
        }

        fileArg++;
        await asset.downloadFile(label, args["to-folder"]);
      } else if (arg === "deletefile" || arg === "deleteFile" || arg === "removefile" || arg === "removeFile") {
        let label = arrayify(args["file-label"], fileArg);

        if (!label) {
          throw new AbortError("No label supplied");
        }

        fileArg++;
        let result = await asset.deleteFile(label);

        if (!result) {
          log(`Failed to delete file ${label}`);
        }
      } else if (arg === "grep") {
        await asset.grep(args._.pop(), {
          artifact: args.on || args.artifact || "trace",
          nameOnly: args["name-only"],
          ordering: null
        });
      } else if (arg === "analyze") {
        await asset.analyze();
      } else {
        log(`No usage found for ${arg}`);
      }
    }

    if (configObject.rawOutput && !configObject.script) return asset;
  },

  async checkSegments(args) {
    let asset = args._.shift();

    let res = await lib.makeAPIRequest({
      env: args.env,
      path: `/movies/${asset}/metadata/Metadata`
    });
    let segments = res.data.attributes.metadata.userMetaData.segments.segments;
    let r = segments.reduce((lastSegment, val, ind) => {
      let curSegment = val.startTime;

      if (curSegment < lastSegment) {
        log("bad segment " + (ind + 1));
      }

      return val.endTime;
    }, "00:00:00:00");
  },

  async getJobs(args) {
    let req = await lib.indexPathFast({
      env: args.env,
      path: "/jobs",
      qs: {
        filter: "presetName=DCTC Add Element US Checkin"
      }
    });
    log(req.map(x => x.relationships.asset.data.id).join("\n"));
  },

  async listAssets(args, tag) {
    let req = await lib.indexPathFast({
      env: args.env,
      path: "/assets",
      qs: {
        noRelationships: true,
        sort: "id"
      },
      chunksize: 30
    });

    for (let asset of req) {
      log(asset.id);
    }

    return req;
  },

  async listSegments(args) {
    let f = JSON.parse(fs.readFileSync(args.file, "utf-8"));

    for (let asset of f) {
      var _r$data$attributes$me, _r$data$attributes$me2;

      let r = await lib.makeAPIRequest({
        env: args.env,
        path: `/movies/${asset.id}/metadata/Metadata`
      });
      let segs = (_r$data$attributes$me = r.data.attributes.metadata.userMetaData) === null || _r$data$attributes$me === void 0 ? void 0 : (_r$data$attributes$me2 = _r$data$attributes$me.segments) === null || _r$data$attributes$me2 === void 0 ? void 0 : _r$data$attributes$me2.segments;

      if (segs && segs.length > 1) {
        log(asset.id);
        log(asset.name);
      }
    }
  },

  async test4(args) {
    let things = await lib.indexPathFast({
      env: args.env,
      path: "/assets",
      qs: {
        filter: `createdBefore=${Date.now() - 1000 * 160 * 24 * 60 * 60},createdSince=${Date.now() - 1000 * 170 * 24 * 60 * 60}`
      }
    });
    log(JSON.stringify(things, null, 4));
  },

  async test5(args) {
    let things = await lib.indexPathFast({
      env: args.env,
      path: "/jobs",
      qs: {
        filter: `state=Queued,presetName=E2 P4101 - DNE Compliance Edit - US Output Deal - Edit WorkOrder`
      }
    });
    log(JSON.stringify(things, null, 4));
  },

  async test2(args) {
    let wfr = await lib.indexPath({
      env: args.env,
      path: "/workflowRuleMetadata"
    });
    log(wfr);

    for (let wfrm of wfr) {
      try {
        wfrm.id = undefined;
        wfrm.links = undefined;
        log(wfrm);
        let req = await lib.makeAPIRequest({
          env: "DEV",
          path: "/workflowRuleMetadata",
          method: "POST",
          payload: {
            data: wfrm
          }
        });
      } catch (e) {
        log("caught");
      } //break;

    }
  },

  async test3(args) {
    let wfr = await lib.indexPath({
      env: args.env,
      path: "/workflowRuleMetadata"
    });
    log(wfr);

    for (let wfrm of wfr) {
      try {
        wfrm.id = undefined;
        wfrm.links = undefined;
        log(wfrm);
        let req = await lib.makeAPIRequest({
          env: "DEV",
          path: "/workflowRuleMetadata",
          method: "POST",
          payload: {
            data: wfrm
          }
        });
      } catch (e) {
        log("caught");
      } //break;

    }
  },

  async deleteOmneons(args) {
    let id = args._.shift();

    let asset;

    if (Number(id)) {
      asset = await Asset.getById("PROD", Number(id));
    } else {
      asset = await Asset.getByName("PROD", id);
    }

    log(asset);
    let f = await asset.getFiles();

    for (let file of f) {
      if (file.label.includes("Omneon")) {
        log(`removing ${file.label}`);
        await file.delete();
      }
    }
  },

  async audit(args) {
    let supportedAudits = ["presets", "rule", "other"];
    await addAutoCompletePrompt();
    let q = await inquirer.prompt([{
      type: "autocomplete",
      name: "obj",
      message: `What audit do you want?`,
      source: async (sofar, input) => {
        return supportedAudits.filter(x => input ? x.includes(input.toLowerCase()) : true);
      }
    }]);
    let choice = q.obj;
    let resourceId = undefined;

    let filterFunc = _ => _;

    if (choice === "presets") {
      let preset = await selectPreset({
        canSelectNone: false
      });
      let remote = await Preset.getByName(args.env, preset.name);
      if (!remote) throw new AbortError("Could not find this item on remote env");

      filterFunc = ev => ev.resource == "Preset";

      resourceId = remote.id;
    } else if (choice === "rule") {
      let preset = await selectRule({
        canSelectNone: false
      });
      let remote = await Rule.getByName(args.env, preset.name);
      if (!remote) throw new AbortError("Could not find this item on remote env");

      filterFunc = ev => ev.resource == "Rule";

      resourceId = remote.id;
    } else {
      resourceId = await askInput(null, "What resourceID?");
    }

    log(chalk`Resource ID on {blue ${args.env}} is {yellow ${resourceId}}`);
    elog(`Loading audits (this might take a while)`);
    const numRows = 100;
    let r = await lib.makeAPIRequest({
      env: args.env,
      path: `/v1.0/audit?perPage=${numRows}&count=${numRows}&filter=%7B%22resourceId%22%3A%22${resourceId}%22%7D&autoload=false&pageNum=1&include=`,
      timeout: 180000
    });
    r.data = r.data.filter(filterFunc);
    log("Data recieved, parsing users");

    for (let event of r.data) {
      var _event$correlation;

      let uid = event === null || event === void 0 ? void 0 : (_event$correlation = event.correlation) === null || _event$correlation === void 0 ? void 0 : _event$correlation.userId;
      if (!uid) continue;

      try {
        event.user = await User.getById(args.env, uid);
      } catch (e) {
        event.user = {
          name: "????"
        };
      }
    }

    if (args.raw) return r.data;
    let evCounter = 0;

    for (let event of r.data) {
      var _event$user;

      let evtime = moment__default['default'](event.createdAt);
      let date = evtime.format("ddd YYYY/MM/DD hh:mm:ssa");
      let timedist = evtime.fromNow();
      log(chalk`${date} {yellow ${timedist}} {green ${(_event$user = event.user) === null || _event$user === void 0 ? void 0 : _event$user.name}} ${event.event}`);
      if (++evCounter >= 30) break;
    }
  },

  async audit2(args) {
    const numRows = 1000;
    let r = await lib.makeAPIRequest({
      env: args.env,
      //path: `/v1.0/audit?perPage=${numRows}&count=${numRows}&autoload=false&pageNum=1&include=`,
      path: `/v1.0/audit?perPage=${numRows}&count=${numRows}&filter=%7B%22correlation.userId%22%3A%5B%22164%22%5D%7D&autoload=false&pageNum=1&include=`,
      timeout: 60000
    });

    for (let event of r.data) {
      log(event.event);
    }
  },

  async findIDs(args) {
    let files = await getFilesFromArgs(args);

    for (let file of files) {
      let preset = await Preset.getByName(args.env, file);
      await preset.resolve();
      log(`silo-presets/${file}.${preset.ext}`);
    }
  },

  async getAssets(env, name) {
    if (!this.callid) this.callid = 0;
    this.callid++;
    let callid = this.callid;
    await sleep(500);
    if (callid != this.callid) return this.lastResult || [];
    let req = await lib.makeAPIRequest({
      env,
      path: `/assets`,
      qs: name ? {
        filter: `nameContains=${name}`
      } : undefined
    });
    this.lastCall = Date.now();
    return this.lastResult = req.data;
  },

  async content(args) {
    addAutoCompletePrompt();
    let q = await inquirer.prompt([{
      type: "autocomplete",
      name: "what",
      message: `What asset do you want?`,
      source: async (sofar, input) => {
        let assets = await this.getAssets(args.env, input);
        assets = assets.map(x => new Asset({
          data: x,
          remote: args.env
        }));
        return assets.map(x => ({
          name: x.chalkPrint(true) + ": " + x.data.links.self.replace("/api/v2/assets/", "/content/"),
          value: x
        }));
      }
    }]);
  },

  async ["@"](args) {
    args._.unshift("-");

    args._.unshift("make");

    return this.supply(args);
  },

  async test(args) {
    let asset = await Asset.getByName("UAT", args.name);
    log(asset);
  },

  //Used to test startup and teardown speed.
  noop() {
    return true;
  }

}, (_applyDecoratedDescriptor(_obj, "help", [_dec, _dec2, _dec3], Object.getOwnPropertyDescriptor(_obj, "help"), _obj), _applyDecoratedDescriptor(_obj, "jupyter", [_dec4, _dec5, _dec6], Object.getOwnPropertyDescriptor(_obj, "jupyter"), _obj), _applyDecoratedDescriptor(_obj, "preset", [_dec7, _dec8, _dec9, _dec10, _dec11, _dec12], Object.getOwnPropertyDescriptor(_obj, "preset"), _obj), _applyDecoratedDescriptor(_obj, "rule", [_dec13, _dec14, _dec15, _dec16], Object.getOwnPropertyDescriptor(_obj, "rule"), _obj), _applyDecoratedDescriptor(_obj, "supply", [_dec17, _dec18, _dec19, _dec20, _dec21, _dec22, _dec23, _dec24, _dec25], Object.getOwnPropertyDescriptor(_obj, "supply"), _obj), _applyDecoratedDescriptor(_obj, "tag", [_dec26, _dec27, _dec28, _dec29], Object.getOwnPropertyDescriptor(_obj, "tag"), _obj), _applyDecoratedDescriptor(_obj, "trace", [_dec30, _dec31, _dec32, _dec33], Object.getOwnPropertyDescriptor(_obj, "trace"), _obj), _applyDecoratedDescriptor(_obj, "providers", [_dec34, _dec35, _dec36, _dec37, _dec38], Object.getOwnPropertyDescriptor(_obj, "providers"), _obj), _applyDecoratedDescriptor(_obj, "config", [_dec39, _dec40, _dec41, _dec42, _dec43], Object.getOwnPropertyDescriptor(_obj, "config"), _obj), _applyDecoratedDescriptor(_obj, "asset", [_dec44, _dec45, _dec46, _dec47, _dec48, _dec49, _dec50, _dec51, _dec52, _dec53, _dec54, _dec55, _dec56, _dec57, _dec58, _dec59, _dec60, _dec61], Object.getOwnPropertyDescriptor(_obj, "asset"), _obj)), _obj));

async function unknownCommand(cmd) {
  log(chalk`Unknown command {red ${cmd}}.`);
}

async function noCommand() {
  write(chalk`Rally Tools {yellow v${version}} CLI\n`); //Prompt users to setup one time config.

  if (!configObject.hasConfig) {
    write(chalk`
It looks like you haven't setup the config yet. Please run '{green rally config}'.
`);
    return;
  }

  let envs = new Set(["LOCAL", "UAT", "DEV", "PROD", "QA", ...Object.keys(configObject.api)]);
  let proms = [];

  for (let env of envs) {
    proms.push({
      env,
      prom: rallyFunctions.testAccess(env)
    });
  } //API Access tests


  for (let {
    env,
    prom
  } of proms) {
    //Test access. Returns HTTP response code
    let resultStr;

    try {
      let result = await prom; //Create a colored display and response

      resultStr = chalk`{yellow ${result} <unknown>}`;
      if (result === 200) resultStr = chalk`{green 200 OK}`;else if (result === 401) resultStr = chalk`{red 401 No Access}`;else if (result >= 500) resultStr = chalk`{yellow ${result} API Down?}`;else if (result === true) resultStr = chalk`{green OK}`;else if (result === false) resultStr = chalk`{red BAD}`;
    } catch (e) {
      if (e instanceof UnconfiguredEnvError) {
        resultStr = chalk`{yellow Unconfigured}`;
      } else if (e instanceof APIError) {
        if (!e.response.body) {
          resultStr = chalk`{red Timeout (?)}`;
        }
      } else if (e.name == "RequestError") {
        resultStr = chalk`{red Low level error (check internet): ${e.error.errno}}`;
      } else {
        resultStr = chalk`{red Internal Error: (oh no!)}`;
      }
    }

    log(chalk`   ${env}: ${resultStr}`);
  }
}

async function $main() {
  //Supply --config to load a different config file
  if (typeof argv.config === "string") {
    loadConfig(argv.config);
  } else if (typeof argv.config === "object") {
    loadConfigFromArgs(argv);
  } else {
    loadConfig();
  } // First we need to decide if the user wants color or not. If they do want
  // color, we need to make sure we use the right mode


  chalk.enabled = configObject.hasConfig ? configObject.chalk : true;

  if (chalk.level === 0 || !chalk.enabled) {
    let force = argv["force-color"];

    if (force) {
      chalk.enabled = true;

      if (force === true && chalk.level === 0) {
        chalk.level = 1;
      } else if (Number(force)) {
        chalk.level = Number(force);
      }
    }
  } //This flag being true allows you to modify UAT and PROD


  if (!argv["protect"]) {
    configObject.dangerModify = true;
  } //This enables raw output for some functions


  if (argv["raw"]) {
    configObject.rawOutput = true;

    global.log = () => {};

    global.errorLog = () => {};

    global.write = () => {};
  }

  if (argv["script"]) {
    configObject.script = true;
  }

  if (argv["ignore-missing"]) {
    configObject.ignoreMissing = true;
  }

  if (argv["update-immutable"]) {
    configObject.updateImmutable = true;
  }

  if (argv["skip-header"]) {
    configObject.skipHeader = true;
  }

  configObject.globalProgress = argv["show-progress"] || false; //Default enviornment should normally be from config, but it can be
  //overridden by the -e/--env flag

  if (configObject.defaultEnv) {
    argv.env = argv.env || configObject.defaultEnv;
  } //Enable verbose logging in some places.


  if (argv["vverbose"]) {
    configObject.verbose = argv["vverbose"];
    configObject.vverbose = true;
  } else if (argv["verbose"]) {
    configObject.verbose = argv["verbose"];
  } else if (argv["vvverbose"]) {
    configObject.verbose = true;
    configObject.vverbose = true;
    configObject.vvverbose = true;
  } //copy argument array to new object to allow modification


  argv._old = argv._.slice(); //Take first argument after `node bundle.js`
  //If there is no argument, display the default version info and API access.

  let func = argv._.shift();

  if (func) {
    if (!cli[func]) return await unknownCommand(func);

    try {
      //Call the cli function
      let ret = await cli[func](argv);

      if (ret) {
        write(chalk.white("CLI returned: "));
        if (ret instanceof Collection) ret = ret.arr; //Directly use console.log so that --raw works as intended.

        if (typeof ret === "object") {
          console.log(JSON.stringify(ret, null, 4));
        } else {
          console.log(ret);
        }
      }
    } catch (e) {
      if (e instanceof AbortError) {
        log(chalk`{red CLI Aborted}: ${e.message}`);
        process.exit(1);
      } else {
        throw e;
      }
    }
  } else {
    await noCommand();
  }

  process.exit(0);
}

async function main(...args) {
  //Catch all for errors to avoid ugly default node promise catcher
  try {
    await $main(...args);
  } catch (e) {
    errorLog(e.stack);
    process.exit(1);
  }
} // If this is an imported module, then we should exec the cli interface.
// Oterwise just export everything.


if (require.main === module) {
  main();
} else {
  loadConfig();
  module.exports = allIndexBundle;
}
//# sourceMappingURL=bundle.js.map

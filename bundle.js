#!/usr/bin/env node
/* Generated by rollup. Written by John Schmidt */
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var os = require('os');
var fs = require('fs');
var fs__default = _interopDefault(fs);
var rp = _interopDefault(require('request-promise'));
var chalk$1 = _interopDefault(require('chalk'));
var path = require('path');
var inquirer = _interopDefault(require('inquirer'));
var argparse = _interopDefault(require('minimist'));

let configFile = os.homedir() + "/.rallyconfig";

let configObject = null;
try {
    let json = fs.readFileSync(configFile);
    configObject = JSON.parse(json);
} catch (e) {
    if (e.code == "ENOENT") ; else {
        throw e;
    }
}

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

global.chalk = chalk$1;
global.log = text => console.log(text);
global.write = text => process.stdout.write(text);
global.errorLog = text => log(chalk$1.red(text));

let lib = class lib {
    static async makeAPIRequest({ env, path: path$$1, path_full, payload, body, json = true, method = "GET", qs, headers = {}, fullResponse = false }) {
        //Keys are defined in enviornment variables
        let config = configObject.api[env];
        if (!config) {
            return false;
        }
        let rally_api_key = config.key;
        let rally_api = config.url;

        path$$1 = path_full || rally_api + path$$1;
        body = body || payload && JSON.stringify(payload);

        if (global.logAPI) {
            log(chalk$1`${method} @ ${path$$1}`);
            if (qs) {
                log(qs);
            }
        }
        if (payload) {
            headers["Content-Type"] = "application/vnd.api+json";
        }

        let requestOptions = {
            method, body, qs, uri: path$$1,
            auth: { bearer: rally_api_key },
            headers: _extends({
                Accept: "application/vnd.api+json"
            }, headers),
            simple: false, resolveWithFullResponse: true
        };
        let response = await rp(requestOptions);

        if (!fullResponse && ![200, 201, 204].includes(response.statusCode)) {
            throw new APIError(response, requestOptions);
        }
        if (fullResponse) {
            return response;
        } else if (json) {
            return JSON.parse(response.body);
        } else {
            return response.body;
        }
    }
    //Index a json endpoint that returns a {links} field.
    static async indexPath(env, path$$1) {
        let all = [];

        let json = await this.makeAPIRequest({ env, path: path$$1 });

        let [numPages, pageSize] = this.numPages(json.links.last);
        //log(`num pages: ${numPages} * ${pageSize}`);

        all = [...json.data];
        while (json.links.next) {
            json = await this.makeAPIRequest({ env, path_full: json.links.next });
            all = [...all, ...json.data];
        }

        return all;
    }

    //Returns number of pages and pagination size
    static numPages(str) {
        return (/page=(\d+)p(\d+)/.exec(str).slice(1)
        );
    }

    //Index a json endpoint that returns a {links} field.
    //
    //This function is faster than indexPath because it can guess the pages it
    //needs to retreive so that it can request all assets at once.
    //
    //This function assumes that the content from the inital request is the
    //first page, so starting on another page may cause issues. Consider
    //indexPath for that.
    static async indexPathFast(env, path$$1) {
        let all = [];

        let json = await this.makeAPIRequest({ env, path: path$$1 });
        let baselink = json.links.first;
        const linkToPage = page => baselink.replace("page=1p", `page=${page}p`);

        let [numPages, pageSize] = this.numPages(json.links.last);
        //log(`num pages: ${numPages} * ${pageSize}`);

        //Construct an array of all the requests that are done simultanously.
        //Assume that the content from the inital request is the first page.
        let promises = [Promise.resolve(json)];
        for (let i = 2; i <= numPages; i++) {
            let req = this.makeAPIRequest({ env, path_full: linkToPage(i) });
            promises.push(req);
        }

        for (let promise of promises) {
            all = [...all, ...(await promise).data];
        }

        return all;
    }
};
let AbortError = class AbortError extends Error {
    constructor(message) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.name = "AbortError";
    }
};

let APIError = class APIError extends Error {
    constructor(response, opts) {
        super(chalk$1`
{reset Request returned} {yellow ${response.statusCode}}
{green ${JSON.stringify(opts)}}
{reset ${response.body}}
        `);
        Error.captureStackTrace(this, this.constructor);
        this.name = "ApiError";
    }
};

let helpEntries = {};
let helpEntry = name => helpEntries[name] ? helpEntries[name] : helpEntries[name] = { name };

function helpText(text) {
    return function (func, name) {
        helpEntry(name).text = text;
        return func;
    };
}
function arg(long, short, desc) {
    return function (func, name) {
        let args = helpEntry(name).args = helpEntry(name).args || [];
        args.unshift({ long, short, desc });
        return func;
    };
}
function param(param, desc) {
    return function (func, name) {
        let params = helpEntry(name).params = helpEntry(name).params || [];
        params.unshift({ param, desc });
        return func;
    };
}
function usage(usage) {
    return function (func, name) {
        usage = usage.replace(/[\[<](\w+)[\]>]/g, chalk`[{blue $1}]`);
        helpEntry(name).usage = usage;
        return func;
    };
}

function findValueInCache(args, cache) {
    for (let [argsKey, value] of cache) {
        if (args.length !== argsKey.length) continue;
        for (let i in argsKey) {
            if (args[i] === argsKey[i]) {
                return { found: true, value };
            }
        }
    }
    return { found: false };
}

//This decorator takes a function and returns a function that remembers the
//  value returned by given arguments
function cached(target, key, desc) {
    let oldFunc = desc.value;
    let cachedValues = [];
    function newFunc(...args) {
        let { found, value } = findValueInCache(args, cachedValues);
        if (!found) {
            //Call the old function to find the value, then store it in the cache
            value = oldFunc(...args);
            cachedValues.push([args, value]);
        }
        return value;
    }
    newFunc.clearCache = function () {
        cachedValues = [];
    };

    return _extends({}, desc, {
        value: newFunc
    });
}

let envs = {};
let Preset = class Preset {
    constructor({ path: path$$1, remote, data }) {
        this.remote = remote;
        if (!this.remote) {
            this.path = path$$1;
            try {
                this.code = this.getLocalCode();
            } catch (e) {
                log(chalk`{red Node Error} e.message`);
                throw new AbortError("Could not load code of local file");
            }
            this.name = this.parseFilenameForName() || this.parseCodeForName();
        } else {
            this.name = data.attributes.name;
            this.id = data.id;
            this.rawData = data;
        }
    }
    chalkPrint() {
        let id = String(this.remote && this.remote + "-" + this.id || "Local").padStart(8);
        return chalk`{green ${id}}: {blue ${this.name}}`;
    }
    parseFilenameForName() {
        if (this.path.endsWith(".jinja") || this.path.endsWith(".json")) {
            return path.basename(this.path).replace("_", " ").replace("-", " ");
        }
    }
    parseCodeForName() {
        const name_regex = /name:\s([\w\d. \/]+)[\r\s\n]*?/;
        const match = name_regex.exec(this.code);
        if (match) return match[1];
    }
    findStringsInCode(strings) {
        if (!this.code) return [];

        return strings.filter(str => {
            let regex = new Regexp(str);
            return !!this.code.match(regex);
        });
    }
    getPath() {
        return `${process.env.rally_repo_path}/silo-presets/${this.name}.${this.ext}`;
    }
    getMetadataPath() {
        return `${process.env.rally_repo_path}/silo-metadata/${this.name}.json`;
    }
    codeBinary() {
        if (this.code.startsWith("=BASE64=")) {
            return bota(this.code.substring(8));
        } else {
            return this.code;
        }
    }
    async uploadPresetData(env, id) {
        let res = await lib.makeAPIRequest({
            env, path: `/presets/${id}/providerData`,
            body: this.code, method: "PUT", fullResponse: true
        });
        write(chalk`response {yellow ${res.statusCode}}`);
    }
    async uploadCodeToEnv(env, createFunction) {
        write(chalk`Uploading {green ${this.name}} to {green ${env}}: `);

        //First query the api to see if this already exists.
        let res = await lib.makeAPIRequest({
            env, path: `/presets`,
            qs: { filter: `name=${this.name}` }
        });
        let remote = res.data[0];

        if (remote) {
            //If it exists we can replace it
            write("replace, ");
            await this.uploadPresetData(env, remote.id);
        } else {
            //If it needs to be created then we need to ask the user for metadata
            write("create, ");
            let metadata = await createFunction(this);
            write("Posting to create preset... ");
            let res = await lib.makeAPIRequest({
                env, path: `/presets`, method: "POST",
                payload: { data: metadata }
            });
            let id = res.data.id;
            write(chalk`Created id {green ${id}}... Uploading Code... `);
            await this.uploadPresetData(env, id);
        }
        log();
    }

    constructMetadata(providerID) {
        return {
            attributes: {
                name: this.name
                //providerSettings: {
                //},
            },
            relationships: {
                providerType: {
                    data: {
                        id: providerID,
                        type: "providerTypes"
                    }
                }
            },
            type: "presets"
        };
    }

    getMetadata() {}
    getLocalCode() {
        return fs__default.readFileSync(this.path, "utf-8");
    }

    static envs(env) {
        return envs[env] = envs[env] || Preset.cache_envs(env);
    }
    static cache_env(env) {}
};

let Rule = class Rule {
    constructor(data, remote) {
        this.rawData = data;
        this.remote = remote;
    }
    chalkPrint() {
        let D = this.rawData;
        let id = String(this.remote + "-" + D.id).padStart(8);
        return chalk`{green ${id}}: {blue ${D.attributes.name}}`;
    }
};

var _obj;

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function (key) {
        desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
        desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
        return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
        Object['define' + 'Property'](target, property, desc);
        desc = null;
    }

    return desc;
}

const rallyFunctions = (_obj = {
    async bestPagintation() {
        global.silentAPI = true;
        for (let i = 10; i <= 30; i += 5) {
            console.time("test with " + i);
            let dl = await lib.indexPathFast("DEV", `/workflowRules?page=1p${i}`);
            console.timeEnd("test with " + i);
        }
    },
    async uploadPresets(env, presets, createFunc = () => false) {
        for (let preset of presets) {
            await preset.uploadCodeToEnv(env, createFunc);
        }
    },
    async getProviders(env) {
        let providers = await lib.indexPath(env, "/providerTypes?page=1p50");
        providers = providers.sort((a, b) => {
            return a.attributes.category.localeCompare(b.attributes.category) || a.attributes.name.localeCompare(b.attributes.name);
        });
        return providers;
    },
    async getEditorConfig(env, provider) {
        let config = await lib.makeAPIRequest({ env, path_full: provider.links.editorConfig });
        let helpText$$1 = config.helpText;
        config.helpText = () => helpText$$1;
        return config;
    },
    async getRules(env) {
        let rules = await lib.indexPathFast(env, "/workflowRules?page=1p20");
        return rules;
    },
    async getPresets(env) {
        let rules = await lib.indexPathFast(env, "/presets?page=1p20");
        return rules;
    },
    //Dummy test access
    async testAccess(env) {
        let result = await lib.makeAPIRequest({ env, path: "/providers?page=1p1", fullResponse: true });
        if (!result) return 401;
        return result.statusCode;
    }
}, (_applyDecoratedDescriptor(_obj, "getProviders", [cached], Object.getOwnPropertyDescriptor(_obj, "getProviders"), _obj), _applyDecoratedDescriptor(_obj, "getRules", [cached], Object.getOwnPropertyDescriptor(_obj, "getRules"), _obj), _applyDecoratedDescriptor(_obj, "getPresets", [cached], Object.getOwnPropertyDescriptor(_obj, "getPresets"), _obj)), _obj);

var version = "1.2.1";

async function $api(propArray) {
    const defaults$$1 = {
        DEV: "https://discovery-dev.sdvi.com/api/v2",
        UAT: "https://discovery-uat.sdvi.com/api/v2",
        PROD: "https://discovery.sdvi.com/api/v2"
    };

    let q;
    if (propArray && propArray[1]) {
        q = { envs: [propArray[1]] };
    } else {
        //Create a checkbox prompt to choose enviornments
        q = await inquirer.prompt([{
            type: "checkbox",
            name: "envs",
            message: `What enviornments would you like to configure?`,
            choices: Object.keys(defaults$$1).map(name => ({ name, checked: true }))
        }]);
    }

    //Each env should ask 2 for two things: The url and the key.
    let questions = q.envs.map(env => {
        let defaultKey = process.env[`rally_api_key_${env}`];
        if (configObject && configObject.api && configObject.api[env]) {
            defaultKey = configObject.api[env].key;
        }

        return [{
            type: "input",
            name: `api.${env}.url`,
            message: `What is the url endpoint for ${env}`,
            default: defaults$$1[env]
        }, {
            type: "input",
            name: `api.${env}.key`,
            message: `What is your api key for ${env}`,
            default: defaultKey
        }];
    });

    //flatten and ask
    questions = [].concat(...questions);
    q = await inquirer.prompt(questions);
    if (propArray) {
        q.api = _extends({}, configObject.api, q.api);
    }
    return q;
}
async function $chalk(propArray) {
    return { chalk: await askQuestion("Would you like chalk enabled (for coloring)?") };
}

//Internal usage/testing
async function selectProvider(env, providers) {
    let defaultProvider = providers.find(x => x.attributes.name === "SdviEvaluate");
    if (args.defaultSelect) {
        return defaultProvider;
    } else {
        let q = await inquirer.prompt([{
            type: "list",
            name: "provider",
            default: defaultProvider,
            choices: providers.map(x => ({
                name: prettyPrintProvider(x),
                value: x
            }))
        }]);
        return q.provider;
    }
}

async function askQuestion(question) {
    return (await inquirer.prompt([{
        type: "confirm",
        name: "ok",
        message: question
    }])).ok;
}

var configHelpers = /*#__PURE__*/Object.freeze({
    $api: $api,
    $chalk: $chalk,
    selectProvider: selectProvider,
    askQuestion: askQuestion
});

var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _dec12, _dec13, _dec14, _dec15, _dec16, _dec17, _dec18, _dec19, _obj$1;

function _applyDecoratedDescriptor$1(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function (key) {
        desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
        desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
        return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
        Object['define' + 'Property'](target, property, desc);
        desc = null;
    }

    return desc;
}

require("source-map-support").install();

let argv = argparse(process.argv.slice(2), {
    string: ["file", "env"],
    alias: {
        f: "file", e: "env"
    }
});

function prettyPrintProvider$1(pro) {
    let id = String(pro.id).padStart(4);
    return chalk`{green ${id}}: {blue ${pro.attributes.category}} - {green ${pro.attributes.name}}`;
}

function printHelp(help, short) {
    let helpText$$1 = chalk`
{white ${help.name}}: ${help.text}
    Usage: ${help.usage || "<unknown>"}
`;
    //Trim newlines
    helpText$$1 = helpText$$1.substring(1, helpText$$1.length - 1);

    if (!short) {
        for (let param$$1 of help.params || []) {
            helpText$$1 += chalk`\n    {blue ${param$$1.param}}: ${param$$1.desc}`;
        }
        for (let arg$$1 of help.args || []) {
            helpText$$1 += chalk`\n    {blue ${arg$$1.short}}, {blue ${arg$$1.long}}: ${arg$$1.desc}`;
        }
    }

    return helpText$$1;
}

let cli = (_dec = helpText(`Display the help menu`), _dec2 = usage(`rally help [subhelp]`), _dec3 = param("subhelp", "The name of the command to see help for"), _dec4 = helpText(`Preset related actions`), _dec5 = usage(`rally preset [action] --env <enviornment> --file [file1] --file [file2] ...`), _dec6 = param("action", "The action to perform. Can be upload or list"), _dec7 = arg("-e", "--env", "The enviornment you wish to perform the action on"), _dec8 = arg("-f", "--file", "A file to act on"), _dec9 = helpText(`Rule related actions`), _dec10 = usage(`rally rule [action] --env [enviornment]`), _dec11 = param("action", "The action to perform. Only list is supported right now"), _dec12 = arg("-e", "--env", "The enviornment you wish to perform the action on"), _dec13 = helpText(`List all available providers, or find one by name/id`), _dec14 = usage(`rally providers [identifier] --env [env]`), _dec15 = param("identifier", "Either the name or id of the provider"), _dec16 = arg("-e", "--env", "The enviornment you wish to perform the action on"), _dec17 = helpText(`Change config for rally tools`), _dec18 = usage("rally config [key]"), _dec19 = param("key", chalk`Key you want to edit. For example, {green chalk} or {green api.DEV}`), (_obj$1 = {
    async help() {
        let arg$$1 = argv._[1];
        if (arg$$1) {
            log(printHelp(helpEntries[arg$$1]));
        } else {
            for (let helpArg in helpEntries) {
                log(printHelp(helpEntries[helpArg], true));
            }
        }
    },

    //@helpText(`Print input args, for debugging`)
    async printArgs(args) {
        log(args);
    },

    async preset(args) {
        let env = args.env;
        if (!env) return errorLog("No env supplied.");
        let arg$$1 = argv._[1];
        if (arg$$1 === "upload") {
            let files = args.file;
            if (!files) {
                throw new AbortError("No files provided to upload (use --file argument)");
            }
            if (typeof files === "string") files = [files];
            log(chalk`Uploading {green ${files.length}} preset(s) to {green ${env}}.`);

            let presets = files.map(path$$1 => new Preset({ path: path$$1, remote: false }));
            await rallyFunctions.uploadPresets(args.env, presets, async preset => {
                log("asking... ");
                let providers = await rallyFunctions.getProviders(env);
                let provider = await selectProvider(env, providers);
                return preset.constructMetadata(provider.id);
            });
        } else if (arg$$1 === "list") {
            log("Loading...");
            let presets = await rallyFunctions.getPresets(env);
            log(chalk`{yellow ${presets.length}} presets on {green ${env}}.`);
            for (let data of presets) log(new Preset({ data, remote: env }).chalkPrint());
        } else {
            log(chalk`Unknown action {red ${arg$$1}} try '{white rally help preset}'`);
        }
        //log(presets);
    },

    async rule(args) {
        let env = args.env;
        if (!env) return errorLog("No env supplied.");
        let arg$$1 = argv._[1];

        if (arg$$1 === "list") {
            log("Loading...");
            let rules = await rallyFunctions.getRules(env);
            log(chalk`{yellow ${rules.length}} rules on {green ${env}}.`);
            for (let data of rules) log(new Rule(data, env).chalkPrint());
        } else {
            log(chalk`Unknown action {red ${arg$$1}} try '{white rally help rule}'`);
        }
    },

    async providers(args) {
        let env = args.env;
        if (!env) return errorLog("No env supplied.");
        let ident = argv._[1];

        let providers = await rallyFunctions.getProviders(env);

        if (ident) {
            let pro = providers.find(x => x.id == ident || x.attributes.name.includes(ident));
            if (!pro) {
                log(chalk`Couldn't find provider by {green ${ident}}`);
            } else {
                log(prettyPrintProvider$1(pro));
                log((await rallyFunctions.getEditorConfig(env, pro)));
            }
        } else {
            for (let pro of providers) log(prettyPrintProvider$1(pro));
        }
    },

    async config(args) {
        let prop = argv._[1];
        let propArray = prop && prop.split(".");

        //if(!await configHelpers.askQuestion(`Would you like to create a new config file in ${configFile}`)) return;
        let newConfigObject;

        if (!prop) {
            log("Creating new config");
            newConfigObject = _extends({}, configObject);
            for (let helperName in configHelpers) {
                if (helperName.startsWith("$")) {
                    newConfigObject = _extends({}, newConfigObject, (await configHelpers[helperName](false)));
                }
            }
        } else {
            log(chalk`Editing option {green ${prop}}`);
            let ident = "$" + propArray[0];

            if (configHelpers[ident]) {
                newConfigObject = _extends({}, configObject, (await configHelpers[ident](propArray)));
            } else {
                log(chalk`No helper for {red ${ident}}`);
                return;
            }
        }

        //Create readable json and make sure the user is ok with it
        let newConfig = JSON.stringify(newConfigObject, null, 4);
        log(newConfig);

        if (!(await askQuestion("Write this config to disk?"))) return;
        fs.writeFileSync(configFile, newConfig);
        log(chalk`Created file {green ${configFile}}.`);

        if (!(await askQuestion("Chmod to 600"))) return;
        fs.chmodSync(configFile, "600");
        log(chalk`Changed file to user r/w only`);
    }
}, (_applyDecoratedDescriptor$1(_obj$1, "help", [_dec, _dec2, _dec3], Object.getOwnPropertyDescriptor(_obj$1, "help"), _obj$1), _applyDecoratedDescriptor$1(_obj$1, "preset", [_dec4, _dec5, _dec6, _dec7, _dec8], Object.getOwnPropertyDescriptor(_obj$1, "preset"), _obj$1), _applyDecoratedDescriptor$1(_obj$1, "rule", [_dec9, _dec10, _dec11, _dec12], Object.getOwnPropertyDescriptor(_obj$1, "rule"), _obj$1), _applyDecoratedDescriptor$1(_obj$1, "providers", [_dec13, _dec14, _dec15, _dec16], Object.getOwnPropertyDescriptor(_obj$1, "providers"), _obj$1), _applyDecoratedDescriptor$1(_obj$1, "config", [_dec17, _dec18, _dec19], Object.getOwnPropertyDescriptor(_obj$1, "config"), _obj$1)), _obj$1));

async function noCommand() {
    write(chalk`
Rally Tools {yellow v${version}} CLI
by John Schmidt <John_Schmidt@discovery.com>
`);
    if (!configObject) {
        write(chalk`
It looks like you haven't setup the config yet. Please run '{green rally config}'.
`);
        return;
    }
    for (let env of ["UAT", "DEV", "PROD"]) {
        //Test access. Returns HTTP response code
        let result = await rallyFunctions.testAccess(env);

        //Create a colored display and response
        let resultStr = "{yellow ${result} <unknown>";
        if (result === 200) resultStr = chalk`{green 200 OK}`;else if (result === 401) resultStr = chalk`{red 401 No Access}`;else if (result >= 500) resultStr = chalk`{yellow ${result} API Down?}`;

        log(chalk`   ${env}: ${resultStr}`);
    }
}

async function $main() {
    chalk.enabled = configObject ? configObject.chalk : true;
    if (chalk.level === 0 || !chalk.enabled) {
        let force = argv["force-color"];
        if (force) {
            chalk.enabled = true;
            if (force === true && chalk.level === 0) {
                chalk.level = 1;
            } else if (Number(force)) {
                chalk.level = Number(force);
            }
        }
    }

    let func = argv._[0];
    if (cli[func]) {
        try {
            //Call the cli function
            let ret = await cli[func](argv);
            if (ret) {
                write(chalk.white("CLI returned: "));
                log(ret);
            }
        } catch (e) {
            if (e instanceof AbortError) {
                log(chalk`{red CLI Aborted}: ${e.message}`);
            } else {
                throw e;
            }
        }
    } else {
        await noCommand();
    }
}

async function main$1(...args) {
    try {
        await $main(...args);
    } catch (e) {
        errorLog(e.stack);
    }
}

main$1();
//# sourceMappingURL=bundle.js.map
